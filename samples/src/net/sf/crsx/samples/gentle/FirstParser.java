/* Generated By:JavaCC: Do not edit this line. FirstParser.java */
package net.sf.crsx.samples.gentle;

/** PG Grammar for HACS module net.sf.crsx.samples.gentle.First.
 * @version $Id: FirstParser.jj,v 1.13 2014/01/06 03:11:35 krisrose Exp $
 */
public class FirstParser implements net.sf.crsx.Parser, FirstParserConstants {
        /** Factory. */
        net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
        /** Compilation unit name for error messages. */
        String unit;
        /** Whether the parser should capture token locations. */
        boolean captureLocations = true;
        /** Constructor with token location information. */
        private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
        {
                net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
                if (t == null) t = token;
                if (captureLocations && t != null)
                {
                        if (factory.get("meta") == null)
                                c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
                }
                return c;
        }

        /** Helper interface with category non-terminal calls. */
        abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
        /** Direct category invocations. */
        java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
        {
                categoryCall.put("first", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Int$WithEOF(sink, bound);} });
                categoryCall.put("firstInt", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Int$WithEOF(sink, bound);} });
                categoryCall.put("firstFloat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Float$WithEOF(sink, bound);} });
                categoryCall.put("firstId", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Id$WithEOF(sink, bound);} });
                categoryCall.put("firstStat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Stat$WithEOF(sink, bound);} });
                categoryCall.put("firstExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Exp$WithEOF(sink, bound);} });
                categoryCall.put("firstName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Name$WithEOF(sink, bound);} });
                categoryCall.put("firstT", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_T$WithEOF(sink, bound);} });
                categoryCall.put("firstI_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_I_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstI_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_I_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstI_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_I_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstTmp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Tmp$WithEOF(sink, bound);} });
                categoryCall.put("firstA_Progr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_A_Progr$WithEOF(sink, bound);} });
                categoryCall.put("firstA_Instr", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_A_Instr$WithEOF(sink, bound);} });
                categoryCall.put("firstA_Arg", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_A_Arg$WithEOF(sink, bound);} });
                categoryCall.put("firstStat_MaybeSome", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Stat_MaybeSome$WithEOF(sink, bound);} });
        }

        // Constructor.

        /** Construct dummy instance. */
        public FirstParser()
        {
                this((java.io.Reader) null);
                disable_tracing();
        }

        // Parser implementation.

        public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
        {
                if (factory != null)
                {
                        net.sf.crsx.Parser parser = new FirstParser().parser(f);
                        parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
                        return parser;
                }
                else
                {
                        factory = f;
                        assert f != null : "Or Else!";
                        return this;
                }
        }

        public void setParserVerbose(boolean verbose)
        {
                if (verbose)
                        enable_tracing();
                else
                        disable_tracing();
        }

        public void setParserLocation(boolean capture)
        {
                captureLocations = capture;
        }

        public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
        {}

        public Iterable<String> categories()
        {
                return categoryCall.keySet();
        }

        public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                try
                {
                        this.unit = unit;
                        ReInit((java.io.Reader) null);
                        jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new FirstParserTokenManager(jj_input_stream); // hacks to update line and column numbers
                        if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
                        if (category == null || category.length() == 0) return N_Int(sink, bound);
                        else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
                        else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
                }
                catch (ParseException e)
                {
                        throw new net.sf.crsx.CRSException(e.getMessage());
                }
        }

        public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
                parse(buffer.sink(), category, reader, null, 1, 1, bound);
                return buffer.term(true);
        }


static String unmeta(String s, int i) {String inner = s.substring(1, s.length()-1).trim(); return (inner.length() > i ? inner.substring(i) : inner).trim();}

        /**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
        public static void main(String[] args)
        {
                try
                {
                        if (args.length != 2)
                        {
                                System.err.println("Usage: FirstParser category input");
                                System.exit(2);
                        }
                        String category = args[0];
                        java.io.Reader reader = new java.io.FileReader(args[1]);
                        net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
                        net.sf.crsx.Parser parser = new FirstParser();
                        net.sf.crsx.Sink sink = factory.sink(System.out);
                        parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
                }
                catch (net.sf.crsx.CRSException e)
                {
                        System.err.println("CRS error: "+e);
                        System.exit(1);
                }
                catch (java.io.IOException e)
                {
                        System.err.println("I/O error: "+e);
                        System.exit(1);
                }
        }

/* GRAMMAR. */

/* Productions for Int token. */

/** <em>Int$WithEOF</em> ::= <em>Int</em> EOF . */
  final public net.sf.crsx.Sink N_Int$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Int$WithEOF");
    try {
      sink = N_Int(sink, env);
      jj_consume_token(0);
                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Int$WithEOF");
    }
  }

/**
 * <em>Int</em> ::=   <a href="#T_meta1_T_M_INT">meta1_T_M_INT</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_INT">meta2_T_M_INT</a><font color="red">$$:%{unmeta(#,3)%}</font>  <br>
 *  |   <a href="#T_T_M_INT">T_M_INT</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Int(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Int");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_INT:
        t = jj_consume_token(T_meta1_T_M_INT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_INT:
        t = jj_consume_token(T_meta2_T_M_INT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),3)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_INT:
        t = jj_consume_token(T_T_M_INT);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Int");
    }
  }

/* Productions for Float token. */

/** <em>Float$WithEOF</em> ::= <em>Float</em> EOF . */
  final public net.sf.crsx.Sink N_Float$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Float$WithEOF");
    try {
      sink = N_Float(sink, env);
      jj_consume_token(0);
                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Float$WithEOF");
    }
  }

/**
 * <em>Float</em> ::=   <a href="#T_meta1_T_M_FLOAT">meta1_T_M_FLOAT</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_FLOAT">meta2_T_M_FLOAT</a><font color="red">$$:%{unmeta(#,5)%}</font>  <br>
 *  |   <a href="#T_T_M_FLOAT">T_M_FLOAT</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Float(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Float");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_FLOAT:
        t = jj_consume_token(T_meta1_T_M_FLOAT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_FLOAT:
        t = jj_consume_token(T_meta2_T_M_FLOAT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),5)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_FLOAT:
        t = jj_consume_token(T_T_M_FLOAT);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Float");
    }
  }

/* Productions for Id token. */

/** <em>Id$WithEOF</em> ::= <em>Id</em> EOF . */
  final public net.sf.crsx.Sink N_Id$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Id$WithEOF");
    try {
      sink = N_Id(sink, env);
      jj_consume_token(0);
                              {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Id$WithEOF");
    }
  }

/**
 * <em>Id</em> ::=   <a href="#T_meta1_T_M_ID">meta1_T_M_ID</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_ID">meta2_T_M_ID</a><font color="red">$$:%{unmeta(#,2)%}</font>  <br>
 *  |   <a href="#T_T_M_ID">T_M_ID</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Id(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Id");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_ID:
        t = jj_consume_token(T_meta1_T_M_ID);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_ID:
        t = jj_consume_token(T_meta2_T_M_ID);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),2)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_ID:
        t = jj_consume_token(T_T_M_ID);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Id");
    }
  }

/* Productions for Stat sort with (highest) precedence 0. */

/** <em>Stat$WithEOF</em> ::= <em>Stat</em> EOF . */
  final public net.sf.crsx.Sink N_Stat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Stat$WithEOF");
    try {
      sink = N_Stat(sink, env);
      jj_consume_token(0);
                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Stat$WithEOF");
    }
  }

/**
 * <em>Stat</em> ::=   <a href="#T_meta1_T_M_STAT">meta1_T_M_STAT</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_STAT">meta2_T_M_STAT</a><font color="red">$$:%{unmeta(#,4)%}</font>  <br>
 *  |  (   "<code>TA</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>   <font color="red">{{ Stat__M_TA_Stat[#_Stat_1]}}</font>  |  (   "<code>TA2</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>   <font color="red">{{ Stat__M_TA2_Stat[#_Stat_1]}}</font>  |  (   "<code>{</code>"   <a href="#N_Stat_MaybeSome">&lang;Stat_MaybeSome&rang;</a> <font color="red">:#_Stat_1</font>    "<code>}</code>"   <font color="red">{{Stat__M__7b_Stat__M__7d[#_Stat_1]}}</font>  |  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>    "<code>:=</code>"   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#_Exp_2</font>    "<code>;</code>"   <font color="red">{{Stat_Name__M__3a_3d_Exp__M__3b[#_Name_1, #_Exp_2]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_Stat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Stat");
    try {
        net.sf.crsx.Sink bs___Stat_1 = null;
        net.sf.crsx.Sink bs___Name_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___Stat_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_2 = null;
        net.sf.crsx.util.Buffer b___Exp_2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_STAT:
        t = jj_consume_token(T_meta1_T_M_STAT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_STAT:
        t = jj_consume_token(T_meta2_T_M_STAT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),4)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case 19:
      case 20:
      case 21:
      case T_meta1_T_M_NAME:
      case T_meta2_T_M_NAME:
      case T_T_M_ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 19:
          jj_consume_token(19);
                        bs___Stat_1 = b___Stat_1.sink();
          N_Stat(bs___Stat_1, env);
                        sink = sink .start(sink.makeConstructor("Stat__M_TA_Stat")) .copy(b___Stat_1, true) .end() ;
          break;
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case 20:
        case 21:
        case T_meta1_T_M_NAME:
        case T_meta2_T_M_NAME:
        case T_T_M_ID:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 20:
            jj_consume_token(20);
                                bs___Stat_1 = b___Stat_1.sink();
            N_Stat(bs___Stat_1, env);
                                sink = sink .start(sink.makeConstructor("Stat__M_TA2_Stat")) .copy(b___Stat_1, true) .end() ;
            break;
          case T_meta1_T_M_ID:
          case T_meta2_T_M_ID:
          case 21:
          case T_meta1_T_M_NAME:
          case T_meta2_T_M_NAME:
          case T_T_M_ID:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 21:
              jj_consume_token(21);
                                        bs___Stat_1 = b___Stat_1.sink();
              N_Stat_MaybeSome(bs___Stat_1, env);
              jj_consume_token(22);
                                        sink = sink .start(sink.makeConstructor("Stat__M__7b_Stat__M__7d")) .copy(b___Stat_1, true) .end() ;
              break;
            case T_meta1_T_M_ID:
            case T_meta2_T_M_ID:
            case T_meta1_T_M_NAME:
            case T_meta2_T_M_NAME:
            case T_T_M_ID:
                                        bs___Name_1 = b___Name_1.sink();
              N_Name(bs___Name_1, env);
              jj_consume_token(23);
                                        bs___Exp_2 = b___Exp_2.sink();
              N_Exp(bs___Exp_2, env);
              jj_consume_token(24);
                                        sink = sink .start(sink.makeConstructor("Stat_Name__M__3a_3d_Exp__M__3b")) .copy(b___Name_1, true) .copy(b___Exp_2, true) .end() ;
              break;
            default:
              jj_la1[3] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Stat");
    }
  }

/* Productions for Exp sort with precedence 0. */

/** <em>Exp$WithEOF</em> ::= <em>Exp</em> EOF . */
  final public net.sf.crsx.Sink N_Exp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp$WithEOF");
    try {
      sink = N_Exp(sink, env);
      jj_consume_token(0);
                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp$WithEOF");
    }
  }

/**
 * <em>Exp</em> ::=  (   "<code>TA</code>"   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#_Exp_1</font>   <font color="red">{{ Exp__M_TA_Exp[#_Exp_1]}}</font>  |  <a href="#N_Exp1">&lang;Exp1&rang;</a> <font color="red">:#_Exp_1</font>   <font color="red">{{#_Exp_1}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Exp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp");
    try {
        Token t = null;
        net.sf.crsx.Sink bs___Exp_1 = null;
        net.sf.crsx.util.Buffer b___Exp_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 19:
        jj_consume_token(19);
                        bs___Exp_1 = b___Exp_1.sink();
        N_Exp(bs___Exp_1, env);
                        sink = sink .start(sink.makeConstructor("Exp__M_TA_Exp")) .copy(b___Exp_1, true) .end() ;
        break;
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_FLOAT:
      case T_meta2_T_M_FLOAT:
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case 33:
      case T_meta1_T_M_EXP:
      case T_meta2_T_M_EXP:
      case T_meta1_T_M_NAME:
      case T_meta2_T_M_NAME:
      case T_T_M_INT:
      case T_T_M_FLOAT:
      case T_T_M_ID:
                        bs___Exp_1 = b___Exp_1.sink();
        N_Exp1(bs___Exp_1, env);
                        sink = sink .copy(b___Exp_1, true) ;
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp");
    }
  }

/* Productions for Exp sort with precedence 1. */

/* Handle left recursion. */

/**
 * <em>Exp1LR</em> ::=   "<code>+</code>"   <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#_Exp_2</font>   <a href="#N_Exp1LR">&lang;Exp1LR {{Exp1_LR__M__2b_Exp[#1, #_Exp_2]}}&rang;</a>   <br>
 *  |  <font color="red">{{#1}}</font> 
 */
  final public net.sf.crsx.Sink N_Exp1LR(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__1) throws ParseException {
    trace_call("N_Exp1LR");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_2 = null;
        net.sf.crsx.util.Buffer b___Exp_2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 31:
        jj_consume_token(31);
                bs___Exp_2 = b___Exp_2.sink();
        N_Exp2(bs___Exp_2, env);
                s1 = b1.sink();
                s1 .start(s1.makeConstructor("Exp1_LR__M__2b_Exp")) .copy(b__1, false) .copy(b___Exp_2, true) .end() ;
        sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[8] = jj_gen;
                sink = sink .copy(b__1, false) ;
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp1LR");
    }
  }

/**
 * <em>Exp1</em> ::=  <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#_Exp_1</font>   <a href="#N_Exp1LR">&lang;Exp1LR {{#_Exp_1}}&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Exp1(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp1");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_1 = null;
        net.sf.crsx.util.Buffer b___Exp_1 = new net.sf.crsx.util.Buffer(sink);
                bs___Exp_1 = b___Exp_1.sink();
      N_Exp2(bs___Exp_1, env);
                s1 = b1.sink();
                s1 .copy(b___Exp_1, true) ;
      sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp1");
    }
  }

/* Productions for Exp sort with precedence 2. */

/* Handle left recursion. */

/**
 * <em>Exp2LR</em> ::=   "<code>*</code>"   <a href="#N_Exp3">&lang;Exp3&rang;</a> <font color="red">:#_Exp_2</font>   <a href="#N_Exp2LR">&lang;Exp2LR {{Exp2_LR__M__2a_Exp[#1, #_Exp_2]}}&rang;</a>   <br>
 *  |  <font color="red">{{#1}}</font> 
 */
  final public net.sf.crsx.Sink N_Exp2LR(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__1) throws ParseException {
    trace_call("N_Exp2LR");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_2 = null;
        net.sf.crsx.util.Buffer b___Exp_2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 32:
        jj_consume_token(32);
                bs___Exp_2 = b___Exp_2.sink();
        N_Exp3(bs___Exp_2, env);
                s1 = b1.sink();
                s1 .start(s1.makeConstructor("Exp2_LR__M__2a_Exp")) .copy(b__1, false) .copy(b___Exp_2, true) .end() ;
        sink = N_Exp2LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[9] = jj_gen;
                sink = sink .copy(b__1, false) ;
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp2LR");
    }
  }

/**
 * <em>Exp2</em> ::=  <a href="#N_Exp3">&lang;Exp3&rang;</a> <font color="red">:#_Exp_1</font>   <a href="#N_Exp2LR">&lang;Exp2LR {{#_Exp_1}}&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Exp2(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp2");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Exp_1 = null;
        net.sf.crsx.util.Buffer b___Exp_1 = new net.sf.crsx.util.Buffer(sink);
                bs___Exp_1 = b___Exp_1.sink();
      N_Exp3(bs___Exp_1, env);
                s1 = b1.sink();
                s1 .copy(b___Exp_1, true) ;
      sink = N_Exp2LR(sink, env, b1);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp2");
    }
  }

/* Productions for Exp sort with (highest) precedence 3. */

/**
 * <em>Exp3</em> ::=   <a href="#T_meta1_T_M_EXP">meta1_T_M_EXP</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_EXP">meta2_T_M_EXP</a><font color="red">$$:%{unmeta(#,3)%}</font>  <br>
 *  |  (   "<code>(</code>"   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#</font>    "<code>)</code>"   <font color="red">{{Exp3__M__28_Exp__M__29[#]}}</font>  |  (  <a href="#N_Int">&lang;Int&rang;</a> <font color="red">:#_Int_1</font>   <font color="red">{{Exp3_Int[#_Int_1]}}</font>  |  (  <a href="#N_Float">&lang;Float&rang;</a> <font color="red">:#_Float_1</font>   <font color="red">{{Exp3_Float[#_Float_1]}}</font>  |  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>   <font color="red">{{Exp3_Name[#_Name_1]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_Exp3(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp3");
    try {
        net.sf.crsx.util.Buffer b___Float_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Name_1 = null;
        net.sf.crsx.util.Buffer b___Int_1 = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Int_1 = null;
        net.sf.crsx.Sink bs__ = null;
        net.sf.crsx.Sink bs___Float_1 = null;
        net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_EXP:
        t = jj_consume_token(T_meta1_T_M_EXP);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_EXP:
        t = jj_consume_token(T_meta2_T_M_EXP);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),3)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_FLOAT:
      case T_meta2_T_M_FLOAT:
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case 33:
      case T_meta1_T_M_NAME:
      case T_meta2_T_M_NAME:
      case T_T_M_INT:
      case T_T_M_FLOAT:
      case T_T_M_ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 33:
          jj_consume_token(33);
                        bs__ = b__.sink();
          N_Exp(bs__, env);
          jj_consume_token(34);
                        sink = sink .start(sink.makeConstructor("Exp3__M__28_Exp__M__29")) .copy(b__, true) .end() ;
          break;
        case T_meta1_T_M_INT:
        case T_meta2_T_M_INT:
        case T_meta1_T_M_FLOAT:
        case T_meta2_T_M_FLOAT:
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_NAME:
        case T_meta2_T_M_NAME:
        case T_T_M_INT:
        case T_T_M_FLOAT:
        case T_T_M_ID:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_meta1_T_M_INT:
          case T_meta2_T_M_INT:
          case T_T_M_INT:
                                bs___Int_1 = b___Int_1.sink();
            N_Int(bs___Int_1, env);
                                sink = sink .start(sink.makeConstructor("Exp3_Int")) .copy(b___Int_1, true) .end() ;
            break;
          case T_meta1_T_M_FLOAT:
          case T_meta2_T_M_FLOAT:
          case T_meta1_T_M_ID:
          case T_meta2_T_M_ID:
          case T_meta1_T_M_NAME:
          case T_meta2_T_M_NAME:
          case T_T_M_FLOAT:
          case T_T_M_ID:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case T_meta1_T_M_FLOAT:
            case T_meta2_T_M_FLOAT:
            case T_T_M_FLOAT:
                                        bs___Float_1 = b___Float_1.sink();
              N_Float(bs___Float_1, env);
                                        sink = sink .start(sink.makeConstructor("Exp3_Float")) .copy(b___Float_1, true) .end() ;
              break;
            case T_meta1_T_M_ID:
            case T_meta2_T_M_ID:
            case T_meta1_T_M_NAME:
            case T_meta2_T_M_NAME:
            case T_T_M_ID:
                                        bs___Name_1 = b___Name_1.sink();
              N_Name(bs___Name_1, env);
                                        sink = sink .start(sink.makeConstructor("Exp3_Name")) .copy(b___Name_1, true) .end() ;
              break;
            default:
              jj_la1[10] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[11] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp3");
    }
  }

/* Productions for Name sort with (highest) precedence 0. */

/** <em>Name$WithEOF</em> ::= <em>Name</em> EOF . */
  final public net.sf.crsx.Sink N_Name$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Name$WithEOF");
    try {
      sink = N_Name(sink, env);
      jj_consume_token(0);
                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Name$WithEOF");
    }
  }

/**
 * <em>Name</em> ::=   <a href="#T_meta1_T_M_NAME">meta1_T_M_NAME</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_NAME">meta2_T_M_NAME</a><font color="red">$$:%{unmeta(#,4)%}</font>  <br>
 *  |  <a href="#N_Id">&lang;Id&rang;</a> <font color="red">!!!:#_Id_1</font>   <font color="red">{{#_Id_1}}</font> 
 */
  final public net.sf.crsx.Sink N_Name(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Name");
    try {
        Token t = null;
        String c1 = null;
        net.sf.crsx.Sink bs___Id_1 = null;
        net.sf.crsx.Variable v___Id_1 = null;
        String s___Id_1 = null;
        net.sf.crsx.util.Buffer b___Id_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_NAME:
        t = jj_consume_token(T_meta1_T_M_NAME);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_NAME:
        t = jj_consume_token(T_meta2_T_M_NAME);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),4)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_T_M_ID:
                bs___Id_1 = b___Id_1.sink();
        N_Id(bs___Id_1, env);
                if (b___Id_1.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b___Id_1.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b___Id_1.term(false)+")");}
                c1 = b___Id_1.term(true).constructor().symbol();
                s___Id_1 = c1;
                v___Id_1 = (env.containsKey(s___Id_1) ? env.get(s___Id_1) : factory.freeVariable(s___Id_1, true, true));
                if (v___Id_1 == null) {if (true) throw new ParseException("Variable "+s___Id_1+" cannot be resolved?");}
                sink = sink .use(v___Id_1) ;
         {if (true) return sink;}
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Name");
    }
  }

/* Productions for T token. */

/** <em>T$WithEOF</em> ::= <em>T</em> EOF . */
  final public net.sf.crsx.Sink N_T$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_T$WithEOF");
    try {
      sink = N_T(sink, env);
      jj_consume_token(0);
                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_T$WithEOF");
    }
  }

/**
 * <em>T</em> ::=   <a href="#T_meta1_T_M_T">meta1_T_M_T</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_T">meta2_T_M_T</a><font color="red">$$:%{unmeta(#,1)%}</font>  <br>
 *  |   <a href="#T_T_M_T">T_M_T</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_T(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_T");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_T:
        t = jj_consume_token(T_meta1_T_M_T);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_T:
        t = jj_consume_token(T_meta2_T_M_T);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),1)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_T:
        t = jj_consume_token(T_T_M_T);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_T");
    }
  }

/* Productions for I_Progr sort with (highest) precedence 0. */

/** <em>I_Progr$WithEOF</em> ::= <em>I_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_I_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Progr$WithEOF");
    try {
      sink = N_I_Progr(sink, env);
      jj_consume_token(0);
                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Progr$WithEOF");
    }
  }

/**
 * <em>I_Progr</em> ::=   <a href="#T_meta1_T_M_I_XPROGR">meta1_T_M_I_XPROGR</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_I_XPROGR">meta2_T_M_I_XPROGR</a><font color="red">$$:%{unmeta(#,7)%}</font>  <br>
 *  |  (   "<code>ICG</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>   <font color="red">{{ I_Progr__M_ICG_Stat[#_Stat_1]}}</font>  |  (   "<code>ICGExp</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>   <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">:#_Exp_2</font>   <font color="red">{{ I_Progr__M_ICGExp_Tmp_Exp[#_Tmp_1, #_Exp_2]}}</font>  |  (   "<code>{</code>"   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_1</font>    "<code>}</code>"   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_2</font>   <font color="red">{{ I_Progr__M__7b_I_Progr__M__7d_I_Progr[#_I_Progr_1, #_I_Progr_2]}}</font>  |  (  <a href="#N_I_Instr">&lang;I_Instr&rang;</a> <font color="red">:#_I_Instr_1</font>   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_2</font>   <font color="red">{{I_Progr_I_Instr_I_Progr[#_I_Instr_1, #_I_Progr_2]}}</font>  |  <font color="red">{{I_ProgrEMPTY}}</font>  )  )  )  ) 
 */
  final public net.sf.crsx.Sink N_I_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Progr");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.util.Buffer b___I_Instr_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Progr_2 = null;
        net.sf.crsx.Sink bs___I_Progr_1 = null;
        net.sf.crsx.util.Buffer b___Stat_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___Exp_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Progr_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Instr_1 = null;
        net.sf.crsx.Sink bs___Stat_1 = null;
        Token t = null;
        net.sf.crsx.Sink bs___Exp_2 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Progr_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_I_XPROGR:
        t = jj_consume_token(T_meta1_T_M_I_XPROGR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_I_XPROGR:
        t = jj_consume_token(T_meta2_T_M_I_XPROGR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),7)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      default:
        jj_la1[20] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 53:
          jj_consume_token(53);
                        bs___Stat_1 = b___Stat_1.sink();
          N_Stat(bs___Stat_1, env);
                        sink = sink .start(sink.makeConstructor("I_Progr__M_ICG_Stat")) .copy(b___Stat_1, true) .end() ;
          break;
        default:
          jj_la1[19] = jj_gen;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 54:
            jj_consume_token(54);
                                bs___Tmp_1 = b___Tmp_1.sink();
            N_Tmp(bs___Tmp_1, env);
                                bs___Exp_2 = b___Exp_2.sink();
            N_Exp(bs___Exp_2, env);
                                sink = sink .start(sink.makeConstructor("I_Progr__M_ICGExp_Tmp_Exp")) .copy(b___Tmp_1, true) .copy(b___Exp_2, true) .end() ;
            break;
          default:
            jj_la1[18] = jj_gen;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 21:
              jj_consume_token(21);
                                        bs___I_Progr_1 = b___I_Progr_1.sink();
              N_I_Progr(bs___I_Progr_1, env);
              jj_consume_token(22);
                                        bs___I_Progr_2 = b___I_Progr_2.sink();
              N_I_Progr(bs___I_Progr_2, env);
                                        sink = sink .start(sink.makeConstructor("I_Progr__M__7b_I_Progr__M__7d_I_Progr")) .copy(b___I_Progr_1, true) .copy(b___I_Progr_2, true) .end() ;
              break;
            default:
              jj_la1[17] = jj_gen;
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case T_meta1_T_M_ID:
              case T_meta2_T_M_ID:
              case T_meta1_T_M_NAME:
              case T_meta2_T_M_NAME:
              case T_meta1_T_M_T:
              case T_meta2_T_M_T:
              case T_meta1_T_M_I_XINSTR:
              case T_meta2_T_M_I_XINSTR:
              case T_meta1_T_M_TMP:
              case T_meta2_T_M_TMP:
              case T_T_M_ID:
              case T_T_M_T:
                                                bs___I_Instr_1 = b___I_Instr_1.sink();
                N_I_Instr(bs___I_Instr_1, env);
                                                bs___I_Progr_2 = b___I_Progr_2.sink();
                N_I_Progr(bs___I_Progr_2, env);
                                                sink = sink .start(sink.makeConstructor("I_Progr_I_Instr_I_Progr")) .copy(b___I_Instr_1, true) .copy(b___I_Progr_2, true) .end() ;
                break;
              default:
                jj_la1[16] = jj_gen;
                                                sink = sink .start(sink.makeConstructor("I_ProgrEMPTY")) .end() ;
              }
            }
          }
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Progr");
    }
  }

/* Productions for I_Instr sort with (highest) precedence 0. */

/** <em>I_Instr$WithEOF</em> ::= <em>I_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_I_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Instr$WithEOF");
    try {
      sink = N_I_Instr(sink, env);
      jj_consume_token(0);
                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Instr$WithEOF");
    }
  }

/**
 * <em>I_Instr</em> ::=   <a href="#T_meta1_T_M_I_XINSTR">meta1_T_M_I_XINSTR</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_I_XINSTR">meta2_T_M_I_XINSTR</a><font color="red">$$:%{unmeta(#,7)%}</font>  <br>
 *  |  (  <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>    "<code>=</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_2</font>   (   "<code>*</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_3</font>    "<code>;</code>"   <font color="red">{{I_Instr_Tmp__M__3d_I_Arg__M__2a_I_Arg__M__3b[#_Tmp_1, #_I_Arg_2, #_I_Arg_3]}}</font>  |  (   "<code>+</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_3</font>    "<code>;</code>"   <font color="red">{{I_Instr_Tmp__M__3d_I_Arg__M__2b_I_Arg__M__3b[#_Tmp_1, #_I_Arg_2, #_I_Arg_3]}}</font>  |   "<code>;</code>"   <font color="red">{{I_Instr_Tmp__M__3d_I_Arg__M__3b[#_Tmp_1, #_I_Arg_2]}}</font>  )  )  |  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>    "<code>=</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_2</font>    "<code>;</code>"   <font color="red">{{I_Instr_Name__M__3d_Tmp__M__3b[#_Name_1, #_Tmp_2]}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_I_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Instr");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.Sink bs___Name_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___I_Arg_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Arg_3 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Tmp_2 = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Arg_3 = null;
        net.sf.crsx.util.Buffer b___Tmp_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Arg_2 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_I_XINSTR:
        t = jj_consume_token(T_meta1_T_M_I_XINSTR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_I_XINSTR:
        t = jj_consume_token(T_meta2_T_M_I_XINSTR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),7)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_meta1_T_M_NAME:
      case T_meta2_T_M_NAME:
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_meta1_T_M_TMP:
      case T_meta2_T_M_TMP:
      case T_T_M_ID:
      case T_T_M_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_meta1_T_M_T:
        case T_meta2_T_M_T:
        case T_meta1_T_M_TMP:
        case T_meta2_T_M_TMP:
        case T_T_M_T:
                        bs___Tmp_1 = b___Tmp_1.sink();
          N_Tmp(bs___Tmp_1, env);
          jj_consume_token(61);
                        bs___I_Arg_2 = b___I_Arg_2.sink();
          N_I_Arg(bs___I_Arg_2, env);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 32:
            jj_consume_token(32);
                                bs___I_Arg_3 = b___I_Arg_3.sink();
            N_I_Arg(bs___I_Arg_3, env);
            jj_consume_token(24);
                                sink = sink .start(sink.makeConstructor("I_Instr_Tmp__M__3d_I_Arg__M__2a_I_Arg__M__3b")) .copy(b___Tmp_1, true) .copy(b___I_Arg_2, true) .copy(b___I_Arg_3, true) .end() ;
            break;
          case 24:
          case 31:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 31:
              jj_consume_token(31);
                                        bs___I_Arg_3 = b___I_Arg_3.sink();
              N_I_Arg(bs___I_Arg_3, env);
              jj_consume_token(24);
                                        sink = sink .start(sink.makeConstructor("I_Instr_Tmp__M__3d_I_Arg__M__2b_I_Arg__M__3b")) .copy(b___Tmp_1, true) .copy(b___I_Arg_2, true) .copy(b___I_Arg_3, true) .end() ;
              break;
            case 24:
              jj_consume_token(24);
                                        sink = sink .start(sink.makeConstructor("I_Instr_Tmp__M__3d_I_Arg__M__3b")) .copy(b___Tmp_1, true) .copy(b___I_Arg_2, true) .end() ;
              break;
            default:
              jj_la1[21] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_NAME:
        case T_meta2_T_M_NAME:
        case T_T_M_ID:
                        bs___Name_1 = b___Name_1.sink();
          N_Name(bs___Name_1, env);
          jj_consume_token(61);
                        bs___Tmp_2 = b___Tmp_2.sink();
          N_Tmp(bs___Tmp_2, env);
          jj_consume_token(24);
                        sink = sink .start(sink.makeConstructor("I_Instr_Name__M__3d_Tmp__M__3b")) .copy(b___Name_1, true) .copy(b___Tmp_2, true) .end() ;
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Instr");
    }
  }

/* Productions for I_Arg sort with (highest) precedence 0. */

/** <em>I_Arg$WithEOF</em> ::= <em>I_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_I_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Arg$WithEOF");
    try {
      sink = N_I_Arg(sink, env);
      jj_consume_token(0);
                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Arg$WithEOF");
    }
  }

/**
 * <em>I_Arg</em> ::=   <a href="#T_meta1_T_M_I_XARG">meta1_T_M_I_XARG</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_I_XARG">meta2_T_M_I_XARG</a><font color="red">$$:%{unmeta(#,5)%}</font>  <br>
 *  |  (  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>   <font color="red">{{I_Arg_Name[#_Name_1]}}</font>  |  (  <a href="#N_Float">&lang;Float&rang;</a> <font color="red">:#_Float_1</font>   <font color="red">{{I_Arg_Float[#_Float_1]}}</font>  |  (  <a href="#N_Int">&lang;Int&rang;</a> <font color="red">:#_Int_1</font>   <font color="red">{{I_Arg_Int[#_Int_1]}}</font>  |  <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>   <font color="red">{{I_Arg_Tmp[#_Tmp_1]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_I_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_I_Arg");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.util.Buffer b___Float_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___Int_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Name_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Int_1 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Float_1 = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_I_XARG:
        t = jj_consume_token(T_meta1_T_M_I_XARG);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_I_XARG:
        t = jj_consume_token(T_meta2_T_M_I_XARG);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),5)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_FLOAT:
      case T_meta2_T_M_FLOAT:
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_meta1_T_M_NAME:
      case T_meta2_T_M_NAME:
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_meta1_T_M_TMP:
      case T_meta2_T_M_TMP:
      case T_T_M_INT:
      case T_T_M_FLOAT:
      case T_T_M_ID:
      case T_T_M_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_NAME:
        case T_meta2_T_M_NAME:
        case T_T_M_ID:
                        bs___Name_1 = b___Name_1.sink();
          N_Name(bs___Name_1, env);
                        sink = sink .start(sink.makeConstructor("I_Arg_Name")) .copy(b___Name_1, true) .end() ;
          break;
        case T_meta1_T_M_INT:
        case T_meta2_T_M_INT:
        case T_meta1_T_M_FLOAT:
        case T_meta2_T_M_FLOAT:
        case T_meta1_T_M_T:
        case T_meta2_T_M_T:
        case T_meta1_T_M_TMP:
        case T_meta2_T_M_TMP:
        case T_T_M_INT:
        case T_T_M_FLOAT:
        case T_T_M_T:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_meta1_T_M_FLOAT:
          case T_meta2_T_M_FLOAT:
          case T_T_M_FLOAT:
                                bs___Float_1 = b___Float_1.sink();
            N_Float(bs___Float_1, env);
                                sink = sink .start(sink.makeConstructor("I_Arg_Float")) .copy(b___Float_1, true) .end() ;
            break;
          case T_meta1_T_M_INT:
          case T_meta2_T_M_INT:
          case T_meta1_T_M_T:
          case T_meta2_T_M_T:
          case T_meta1_T_M_TMP:
          case T_meta2_T_M_TMP:
          case T_T_M_INT:
          case T_T_M_T:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case T_meta1_T_M_INT:
            case T_meta2_T_M_INT:
            case T_T_M_INT:
                                        bs___Int_1 = b___Int_1.sink();
              N_Int(bs___Int_1, env);
                                        sink = sink .start(sink.makeConstructor("I_Arg_Int")) .copy(b___Int_1, true) .end() ;
              break;
            case T_meta1_T_M_T:
            case T_meta2_T_M_T:
            case T_meta1_T_M_TMP:
            case T_meta2_T_M_TMP:
            case T_T_M_T:
                                        bs___Tmp_1 = b___Tmp_1.sink();
              N_Tmp(bs___Tmp_1, env);
                                        sink = sink .start(sink.makeConstructor("I_Arg_Tmp")) .copy(b___Tmp_1, true) .end() ;
              break;
            default:
              jj_la1[25] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[26] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_I_Arg");
    }
  }

/* Productions for Tmp sort with (highest) precedence 0. */

/** <em>Tmp$WithEOF</em> ::= <em>Tmp</em> EOF . */
  final public net.sf.crsx.Sink N_Tmp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Tmp$WithEOF");
    try {
      sink = N_Tmp(sink, env);
      jj_consume_token(0);
                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Tmp$WithEOF");
    }
  }

/**
 * <em>Tmp</em> ::=   <a href="#T_meta1_T_M_TMP">meta1_T_M_TMP</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_TMP">meta2_T_M_TMP</a><font color="red">$$:%{unmeta(#,3)%}</font>  <br>
 *  |  <a href="#N_T">&lang;T&rang;</a> <font color="red">!!!:#_T_1</font>   <font color="red">{{#_T_1}}</font> 
 */
  final public net.sf.crsx.Sink N_Tmp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Tmp");
    try {
        net.sf.crsx.Variable v___T_1 = null;
        net.sf.crsx.Sink bs___T_1 = null;
        Token t = null;
        String c1 = null;
        String s___T_1 = null;
        net.sf.crsx.util.Buffer b___T_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_TMP:
        t = jj_consume_token(T_meta1_T_M_TMP);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_TMP:
        t = jj_consume_token(T_meta2_T_M_TMP);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),3)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_T_M_T:
                bs___T_1 = b___T_1.sink();
        N_T(bs___T_1, env);
                if (b___T_1.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b___T_1.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b___T_1.term(false)+")");}
                c1 = b___T_1.term(true).constructor().symbol();
                s___T_1 = c1;
                v___T_1 = (env.containsKey(s___T_1) ? env.get(s___T_1) : factory.freeVariable(s___T_1, true, true));
                if (v___T_1 == null) {if (true) throw new ParseException("Variable "+s___T_1+" cannot be resolved?");}
                sink = sink .use(v___T_1) ;
         {if (true) return sink;}
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Tmp");
    }
  }

/* Productions for A_Progr sort with (highest) precedence 0. */

/** <em>A_Progr$WithEOF</em> ::= <em>A_Progr</em> EOF . */
  final public net.sf.crsx.Sink N_A_Progr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Progr$WithEOF");
    try {
      sink = N_A_Progr(sink, env);
      jj_consume_token(0);
                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Progr$WithEOF");
    }
  }

/**
 * <em>A_Progr</em> ::=   <a href="#T_meta1_T_M_A_XPROGR">meta1_T_M_A_XPROGR</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_A_XPROGR">meta2_T_M_A_XPROGR</a><font color="red">$$:%{unmeta(#,7)%}</font>  <br>
 *  |  (   "<code>CG</code>"   <a href="#N_I_Progr">&lang;I_Progr&rang;</a> <font color="red">:#_I_Progr_1</font>   <font color="red">{{ A_Progr__M_CG_I_Progr[#_I_Progr_1]}}</font>  |  (   "<code>Compile</code>"   <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#_Stat_1</font>   <font color="red">{{ A_Progr__M_Compile_Stat[#_Stat_1]}}</font>  |  (  <a href="#N_A_Instr">&lang;A_Instr&rang;</a> <font color="red">:#_A_Instr_1</font>   <a href="#N_A_Progr">&lang;A_Progr&rang;</a> <font color="red">:#_A_Progr_2</font>   <font color="red">{{A_Progr_A_Instr_A_Progr[#_A_Instr_1, #_A_Progr_2]}}</font>  |  <font color="red">{{A_ProgrEMPTY}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_A_Progr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Progr");
    try {
        net.sf.crsx.util.Buffer b___A_Instr_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___A_Progr_2 = null;
        net.sf.crsx.Sink bs___Stat_1 = null;
        Token t = null;
        net.sf.crsx.util.Buffer b___A_Progr_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Progr_1 = null;
        net.sf.crsx.util.Buffer b___Stat_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___A_Instr_1 = null;
        net.sf.crsx.util.Buffer b___I_Progr_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_A_XPROGR:
        t = jj_consume_token(T_meta1_T_M_A_XPROGR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_A_XPROGR:
        t = jj_consume_token(T_meta2_T_M_A_XPROGR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),7)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      default:
        jj_la1[33] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 80:
          jj_consume_token(80);
                        bs___I_Progr_1 = b___I_Progr_1.sink();
          N_I_Progr(bs___I_Progr_1, env);
                        sink = sink .start(sink.makeConstructor("A_Progr__M_CG_I_Progr")) .copy(b___I_Progr_1, true) .end() ;
          break;
        default:
          jj_la1[32] = jj_gen;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 81:
            jj_consume_token(81);
                                bs___Stat_1 = b___Stat_1.sink();
            N_Stat(bs___Stat_1, env);
                                sink = sink .start(sink.makeConstructor("A_Progr__M_Compile_Stat")) .copy(b___Stat_1, true) .end() ;
            break;
          default:
            jj_la1[31] = jj_gen;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 88:
            case 90:
            case 91:
            case 92:
            case T_meta1_T_M_A_XINSTR:
            case T_meta2_T_M_A_XINSTR:
                                        bs___A_Instr_1 = b___A_Instr_1.sink();
              N_A_Instr(bs___A_Instr_1, env);
                                        bs___A_Progr_2 = b___A_Progr_2.sink();
              N_A_Progr(bs___A_Progr_2, env);
                                        sink = sink .start(sink.makeConstructor("A_Progr_A_Instr_A_Progr")) .copy(b___A_Instr_1, true) .copy(b___A_Progr_2, true) .end() ;
              break;
            default:
              jj_la1[30] = jj_gen;
                                        sink = sink .start(sink.makeConstructor("A_ProgrEMPTY")) .end() ;
            }
          }
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Progr");
    }
  }

/* Productions for A_Instr sort with (highest) precedence 0. */

/** <em>A_Instr$WithEOF</em> ::= <em>A_Instr</em> EOF . */
  final public net.sf.crsx.Sink N_A_Instr$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Instr$WithEOF");
    try {
      sink = N_A_Instr(sink, env);
      jj_consume_token(0);
                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Instr$WithEOF");
    }
  }

/**
 * <em>A_Instr</em> ::=   <a href="#T_meta1_T_M_A_XINSTR">meta1_T_M_A_XINSTR</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_A_XINSTR">meta2_T_M_A_XINSTR</a><font color="red">$$:%{unmeta(#,7)%}</font>  <br>
 *  |  (   "<code>ADDF</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_1</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_2</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_3</font>   <font color="red">{{A_Instr__M_ADDF_A_Arg__M__2c_A_Arg__M__2c_A_Arg[#_A_Arg_1, #_A_Arg_2, #_A_Arg_3]}}</font>  |  (   "<code>LDF</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_2</font>   <font color="red">{{A_Instr__M_LDF_Tmp__M__2c_A_Arg[#_Tmp_1, #_A_Arg_2]}}</font>  |  (   "<code>MULF</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_1</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_2</font>    "<code>,</code>"   <a href="#N_A_Arg">&lang;A_Arg&rang;</a> <font color="red">:#_A_Arg_3</font>   <font color="red">{{A_Instr__M_MULF_A_Arg__M__2c_A_Arg__M__2c_A_Arg[#_A_Arg_1, #_A_Arg_2, #_A_Arg_3]}}</font>  |   "<code>STF</code>"   <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>    "<code>,</code>"   <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_2</font>   <font color="red">{{A_Instr__M_STF_Name__M__2c_Tmp[#_Name_1, #_Tmp_2]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_A_Instr(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Instr");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.Sink bs___Name_1 = null;
        net.sf.crsx.Sink bs___Tmp_2 = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___A_Arg_3 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___A_Arg_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___A_Arg_1 = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Sink bs___A_Arg_3 = null;
        net.sf.crsx.Sink bs___A_Arg_1 = null;
        net.sf.crsx.util.Buffer b___Tmp_2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___A_Arg_2 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_A_XINSTR:
        t = jj_consume_token(T_meta1_T_M_A_XINSTR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_A_XINSTR:
        t = jj_consume_token(T_meta2_T_M_A_XINSTR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),7)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case 88:
      case 90:
      case 91:
      case 92:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 88:
          jj_consume_token(88);
                        bs___A_Arg_1 = b___A_Arg_1.sink();
          N_A_Arg(bs___A_Arg_1, env);
          jj_consume_token(89);
                        bs___A_Arg_2 = b___A_Arg_2.sink();
          N_A_Arg(bs___A_Arg_2, env);
          jj_consume_token(89);
                        bs___A_Arg_3 = b___A_Arg_3.sink();
          N_A_Arg(bs___A_Arg_3, env);
                        sink = sink .start(sink.makeConstructor("A_Instr__M_ADDF_A_Arg__M__2c_A_Arg__M__2c_A_Arg")) .copy(b___A_Arg_1, true) .copy(b___A_Arg_2, true) .copy(b___A_Arg_3, true) .end() ;
          break;
        case 90:
        case 91:
        case 92:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 90:
            jj_consume_token(90);
                                bs___Tmp_1 = b___Tmp_1.sink();
            N_Tmp(bs___Tmp_1, env);
            jj_consume_token(89);
                                bs___A_Arg_2 = b___A_Arg_2.sink();
            N_A_Arg(bs___A_Arg_2, env);
                                sink = sink .start(sink.makeConstructor("A_Instr__M_LDF_Tmp__M__2c_A_Arg")) .copy(b___Tmp_1, true) .copy(b___A_Arg_2, true) .end() ;
            break;
          case 91:
          case 92:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 91:
              jj_consume_token(91);
                                        bs___A_Arg_1 = b___A_Arg_1.sink();
              N_A_Arg(bs___A_Arg_1, env);
              jj_consume_token(89);
                                        bs___A_Arg_2 = b___A_Arg_2.sink();
              N_A_Arg(bs___A_Arg_2, env);
              jj_consume_token(89);
                                        bs___A_Arg_3 = b___A_Arg_3.sink();
              N_A_Arg(bs___A_Arg_3, env);
                                        sink = sink .start(sink.makeConstructor("A_Instr__M_MULF_A_Arg__M__2c_A_Arg__M__2c_A_Arg")) .copy(b___A_Arg_1, true) .copy(b___A_Arg_2, true) .copy(b___A_Arg_3, true) .end() ;
              break;
            case 92:
              jj_consume_token(92);
                                        bs___Name_1 = b___Name_1.sink();
              N_Name(bs___Name_1, env);
              jj_consume_token(89);
                                        bs___Tmp_2 = b___Tmp_2.sink();
              N_Tmp(bs___Tmp_2, env);
                                        sink = sink .start(sink.makeConstructor("A_Instr__M_STF_Name__M__2c_Tmp")) .copy(b___Name_1, true) .copy(b___Tmp_2, true) .end() ;
              break;
            default:
              jj_la1[34] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Instr");
    }
  }

/* Productions for A_Arg sort with (highest) precedence 0. */

/** <em>A_Arg$WithEOF</em> ::= <em>A_Arg</em> EOF . */
  final public net.sf.crsx.Sink N_A_Arg$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Arg$WithEOF");
    try {
      sink = N_A_Arg(sink, env);
      jj_consume_token(0);
                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Arg$WithEOF");
    }
  }

/**
 * <em>A_Arg</em> ::=   <a href="#T_meta1_T_M_A_XARG">meta1_T_M_A_XARG</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_A_XARG">meta2_T_M_A_XARG</a><font color="red">$$:%{unmeta(#,5)%}</font>  <br>
 *  |  (   "<code>#</code>"   (  <a href="#N_Float">&lang;Float&rang;</a> <font color="red">:#_Float_1</font>   <font color="red">{{A_Arg__M__h_Float[#_Float_1]}}</font>  |  <a href="#N_Int">&lang;Int&rang;</a> <font color="red">:#_Int_1</font>   <font color="red">{{A_Arg__M__h_Int[#_Int_1]}}</font>  )  |  (   "<code>[</code>"   <a href="#N_I_Arg">&lang;I_Arg&rang;</a> <font color="red">:#_I_Arg_1</font>    "<code>]</code>"   <font color="red">{{ A_Arg__M__5b_I_Arg__M__5d[#_I_Arg_1]}}</font>  |  (  <a href="#N_Name">&lang;Name&rang;</a> <font color="red">:#_Name_1</font>   <font color="red">{{A_Arg_Name[#_Name_1]}}</font>  |  <a href="#N_Tmp">&lang;Tmp&rang;</a> <font color="red">:#_Tmp_1</font>   <font color="red">{{A_Arg_Tmp[#_Tmp_1]}}</font>  )  )  ) 
 */
  final public net.sf.crsx.Sink N_A_Arg(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_A_Arg");
    try {
        net.sf.crsx.Sink bs___Tmp_1 = null;
        net.sf.crsx.util.Buffer b___Float_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Name_1 = null;
        net.sf.crsx.util.Buffer b___Int_1 = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.util.Buffer b___Name_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b___I_Arg_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___Int_1 = null;
        net.sf.crsx.util.Buffer b___Tmp_1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs___I_Arg_1 = null;
        net.sf.crsx.Sink bs___Float_1 = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_A_XARG:
        t = jj_consume_token(T_meta1_T_M_A_XARG);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_A_XARG:
        t = jj_consume_token(T_meta2_T_M_A_XARG);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),5)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta1_T_M_ID:
      case T_meta2_T_M_ID:
      case T_meta1_T_M_NAME:
      case T_meta2_T_M_NAME:
      case T_meta1_T_M_T:
      case T_meta2_T_M_T:
      case T_meta1_T_M_TMP:
      case T_meta2_T_M_TMP:
      case 99:
      case 100:
      case T_T_M_ID:
      case T_T_M_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 99:
          jj_consume_token(99);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_meta1_T_M_FLOAT:
          case T_meta2_T_M_FLOAT:
          case T_T_M_FLOAT:
                                bs___Float_1 = b___Float_1.sink();
            N_Float(bs___Float_1, env);
                                sink = sink .start(sink.makeConstructor("A_Arg__M__h_Float")) .copy(b___Float_1, true) .end() ;
            break;
          case T_meta1_T_M_INT:
          case T_meta2_T_M_INT:
          case T_T_M_INT:
                                bs___Int_1 = b___Int_1.sink();
            N_Int(bs___Int_1, env);
                                sink = sink .start(sink.makeConstructor("A_Arg__M__h_Int")) .copy(b___Int_1, true) .end() ;
            break;
          default:
            jj_la1[38] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case T_meta1_T_M_NAME:
        case T_meta2_T_M_NAME:
        case T_meta1_T_M_T:
        case T_meta2_T_M_T:
        case T_meta1_T_M_TMP:
        case T_meta2_T_M_TMP:
        case 100:
        case T_T_M_ID:
        case T_T_M_T:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 100:
            jj_consume_token(100);
                                bs___I_Arg_1 = b___I_Arg_1.sink();
            N_I_Arg(bs___I_Arg_1, env);
            jj_consume_token(101);
                                sink = sink .start(sink.makeConstructor("A_Arg__M__5b_I_Arg__M__5d")) .copy(b___I_Arg_1, true) .end() ;
            break;
          case T_meta1_T_M_ID:
          case T_meta2_T_M_ID:
          case T_meta1_T_M_NAME:
          case T_meta2_T_M_NAME:
          case T_meta1_T_M_T:
          case T_meta2_T_M_T:
          case T_meta1_T_M_TMP:
          case T_meta2_T_M_TMP:
          case T_T_M_ID:
          case T_T_M_T:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case T_meta1_T_M_ID:
            case T_meta2_T_M_ID:
            case T_meta1_T_M_NAME:
            case T_meta2_T_M_NAME:
            case T_T_M_ID:
                                        bs___Name_1 = b___Name_1.sink();
              N_Name(bs___Name_1, env);
                                        sink = sink .start(sink.makeConstructor("A_Arg_Name")) .copy(b___Name_1, true) .end() ;
              break;
            case T_meta1_T_M_T:
            case T_meta2_T_M_T:
            case T_meta1_T_M_TMP:
            case T_meta2_T_M_TMP:
            case T_T_M_T:
                                        bs___Tmp_1 = b___Tmp_1.sink();
              N_Tmp(bs___Tmp_1, env);
                                        sink = sink .start(sink.makeConstructor("A_Arg_Tmp")) .copy(b___Tmp_1, true) .end() ;
              break;
            default:
              jj_la1[39] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[40] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_A_Arg");
    }
  }

/** <em>Stat_MaybeSome$WithEOF</em> ::= <em>Stat_MaybeSome</em> EOF . */
  final public net.sf.crsx.Sink N_Stat_MaybeSome$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Stat_MaybeSome$WithEOF");
    try {
      sink = N_Stat_MaybeSome(sink, env);
      jj_consume_token(0);
                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Stat_MaybeSome$WithEOF");
    }
  }

/**
 * <em>Stat_MaybeSome</em> ::=   <a href="#T_meta1_T_M_STAT_XMAYBESOME">meta1_T_M_STAT_XMAYBESOME</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_STAT_XMAYBESOME">meta2_T_M_STAT_XMAYBESOME</a><font color="red">$$:%{unmeta(#,5)%}</font>  <br>
 *  |  (  <a href="#N_Stat">&lang;Stat&rang;</a> <font color="red">:#1</font>   <a href="#N_Stat_MaybeSome">&lang;Stat_MaybeSome&rang;</a> <font color="red">:#2</font>   <font color="red">{{ $Cons[#1,#2] }}</font>  |  <font color="red">{{ $Nil }}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Stat_MaybeSome(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Stat_MaybeSome");
    try {
        Token t = null;
        net.sf.crsx.Sink bs__1 = null;
        net.sf.crsx.Sink bs__2 = null;
        net.sf.crsx.util.Buffer b__2 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_STAT_XMAYBESOME:
        t = jj_consume_token(T_meta1_T_M_STAT_XMAYBESOME);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_STAT_XMAYBESOME:
        t = jj_consume_token(T_meta2_T_M_STAT_XMAYBESOME);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),5)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      default:
        jj_la1[44] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_meta1_T_M_ID:
        case T_meta2_T_M_ID:
        case 19:
        case 20:
        case 21:
        case T_meta1_T_M_STAT:
        case T_meta2_T_M_STAT:
        case T_meta1_T_M_NAME:
        case T_meta2_T_M_NAME:
        case T_T_M_ID:
                        bs__1 = b__1.sink();
          N_Stat(bs__1, env);
                        bs__2 = b__2.sink();
          N_Stat_MaybeSome(bs__2, env);
                        sink = sink .start(sink.makeConstructor("$Cons")) .copy(b__1, true) .copy(b__2, true) .end() ;
          break;
        default:
          jj_la1[43] = jj_gen;
                        sink = sink .start(sink.makeConstructor("$Nil")) .end() ;
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Stat_MaybeSome");
    }
  }

  /** Generated Token Manager. */
  public FirstParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[45];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x22,0x880,0x22000,0x222000,0x322000,0x3a2000,0x223a2000,0xa28a2,0x80000000,0x0,0x22880,0x228a2,0x228a2,0x228a2,0x22000,0x0,0x22000,0x200000,0x0,0x0,0x0,0x81000000,0x81000000,0x22000,0x22000,0x22,0x8a2,0x228a2,0x228a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8a2,0x22000,0x22000,0x22000,0x22000,0x223a2000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x2200,0x2200,0x2200,0x2200,0x228a,0x0,0x1,0x2200,0x2200,0x2202,0x228a,0x2200,0x88000,0x4008a200,0x0,0x400000,0x200000,0x8800000,0x0,0x1,0x8a200,0x4008a200,0x88000,0x88000,0x8a200,0x8a200,0x88000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8a200,0x8a200,0x8a200,0x8a200,0x2200,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4404,0x0,0x0,0x0,0x0,0x0,0x0,0x4400,0x4404,0x4400,0x4400,0x4400,0x4510,0x4400,0x3d000000,0x20000,0x10000,0x440000,0x18000000,0x1c000000,0x1d000000,0x3d000000,0x0,0x4400,0x4400,0x4400,0x4400,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x80000,0x100000,0x200000,0x200000,0x200000,0x200000,0x200000,0x380000,0x0,0x0,0x300000,0x380000,0x380000,0x380000,0x200000,0x1000000,0x1200000,0x0,0x0,0x0,0x0,0x0,0x0,0x1200000,0x1200000,0x1080000,0x1180000,0x1380000,0x1380000,0x1000000,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x180000,0x1200000,0x1200010,0x1200018,0x1200458,0x200000,0x11000,};
   }

  /** Constructor with InputStream. */
  public FirstParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FirstParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FirstParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public FirstParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new FirstParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public FirstParser(FirstParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(FirstParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[121];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 45; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 121; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
