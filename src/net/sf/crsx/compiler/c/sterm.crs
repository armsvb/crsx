// Copyright © 2012,2013 IBM Corporation
// $Id: term.crs,v 3.28 2013/12/18 20:16:18 villardl Exp $

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE C FUNCTION BODY FRAGMENT FOR CONTRACTION OF TERM.
//
// Implements the following term functions:
//
// * {#env} ST-send[TERM, sink] - send term to sink
// * {#env} ST-set-binders[BINDERS, sink, ok vars.#[ok, vars]] - set binders and term to a list of variables
// * {#env} ST-set[TERM, sink, variable] - set Term variable (and register > to term)
// * {#env} ST-set-ref[TERM, sink, variable] - set Term reference variable
// * {#env} ST-set-bool[TERM, sink, variable] - set boolean (int) variable
// * {#env} ST-set-int[TERM, sink, variable] - set integer (long long) variable
// * {#env} ST-set-num[TERM, sink, variable] - set generic numeric (double) variable
// * {#env} ST-set-string[TERM, sink, variable] - set allocated string (char*) variable
// * {#env} ST-local-string[TERM, sink, s p.#[s,p]] - invoke # with either local (volatile!) variable name
//                or literal argument string, with post-processing p
//
// * {#env} ST-then-*[OK, ...] - delayed variant of each of the above.
//
// * {#env} ST-substitute[METAVAR, ARGUMENT_TERMS, sink] - send substitution result to sink
//
// Meta-variables expand.
///////////////////////////////////////////////////////////////////////////////////////////////////

STERM[(

$Use["compiler/c/cdefs.crs"];
$Use["compiler/c/evaluators.crs"];

$Lax;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to send term to sink.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-then-send[OK_SORT, Reified_Term, Text] :: Text;

{#env}ST-then-send[OK, #term, #sink] 
→ 
{
    #env; 
    "$pending-props" : TERM[#term]
}
ST-send[#term, #sink]
; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send[Reified_Term, Text] :: Text;
 
// Skip the environment

{#env}ST-send[PROPERTY-REF[#ref, #use, #term], #sink]                                                       → {#env}ST-send[#term, #sink];
{#env}ST-send[PROPERTY[VARIABLE-USE[#key], #value, #term], #sink]                                           → {#env}ST-send[#term, #sink];
{#env}ST-send[PROPERTY[LITERAL[#literal, #sort], #value, #term], #sink]                                     → {#env}ST-send[#term, #sink];
{#env}ST-send[PROPERTY[$[NotMatch,VARIABLE-USE[#1],$[NotMatch,LITERAL[#2,#3],#Key]], #value, #term], #sink] → {#env}ST-send[#term, #sink];

// TODO: the choice between or lazy should be done by placing a marker.
// Currently only use strict evaluation for the top-level construction.

ST-Send-Construction-Function-Strict:
{
    #env; 
    "$tail"         : YES; 
    "$pending-props" : #Pending
}
ST-send[CONSTRUCTION[KFUNCTION, #Symbol, #Binders], #sink] 
→ 
{#env; "$tail" : NO; "$pending-props" : NO}
ST-set-properties[#Pending, (), #sink, ok¹ props¹.
ST-set-binders[ok¹, #Binders, #sink, ok¹ vars¹.
ST-eval-function[ok¹, YES, #Symbol, props¹, vars¹, #sink]]]
;

ST-Send-Construction-Function-Lazy
:
{
    #env; 
    "$tail"         : NO; 
    "$pending-props" : #pending
}
ST-send[CONSTRUCTION[KFUNCTION, #symbol, #binders], #sink]  // TODO: add a marker to force strict evaluation.
→
%n⟪« 
{#env; "$tail": NO; "$pending-props" : NO}ST-send-properties[#pending, #sink]  »
START(«#sink», «EventConstructor[#symbol]»);⟦« 
{#env; "$tail": NO; "$pending-props" : NO}ST-send-binders[#binders, #sink] »⟧
END(«#sink», «EventConstructor[#symbol]»);«ST-send-tail[NO]»⟫
;

ST-Send-Construction-Data
:
{
    #env; 
    "$tail"         : #tail; 
    "$pending-props" : #pending
}
ST-send[CONSTRUCTION[KDATA, #symbol, #binders], #sink] 
→
%n⟪«
{#env; "$tail": NO; "$pending-props": NO}ST-send-properties[#pending, #sink]»
START(«#sink», «EventConstructor[#symbol]»);⟦« 
{#env; "$tail": NO; "$pending-props": NO}ST-send-binders[#binders, #sink] »⟧
END(«#sink», «EventConstructor[#symbol]»);«ST-send-tail[#tail]»⟫
;

ST-Send-Literal
:
{
    #env;
    "$tail"         : #tail; 
    "$pending-props" : #pending
}  
ST-send[LITERAL[#literal, #sort], #sink] 
→
%n⟪«{#env; "$tail": NO; "$pending-props": NO}ST-send-properties[#pending, #sink]»¶LITERAL(«#sink», (char *)«STRING[#literal]»);«ST-send-tail[#tail]»⟫
;

ST-Send-Variable
:
{#env}ST-send[VARIABLE-USE[#variable], #sink] 
→
{#env}ST-send-variable[Check-bound-hidden[$[{#env}Get, #variable, FRESH]], #variable, #sink]
;

ST-Send-MetaApplication
:
{   
    #env; 
    "$tail"         : #tail; 
    "$pending-props" : #pending
}
ST-send[META-APPLICATION[#metavar, #arguments, #occ], #sink]
→
%n⟪«{#env; "$tail": NO; "$pending-props": NO}ST-send-properties[#pending, #sink]»«
    {#env; "$tail": NO; "$pending-props": NO}ST-substitute[#metavar, #arguments, #occ, #sink]»«
    ST-send-tail[#tail]»⟫;

ST-Send-Evaluator // TODO: check $PendingProps is NO
:
{#env}ST-send[EVALUATOR[#primitive, #terms, #options], #sink] 
→
{#env; "$pending-props": NO}E-send[Primitive[#primitive], #terms, #options, #sink]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-variable[$Boolean, Reified_Variable, Text] :: Text;

{#env; "$tail": #tail} 
ST-send-variable[$True, #variable, #sink] 
→
%n⟪¶USEF(«#sink»);«ST-send-tail[#tail]»⟫;

{#env; "$tail": #tail} 
ST-send-variable[$False, #variable, #sink] 
→
%n⟪¶USE(«#sink», linkVariable(«#sink»->context, «#variable»));«ST-send-tail[#tail]»⟫;



ST-send-tail[STRING_ENTRY] :: Text;

ST-send-tail[YES]   → %n⟪¶return 1;⟫;
ST-send-tail[NO]    → %n⟪⟫;

ST-send-tail2[STRING_ENTRY] :: Text;

ST-send-tail2[YES]  → %n⟪¶return ⟫;
ST-send-tail2[NO]   → %n⟪¶⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-eval-function[OK_SORT, STRING_ENTRY, $String, $List[Text], $List[Text], Text] :: Text;

{#env}
ST-eval-function[OK, #tail, #symbol, #props, #vars, #sink] → // vars  are in order 
    %n⟪«ST-send-tail2[#tail]»«MANGLE[#symbol]»(«#sink», 1«{#env}ST-function-args-props[#props]»«{#env}ST-function-args[#vars]»);⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-function-args[$List[Text]] :: Text;

{#env}ST-function-args[()]            → %n⟪⟫ ;
{#env}ST-function-args[(#Arg; #Args)] → %n⟪, «#Arg»«{#env}ST-function-args[#Args]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-function-args-props[$List[Text]] :: Text;

{#env}ST-function-args-props[()]            → %n⟪, NULL, NULL⟫;
{#env}ST-function-args-props[(#Arg;#Args)]  → {#env}ST-function-args[(#Arg;#Args)];


//------------
// Send the properties to a sink

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-properties[STRING_ENTRY, Text] :: Text;
 
{#env}ST-send-properties[NO, #sink]             → %n⟨⟩;
{#env}ST-send-properties[TERM[#term], #sink]      → {#env}ST-send-properties-term[#term, #sink];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-properties-term[Reified_Term, Text] :: Text;

{#env}ST-send-properties-term[PROPERTY-REF[#ref, #use, #term], #sink] →
    {#env}ST-send-property-ref[$[{#env}Get[STRING_ENTRY], $[:, "MetaVar$", #ref]], #use, #sink, #term];

ST-Send-Property-Variable-Key[Fresh[value::Text]]
:
{#env}ST-send-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], #sink] →
    %n⟪¶{⟦
Term «value»;« {#env} ST-set[#value, #sink, value] »
«value» = NORMALIZEP(«#sink»->context, «value»);
ADD_PROPERTY_VARIABLE(«#sink», linkVariable(«#sink»->context, «#key»), «value»); ⟧
}« {#env} ST-send-properties-term[#term, #sink] »⟫;

ST-Send-Property-Literal-Key[Fresh[value::Text]]
:
{#env}ST-send-properties-term[PROPERTY[LITERAL[#Literal, #Sort], #Value, #Term], #sink] 
→
%n⟪¶{⟦
Term «value»;« {#env} ST-set[#Value, #sink, value] »
«value» = NORMALIZEP(«#sink»->context, «value»);
ADD_PROPERTY_NAMED(«#sink», (char *) « STRING[#Literal] », «value»);⟧
}« {#env} ST-send-properties-term[#Term, #sink] »⟫
;

ST-Send-Property-other[Fresh[key::Text, value::Text]]
:
{#env}ST-send-properties-term[PROPERTY[$[NotMatch,VARIABLE-USE[#1],$[NotMatch,LITERAL[#2,#3],#Key]], #Value, #Term], #sink] 
→
%n⟪¶{⟦ 
Term «key», «value»;« {#env} ST-set-ref[#Key, #sink, key] »« {#env} ST-set[#Value, #sink, value] »
«value» = NORMALIZEP(«#sink»->context, «value»);
ADD_PROPERTY(«#sink», «key», «value»);«ST-unlink-ref[#sink, key] »« {#env} ST-send-properties-term[#Term, #sink] »⟧}⟫
;

// Ignore all other cases.
{#env}ST-send-properties-term[CONSTRUCTION[#Kind, #Symbol, #Binders], #sink]        → %n⟨⟩;
{#env}ST-send-properties-term[LITERAL[#Value, #Sort], #sink]                        → %n⟨⟩;
{#env}ST-send-properties-term[VARIABLE-USE[#Variable ], #sink]                      → %n⟨⟩;
{#env}ST-send-properties-term[META-APPLICATION[#metavar, #Binders, #Use ], #sink]   → %n⟨⟩;
{#env}ST-send-properties-term[EVALUATOR[#Name, #Terms, #Options], #sink]            → %n⟨⟩;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-property-ref[STRING_ENTRY, Reified_Use, Text, Reified_Term] :: Text;

{#env}
ST-send-property-ref[PROPERTY_VARIABLE[#namedP, #varP], USE[#count], #sink, #term]
→
%n⟪«$[If, $[Equal, #count, 1], // Last use?
    %n⟨
ADD_PROPERTIES(‹#sink›, ‹#namedP ›, ‹#varP›);⟩,
    %n⟨
ADD_PROPERTIES(‹#sink›, LINK_NamedPropertyLink(‹#sink›->context, ‹#namedP ›), LINK_VariablePropertyLink(‹#sink›->context, ‹#varP›));⟩
]»« {#env} ST-send-properties-term[#term, #sink] »⟫
;

//------------

// Set the properties to be then used in strict function.
// Add property variable in reverse order as ST-function-args reverses them.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-properties[STRING_ENTRY, $List[Reified_Variable], Text, ok¹::OK_SORT props¹::$List[Reified_Variable].Text] :: Text;

{#env}ST-set-properties[NO, #props, #sink, ok¹ props.#[ok¹, props]] → {#env}#[OK, #props];

{#env}ST-set-properties[TERM[#term], #props, #sink, ok¹ props¹.#[ok¹, props¹]] 
→
{#env}ST-set-properties-term[#term, #props,  #sink, ok¹ props¹.#[ok¹, props¹]];
 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-properties-term[Reified_Term, $List[Reified_Variable], Text, ok¹::OK_SORT props¹::$List[Reified_Variable].Text] :: Text;

{#env}ST-set-properties-term[PROPERTY-REF[#ref, #use, #term], #props, #sink, ok¹ props¹.#[ok¹, props¹]] 
→
{#env}ST-set-properties-ref[$[{#env}Get[STRING_ENTRY], $[:, "MetaVar$", #ref]], #use, #term, #sink, ok¹ props¹.#[ok¹, props¹]];

-[Fresh[varP::Text, namedP::Text]]
:
{#env}ST-set-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], (), #sink, ok¹ props¹.#[ok¹, props¹]] 
→
%n⟪¶NamedPropertyLink «namedP» = NULL;
VariablePropertyLink «varP» = NULL;« 
{#env} ST-set-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], (namedP; varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫
;

ST-set-property-Variable-Key[Fresh[value::Text]]
:
{#env}ST-set-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] 
→
%n⟪¶Term «value»;{⟦« {#env} ST-set[#value, #sink, value] »⟧¶}
«value» = NORMALIZEP(«#sink»->context, «value»);
«#varP» = addVariableProperty(«#sink»->context, «#varP», linkVariable(«#sink»->context, «#key»), «value»);« {#env}ST-set-properties-term[#term, (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;

-[Fresh[varP::Text, namedP::Text]]
:
{#env}ST-set-properties-term[PROPERTY[LITERAL[#literal, #sort],  #value, #term], (), #sink, ok¹ props¹.#[ok¹, props¹]]
→
%n⟪¶NamedPropertyLink «namedP» = NULL; 
VariablePropertyLink «varP» = NULL;« 
{#env} ST-set-properties-term[PROPERTY[LITERAL[#literal, #sort], #value, #term], (namedP; varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;

ST-set-property-Literal-Key[Fresh[value::Text]]
:
{#env}ST-set-properties-term[PROPERTY[LITERAL[#literal, #sort], #value, #term], (#namedP;#varP;), #sink, ok¹ props¹.#[ok¹, props¹]] 
→
%n⟪
Term «value»;¶{⟦« {#env} ST-set[#value, #sink, value] »⟧¶}
«value» = NORMALIZEP(«#sink»->context, «value»);
«#namedP» = addNamedProperty(«#sink»->context, «#namedP», (char *) « STRING[#literal] », «value»);« 
{#env}ST-set-properties-term[#term,  (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;

ST-set-property-other[Fresh[key::Text, value::Text]]
:
{#env}
ST-set-properties-term[PROPERTY[$[NotMatch,VARIABLE-USE[#1],$[NotMatch,LITERAL[#2,#3],#key]], #value, #term], (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]]
→
%n⟪
Term «key», «value»;{⟦« {#env} ST-set-ref[#key, #sink, key] »« {#env} ST-set[#value, #sink, value] »⟧¶}
«value» = NORMALIZEP(«#sink»->context, «value»);
if (IS_VARIABLE_USE(«key»))
    «#varP» = addVariableProperty(«#sink»->context, «#varP», linkVariable(«#sink»->context, VARIABLE(«key»)), «value»);
else
    «#namedP» = addNamedProperty(«#sink»->context, «#namedP», SYMBOL(« key »), «value»);
«ST-unlink-ref[#sink, key] »« {#env} ST-set-properties-term[#term, (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;


{#env}ST-set-properties-term[CONSTRUCTION[#kind, #symbol, #binders], #props, #sink, ok¹ props¹.#[ok¹, props¹]]      → {#env}#[OK, #props];
{#env}ST-set-properties-term[CONSTRUCTION[#kind, #symbol, #binders], #props, #sink, ok¹ props¹.#[ok¹, props¹]]      → {#env}#[OK, #props];
{#env}ST-set-properties-term[LITERAL[#value, #sort], #props, #sink, ok¹ props¹.#[ok¹, props¹]]                      → {#env}#[OK, #props];
{#env}ST-set-properties-term[VARIABLE-USE[#variable], #props, #sink, ok¹ props¹.#[ok¹, props¹]]                     → {#env}#[OK, #props];
{#env}ST-set-properties-term[META-APPLICATION[#metavar, #binders, #use], #props, #sink, ok¹ props¹.#[ok¹, props¹]]  → {#env}#[OK, #props];
{#env}ST-set-properties-term[EVALUATOR[#name, #terms, #options], #props, #sink, ok¹ props¹.#[ok¹, props¹]]          → {#env}#[OK, #props];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-properties-ref[STRING_ENTRY, Reified_Use, Reified_Term, Text, ok¹::OK_SORT props¹::$List[Reified_Variable].Text] :: Text;

-[Fresh[namedP::Text, varP::Text]]
:
{#env}
ST-set-properties-ref[PROPERTY_VARIABLE[#namedP, #varP], USE[#count], #term, #sink, ok¹ props¹.#[ok¹, props¹]]
→   
$[If, $[Equal, #count, 1], // Last use?
    {#env}ST-set-properties-term[#term, (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]],
    %n⟪
NamedPropertyLink ‹namedP›  = LINK_NamedPropertyLink(‹#sink›->context, ‹#namedP›);
VariablePropertyLink ‹varP› = LINK_VariablePropertyLink(‹#sink›->context, ‹#varP›);«
{#env}ST-set-properties-term[#term, (namedP; varP;), #sink, ok¹ props¹.#[ok¹, props¹]]»⟫]
;

// -----------------------
// Generate code for sending construction subterms, starting with binders.
//

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binders[$List[Reified_Binder], Text] :: Text;

{#env}ST-send-binders[(), #sink] → %n⟪⟫;

{#env}ST-send-binders[(#binder; #binders), #sink] 
→
%n⟪« {#env}ST-send-binder[HasFunctionalBinders[#binder], #binder, #sink] »« {#env}ST-send-binders[#binders, #sink] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binder[$Boolean, Reified_Binder, Text] :: Text;

// Subterm without binders. This is just a term to send
{#env}ST-send-binder[#has, ARGUMENT[#sort, #term], #sink] 
→
{#env}ST-then-send[OK, #term, #sink];

// Has functional binders : function argument is a closure so no need to send binder.
{#env}ST-send-binder[$True, #binder, #sink] 
→ 
{#env}ST-send-closure-binder[#binder, #sink];

// Has no functional binders : expect Variables and a Term  
// First analyze the binders for potential reuse
{#env}ST-send-binder[$False, #binder, #sink] 
→
{#env}ST-analyze-binders[OK, #binder, #sink, ok¹ vars.ST-send-binder1[OK, #binder, vars, #sink]];

// TODO: Consolidate ST-send-binder and ST-set-term-binder.
// TODO: Factor out redundant code if BOUND and !BOUND case.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binder1[OK_SORT, Reified_Binder, $List[Text], Text] :: Text;

// Since all binders can be reused, generate a case rebinding them. 
// Note that binders can't be reused if shared.
{#env; "$all_reused": YES}
ST-send-binder1[OK, #binder, (#var; #vars), #sink] 
→
%n⟪¶if (!IS_BOUND(«#var»))¶{ /* Reuse */⟦ «{#env}ST-send-binder2[#binder, (#var; #vars), (), #sink, $True]» ⟧¶} ¶else¶{ /* Substitute */⟦« {#env}ST-send-binder2[#binder, (#var; #vars), (), #sink, $False] » ⟧¶}⟫;

// Can't be reused. Just generate the no rebind case.
{#env; "$all_reused": NO}
ST-send-binder1[OK, #binder, #vars, #sink] 
→
{#env}
ST-send-binder2[#binder, #vars, (), #sink, $False];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binder2[Reified_Binder, $List[Text], $List[Text], Text, $Boolean /* true: reuse, false: copy */] :: Text;

-[Fresh[binds::Text]]
:
{#env}ST-send-binder2[ARGUMENT[#sort, #term], (), (#binder; #binders), #sink, #reuse] 
→
%n⟪¶Variable «binds»[«INTEGER[Length[#binders, 1]]»] = {«#binder»«ConcatText[#binders, %n⟨, ⟩]»};
BINDS(«#sink», «INTEGER[Length[#binders, 1]]», «binds»);«{#env}ST-then-send[OK, #term, #sink]»⟫;

-[Free[reused::Text]]
:
{#env; reused: BOUNDREUSE}
ST-send-binder2[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (reused; #vars), #binders, #sink, $True] 
→ 
%n⟪¶REBIND(«reused»);« {#env}ST-send-binder2[#binder[reused], #vars, Append[#binders,(reused;)], #sink, $True] »⟫;

-[Free[noreuse], Fresh[new::Text]]
:
{#env; noreuse: BOUNDREUSE}
ST-send-binder2[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (noreuse; #vars), #binders, #sink, $False]
→
%n⟪¶Variable «new» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«new»");« {#env; new: BOUND}ST-send-binder2[#binder[new], #vars, Append[#binders,(new;)], #sink, $False] »⟫;

-[Free[noreuse::Text], Fresh[new::Text]]
:
{#env; noreuse: BOUND}
ST-send-binder2[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (noreuse; #vars), #binders, #sink, $False] 
→
%n⟪¶Variable «new» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«new»");« {#env; new: BOUND}ST-send-binder2[#binder[new], #vars, Append[#binders,(new;)], #sink, $False] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-closure-binder[Reified_Binder, Text] :: Text;

{#env}ST-send-closure-binder[ARGUMENT[#sort, #term], #sink] 
→
{#env}ST-then-send[OK, #term, #sink];

-[Fresh[b::Reified_Variable]]:
{#env}ST-send-closure-binder[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], #sink] 
→
{#env; b: BOUND_FUN}ST-send-closure-binder[#binder[b], #sink];

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to substitute what was matched by meta-application, with substitutions. 

// ST-substitute builds information for either copying or substituting.
//
// Do a plain copy if all variables have been previously marked for *Reuse, otherwise a full substitution is necessary.
//
// Consider case when meta-variable matches a closure

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute[$String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env}ST-substitute[#metavar, #binders, #use, #sink] 
→
{#env}ST-substitute0[$[{#env}Get[STRING_ENTRY], $[:, "MetaVar$", #metavar]], #metavar, #binders, #use, #sink];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute0[STRING_ENTRY, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// Case 1: top-level meta-variable. Copy or Substitute
-[Free[var::Reified_Variable]]
:
{#env; var: ARG[#Index, $True]}   
ST-substitute0[VARIABLE[var], #metavar, #Binders, #Use, #sink] 
→
{#env}ST-substitute1[#metavar, #Binders, #Use, #sink];

// Case 2: top-level closure. Either invoke or copy.
-[Free[var::Reified_Variable]]
:
{#env; var: ARG[#Index, $False]} 
ST-substitute0[VARIABLE[var], #metavar, #binders, #use, #sink] 
→
{#env}ST-call[var, #metavar, #binders, #use, #sink];

// Case 3: sub meta-variable.. 
-[Free[var::Reified_Variable]]:
{#env; var:SUB[#parent, #i, $True]} // Sub data term. Copy or Substitute
ST-substitute0[VARIABLE[var], #metavar, #binders, #use, #sink] 
→
{#env}ST-substitute1[#metavar, #binders, #use, #sink];

// Case 4: sub closure
-[Free[var::Reified_Variable]]
:
{#env; var: SUB[#parent, #i, $True]} // Sub function term. Should not occur
ST-substitute0[VARIABLE[var], #metavar, #Binders, #Use, #sink]
→
$[Error, "Cannot have sub-function with binders"];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute1[$String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// The meta variable has no argument. Just copy.
{#env; "$tail": #Tail}
ST-substitute1[#metavar, (), USE[#Count], #sink] 
→
$[If, $[Equal, #Count, 1],
    %n⟪¶COPY(«#sink», « {#env}MetaVar[#metavar] »);« ST-send-tail[#Tail] »⟫, // Give up the reference own by the step function 
    %n⟪¶COPY(«#sink», LINK(«#sink»->context, « {#env}MetaVar[#metavar] »)); « ST-send-tail[#Tail] »⟫];

// The meta variable has arguments. Analyze whether substitution is needed.
{#env}ST-substitute1[#metavar, (#argument1; #arguments), #occ, #sink] 
→
{#env}ST-substitute2[#metavar, (#argument1; #arguments), #occ, #sink, 0, %n⟪⟫, %n⟪⟫, %n⟪⟫, %n⟪⟫, $True, 0];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute2[$String, $List[Reified_Binder], Reified_Use, Text, $Numeric, Text, Text, Text, Text, $Boolean, $Numeric] :: Text;

// Process substitution argument.
{#env}ST-substitute2[#metavar, (ARGUMENT[#sort, #term]; #arguments), #occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used] 
→
{#env}ST-substitute3[{#env} T-CheckReuse[#term], #metavar, #term, $[:,#metavar,"$",$[FormatNumber, #index]], #arguments, #occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used];

// Generate COPY instruction for explicit substitution.
{#env; "$tail": #Tail}
ST-substitute2[#metavar, (), USE[#Count], #sink, #arity, #prefix, #vars, #args, #sep, $True, #used] 
→
$[If, $[Equal, #Count, 1],
  %n⟪¶COPY(«#sink», « {#env}MetaVar[#metavar] »);« ST-send-tail[#Tail] »⟫,
  %n⟪¶COPY(«#sink», LINK(«#sink»->context, « {#env}MetaVar[#metavar] »));« ST-send-tail[#Tail] »⟫];

// Generate full SUBSTITUTE instruction for non-explicit substitution.
-[Fresh[substitution::Text, vars::Text, args::Text]]
:
{#env; "$tail": #Tail}
ST-substitute2[#metavar, (), USE[#Count], #sink, #arity, #prefix, #vars, #args, #sep, $False, #used]
→
%n⟪« #prefix »
Variable «vars»[«INTEGER[#used]»] = {«#vars»};
Term «args»[«INTEGER[#used]»] = {«#args»};
struct _SubstitutionFrame «substitution» = {NULL, 0, «INTEGER[#used]», «vars», «args»};
SUBSTITUTE(«#sink», «$[If, $[Equal, #Count, 1], %n⟨⟩, ST-link-prefix[#sink]]»«{#env}MetaVar[#metavar]»«$[If, $[Equal, #Count, 1],%n⟨⟩, %n⟨)⟩]», &«substitution»);« ST-send-tail[#Tail] »⟫;

// Skip reusable substitution component.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute3[T_REUSE_SORT, $String, Reified_Term, $String, $List[Reified_Binder], Reified_Use, Text, $Numeric, Text, Text, Text, Text, $Boolean, $Numeric] :: Text;

{#env}ST-substitute3[T_REUSE, #metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used]
→
{#env}ST-substitute2[#metavar, #Arguments, #Occ, #sink, $[Plus,#index,1], #prefix, #vars, #args, #sep, #explicit, #used];

// Generate non-explicit substitution setup for argument.
{#env}ST-substitute3[T_NO_REUSE, #metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used]
→
{#env}ST-substitute4[$[{#env}Get[STRING_ENTRY], #metavarIndex],#metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used];
 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute4[STRING_ENTRY, $String, Reified_Term, $String, $List[Reified_Binder], Reified_Use, Text, $Numeric, Text, Text, Text, Text, $Boolean, $Numeric] :: Text;

-[Fresh[arg::Text]]
:
{#env}
ST-substitute4[VARIABLE[#var], #metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used]
→
{#env}
ST-substitute2[#metavar, #Arguments, #Occ, #sink, $[Plus,#index,1],
  // prefix extended with reference to argument term.  TODO: linear arguments.
  %n⟪« #prefix »
Term «arg»;« {#env; "$tail": NO}ST-set[#Term, #sink, arg] »⟫,
  // vars and args recorded; separator now known to be comma.
  %n⟪«#vars»«#sep»«#var»⟫, %n⟪«#args»«#sep»«arg»⟫, %n⟪,⟫,
  // explicitness property now lost.
  $False, $[Plus,#used,1]];

ST-link-prefix[Text] :: Text;
ST-link-prefix[#sink] → %n⟪LINK(«#sink»->context,⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-UnlinkLastMetaUse[$String, Reified_Use, Text] :: Text;

{#env}
ST-UnlinkLastMetaUse[#metavar, USE[#Use], #sink]
→
$[If, $[Equal, #Use, 1], %n⟪
UNLINK(«#sink»->context, «{#env}MetaVar[#metavar]»);⟫, %n⟪⟫]
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to call or copy a closure

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call[Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// Closure without arguments. Not possible.
{#env}ST-call[#closure, #metavar, (), #use, #sink] 
→
$[Error, "Internal error: closure without arguments"];

// The meta variable has arguments. Analyze whether call is needed.
{#env}ST-call[#closure, #metavar, (#argument1; #arguments), #use, #sink] 
→
{#env}ST-call1[#closure, #metavar, (#argument1; #arguments), #use, #sink]; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call1[Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// Done. Can reuse.
{#env}ST-call1[#closure, #metavar, (), #use, #sink] 
→
{#env}ST-call-copy[#metavar, #use, #sink];

// Process substitution argument.
{#env}ST-call1[#closure, #metavar, (ARGUMENT[#sort, VARIABLE-USE[#y]]; #arguments), #use, #sink] 
→
{#env}ST-call1-var[$[{#env}Get, #y], #closure, #metavar, #arguments, #use, #sink];

// Not a variable: need to invoke closure
-[Fallback]:
{#env}ST-call1[#closure, #metavar, #arguments, #use, #sink] 
→
{#env}ST-invoke[#closure, #metavar, #arguments, #use, #sink]; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call-copy[$String, Reified_Use, Text] :: Text;

{#env; "$tail": #tail}ST-call-copy[#metavar, USE[#count], #sink]
→
$[If, $[Equal, #count, 1],
  %n⟪¶COPY(«#sink», « {#env}MetaVar[#metavar] »);« ST-send-tail[#tail] »⟫,
  %n⟪¶COPY(«#sink», LINK(«#sink»->context, « {#env}MetaVar[#metavar] »));« ST-send-tail[#tail] »⟫];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call1-var[VARIABLE_ENTRY, Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// A functional binder.. continue.
{#env}ST-call1-var[BOUND_FUN, #closure, #metavar, #arguments, #use, #sink]
→
{#env}ST-call1[#closure, #metavar,  #arguments, #use, #sink];

// Something else... invoke.
-[Fallback]:
{#env}ST-call1-var[#entry, #closure, #metavar, #arguments, #use, #sink]
→
{#env}ST-invoke[#closure, #metavar, #arguments, #use, #sink]; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-invoke[Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env}ST-invoke[#closure, #metavar, #binders, #use, #sink]
→ 
{#env}ST-set-binders[OK, #binders, #sink, ok¹ args¹.
                         ST-invoke2[ok¹, ST-may-link[#closure, #use, #sink], args¹, #metavar, {#env}MetaVarArityNum[#metavar], #sink]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-invoke2[OK_SORT, Text, $List[Text], $String, $Numeric, Text] :: Text;

{#env; "$tail": #tail}
ST-invoke2[OK, #closure, #args, #metavar, #arity, #sink]
→
%n⟪«ST-send-tail2[#tail]»¶CALL(«#sink», «#closure»«ConcatText[#args,%n⟨,⟩]»);⟫;

ST-may-link[Text, Reified_Use, Text] :: Text;

ST-may-link[#term, USE[#count], #sink]
→ 
$[If, $[Equal, #count, 1], 
    #term,
    %n⟨LINK(«#sink»->context, «#term»)⟩];

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to release reference to term to an existing variable.

ST-unlink-ref[Text, Text] :: Text;
ST-unlink-ref[#sink, #variable] → %n⟪¶UNLINK(«#sink»->context, «#variable»);⟫;

// ------------------------
//
// Generate code to capture copy of a bound term to an existing variable.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-binders[OK_SORT, $List[Reified_Binder], Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

{#env}ST-set-binders[OK, #Binders, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→ 
{#env}ST-set-binders2[OK, #Binders, (), #sink, ok¹ vars¹.#[ok¹, vars¹]] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-binders2[OK_SORT, $List[Reified_Binder], $List[Text], Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

// Done. 
{#env}ST-set-binders2[OK, (), #vars, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→ 
{#env}#[OK, #vars];

// Process each arguments, one at a time. Each arguments produces a list of variables
// (of type Variable/Term/Closure) to then be used for calling the function.
{#env}ST-set-binders2[OK, (#binder; #binders), #vars, #sink, ok¹ vars¹.#[ok¹, vars¹]]
→
{#env}ST-set-binder[HasFunctionalBinders[#binder], #binder, #sink, ok¹ vars¹.
      ST-set-binders2[ok¹, #binders, Append[#vars, vars¹], #sink, ok¹ vars¹.
      #[ok¹, vars¹]]];

// If at least one binder is functional, then generate a closure. 
// Otherwise generate Variable for each binder.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-binder[$Boolean, Reified_Binder, Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

// Subterm without binders. This is a term.
{#env}ST-set-binder[#has, ARGUMENT[#sort, #term], #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
{#env}ST-set-to[#term, #sink, var.#[OK, (var;)]];

// With functional binders : function argument is a closure: skip binders.
-[Fresh[b::Reified_Variable]]:
{#env}ST-set-binder[$True, BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], #sink, ok¹ vars¹.#[ok¹, vars¹]]
→
{#env; b:BOUND_FUN}ST-set-binder[$True, #binder[b], #sink, ok¹ vars¹.#[ok¹, vars¹]];
;

// Without functional binders : expect Variables and a Term  
// First analyze the binders for potential reuse and then compute the arguments.
{#env}ST-set-binder[$False, #binder, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
{#env}ST-analyze-binders[OK, #binder, #sink, ok¹ vars.
      ST-set-term-binder[OK, #binder, vars, #sink, ok¹ vars¹.
      #[ok¹, vars¹]]];

//------- 
// Generate arguments of type Variable for binders and Term. 
//
// When all binders can be reused, and not bound (not shared) then just rebind them and copy term  
//  
// In the more general form, the generated code looks like this:
//     
//      Variable b1, ... bn;
//      Term term; 
//      if (!IS_BOUND(ob1))
//      { // Reused
//          b1 = ob1; REBIND(b1);
//          ...
//          term = ... // COPY
//      }
//      else
//      { // Substitute
//          b1 = new Variable ....
//          ...
//              
//          term = ... // SUBSTITUTE
//      }

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder[OK_SORT, Reified_Binder /* The argument */, $List[Reified_Variable] /* The analyzed binders */, Text /* sink */, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

{#env}
ST-set-term-binder[OK, #binder, #binders, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
{#env}
ST-set-term-binder-decls[#binders, (), ok¹ decls.ST-set-term-binder1[ok¹, #binder, #binders, decls, #sink, ok¹ vars¹.#[ok¹, vars¹]]];

// First pass: generate declarations. 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder-decls[$List[Reified_Variable] /* The analyzed binders */, $List[Text] /* The resulting var decls */, ok¹::OK_SORT decls::$List[Text].Text] :: Text;

-[Fresh[term::Text]]
:
{#env}ST-set-term-binder-decls[(), #decls, ok¹ decls.#[ok¹, decls]]
→
%n⟪¶Term «term»; «{#env}#[OK, Append[#decls, (term;)]]»⟫;

-[Fresh[b::Text]]
:
{#env}ST-set-term-binder-decls[(#binder; #binders), #decls, ok¹ decls.#[ok¹, decls]]
→
%n⟪¶Variable «b»;«{#env}ST-set-term-binder-decls[#binders, Append[#decls, (b;)], ok¹ decls.#[ok¹, decls]]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder1[OK_SORT, Reified_Binder /* The argument */, $List[Reified_Variable] /* The analyzed binders */, 
                    $List[Text] /* The variable declarations */, Text /* sink */, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;


{#env}ST-set-term-binder1[OK, #binder, #binders, #decls, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
%n⟪«{#env}ST-set-term-binder2[#binder, #binders, #decls, #sink]»«{#env}#[OK, #decls]»⟫;


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder2[Reified_Binder /* The argument */, $List[Reified_Variable] /* The analyzed binders */, $List[Text] /* The variable declarations */, Text /* sink */] :: Text;

// Since all binders can be reused, generate a case rebinding them. 
// Note that binders can't be reused if shared.
{#env; "$all_reused": YES}
ST-set-term-binder2[#binder, (#var; #binders), #decls, #sink] 
→
%n⟪¶if (!IS_BOUND(«#var»))¶{ /* Reuse */⟦ «{#env}ST-set-term-binder3[#binder, (#var; #binders), #decls, #sink, $True]» ⟧¶} ¶else¶{ /* Substitute */⟦« {#env}ST-set-term-binder3[#binder, (#var; #binders), #decls, #sink, $False] »⟧¶}⟫;

// Can't be reused. Just generate the no rebind case.
{#env; "$all_reused": NO}
ST-set-term-binder2[#binder, #binders, #decls, #sink] 
→
{#env}ST-set-term-binder3[#binder, #binders, #decls, #sink, $False];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder3[Reified_Binder, $List[Reified_Variable], $List[Text], Text, $Boolean /* Enable Reuse */] :: Text;

{#env}ST-set-term-binder3[ARGUMENT[#sort, #term], (), (#vterm;), #sink, #reuse] 
→
{#env}ST-set[#term, #sink, #vterm];

-[Free[reused::Text]]
:
{#env; reused: BOUNDREUSE}
ST-set-term-binder3[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (reused; #binders), (#decl; #decls), #sink, $True] 
→ 
%n⟪¶«#decl» = «reused»; REBIND(«reused»);« {#env}ST-set-term-binder3[#binder[reused], #binders, #decls, #sink, $True] »⟫
;

-[Free[reuse::Text]]
:
{#env; reused: BOUNDREUSE}
ST-set-term-binder3[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (reused; #binders), (#decl; #decls), #sink, $False] 
→ 
%n⟪¶«#decl» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«#decl»");« {#env; #decl: BOUND}ST-set-term-binder3[#binder[#decl], #binders, #decls, #sink, $False] »⟫;

-[Free[new::Text]]
:
{#env; new: BOUND}
ST-set-term-binder3[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (new; #binders), (#decl; #decls), #sink, $False] 
→
%n⟪¶«#decl» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«#decl»");« {#env}ST-set-term-binder3[#binder[#decl], #binders, #decls, #sink, $False] »⟫;

//---------
// Analyze binders and return a list of variables corresponding to the binder.
// 
// Each variable is added to the environment and marked as either BOUND or BOUNDREUSE.
// 
// The property "$all_reused" is set to YES when all binders can be reused, otherwise set to NO

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders[OK_SORT, Reified_Binder, Text, ok¹::OK_SORT vars::$List[Reified_Variable].Text] :: Text;
 
{#env}
ST-analyze-binders[OK, BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #sink, ok¹ vars.#[ok¹, vars]]
→
{#env; "$binders":LIST_VARIABLE[()]; "$all_reused": YES}
ST-analyze-binders1[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #sink, 0, OUTER, ok¹ vars.#[ok¹, vars]]
;

// - Analyze each binder and either allocate it or reuse the unique variable it replaces.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders1[Reified_Binder, Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

{#env}
ST-analyze-binders1[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders2[#occs, NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
;

// - Once all binders are collected ...
{#env; "$binders":LIST_VARIABLE[#Args]}
ST-analyze-binders1[ARGUMENT[#sort, #Term], #sink, #rank, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}
#[OK, #Args] 
;

// -- if binder occurs in exactly one meta-application then record a cookie for that meta-application position and promiscuity -
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders2[$List[Reified_Occurrence], Meta-Occurrence, Reified_Promiscuity, Reified_Kind, 
    Reified_Depth, binder : Reified_Variable . Reified_Binder, Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

// Record first occurrence. Cannot reuse if meta is copied (TODO: revisit!) or if previous binder coudn't have been reused.
{#env}
ST-analyze-binders2[(META-USE[#mv,#k];#occs), NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
$[{#env}IfDef, $[:,"Copy$",#mv],
  {#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]],
  $[If, $[Equal, #state, NO_REUSE],
    {#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]],
    {#env}ST-analyze-binders2[#occs, UNIQUE[$[:,"BinderUnique$",#mv,"$",$[FormatNumber, #k],"$",PromiscuityString[#promisc]]], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]]
]
;

// Case where there is more than one occurrence. Can't reuse
{#env}
ST-analyze-binders2[(META-USE[#mv,#k];#occs), UNIQUE[#cookie], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
;

// Fallback case: process next occurrence
{#env}
ST-analyze-binders2[(#occ;#occs), #cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders2[#occs, #cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
;

// done with occurrence. Move to the next phase
{#env}
ST-analyze-binders2[(), #cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders3[#cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
;

// -- test whether uniquely used local binder was also unique in pattern?
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders3[Meta-Occurrence, Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder, 
    Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

{#env}
ST-analyze-binders3[UNIQUE[#cookie], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
$[{#env}IfDef, #cookie,
  {#env}ST-analyze-binders4[$[{#env}Get[STRING_ENTRY], #cookie], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]],
  {#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
];

// -- binder that can neither be reused. Generate a fresh binder.
{#env}
ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders6[#promisc, #kind, #depth, b.#Binder[b], sink, #index, #state, ok¹ vars.#[ok¹, vars]]
;

// -- outermost reused binder.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders4[STRING_ENTRY, Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder,
     Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

{#env}
ST-analyze-binders4[VARIABLE[#reused], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, OUTER, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders5[#reused, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, REUSING, ok¹ vars.#[ok¹, vars]]
;

// -- following reused binder.
{#env}
ST-analyze-binders4[VARIABLE[#reused], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, REUSING, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders5[#reused, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, REUSING, ok¹ vars.#[ok¹, vars]]
;

// -- binder that should not be reused because we are copying.
{#env}
ST-analyze-binders4[VARIABLE[#reused], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, COPYING, ok¹ vars.#[ok¹, vars]]
→
{#env}
ST-analyze-binders6[#promisc, #kind, #depth, b.#Binder[b], #sink, #index, COPYING, ok¹ vars.#[ok¹, vars]]
;

// --- Generate binder that can be reused.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders5[Text, Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder, 
    Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

-[Free[reused::Text]]
:
{#env; "$binders":LIST_VARIABLE[#binders]}
ST-analyze-binders5[reused, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env; reused : BOUNDREUSE; "$binders":LIST_VARIABLE[Append[#binders, (reused;)]]}
ST-analyze-binders1[#Binder[reused], #sink, $[Plus, #index, 1], #state, ok¹ vars.#[ok¹, vars]]
;

// --- Generate binder that can't be reused.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders6[Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder, 
    Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

-[Fresh[new::Text]]
:
{#env; "$binders":LIST_VARIABLE[#binders]}
ST-analyze-binders6[#promisc, #kind, #depth, b.#Binder[b], sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env; new : BOUND; "$binders":LIST_VARIABLE[Append[#binders, (new;)]]; "$all_reused": NO}
ST-analyze-binders1[#Binder[new], sink, $[Plus, #index, 1], #state, ok¹ vars.#[ok¹, vars]]
;

//--- Generate arguments of type Closure. 
// 
// Either reuse Closure or curry is less argument. 
//

// TODO: CURRYING

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-closure-binder[OK_SORT, Reified_Binder, Text, ok¹::OK_SORT vars¹ /* The variable holding the Closure */::$List[Text].Text] :: Text;

{#env}ST-set-closure-binder[OK, ARGUMENT[#Sort, #Term], #sink, ok¹ vars¹.#[ok¹, vars¹]]
→
{#env}ST-set-closure[#Term, #sink, ok¹ vars¹.#[ok¹, vars¹]];

-[Fresh[b::Reified_Variable]]
:
{#env}ST-set-closure-binder[OK, BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #sink, ok¹ vars¹.#[ok¹, vars¹]]
→
{#env}ST-set-closure-binder[OK, #Binder[b], #sink, ok¹ vars¹.#[ok¹, vars¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-closure[Reified_Term, Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

// x...y.T[ ... ]. A new closure. Compute captured arg
{#env; "$Function":STRING_VALUE[#Function]; "$ClosureCount":NUM_VALUE[#CCount]}
ST-set-closure[CONSTRUCTION[#Kind, #Symbol, #Binders], #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
{#env;"$ClosureCount":NUM_VALUE[$[Plus, #CCount, 1]]}
ST-set-capture[OK, #Binders, (), #sink, ok¹ captureds¹.
ST-set-closure2[ok¹, captureds¹, $[:, #Function, "$CC$", $[FormatNumber, #CCount]], #sink, ok¹ vars¹.#[ok¹, vars¹]]]
;

// x...y.x. A identity closure. TODO: assert the term is x.x (should be simplified before code gen).
-[Fresh[c::Text]]:
{#env}ST-set-closure[VARIABLE-USE[#v], #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
%n⟪¶Closure «c» = ID_CLOSURE;«{#env}#[OK, (c;)]»⟫;

// x...y.#[ ... ]: Reuse closure. No need to capture anything. 
-[Fresh[c::Text]]:
{#env;"$Function":STRING_VALUE[#Function]; "$ClosureCount":NUM_VALUE[#CCount]}
ST-set-closure[META-APPLICATION[#Meta, #Binders, #Use], #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
%n⟪¶Closure «c» = linkClosure(«{#env}MetaVar[#Meta]»);«{#env}#[OK, (c;)]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-closure2[OK_SORT, $List[Text], $String,  Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

-[Fresh[env::Text, c::Text]]:
{#env}ST-set-closure2[OK, #captured, #closurename, #sink, ok¹ vars¹.#[ok¹, vars¹]]
→
%n⟪«ST-init-env[env, #captured, #sink]»
Closure «c» = { (FuncP) &«MANGLE[#closurename]», «env» };«{#env}#[OK, (c;)]»⟫;

ST-init-env[Text, $List[Text], Text] :: Text;

ST-init-env[#env, (), #sink]
→
%n⟪¶CEnv «#env» = NO_CENV;⟫;

ST-init-env[#env, (#captured1; #captured), #sink]
→
ST-init-env2[#env, %n⟪⟫, 0, (#captured1; #captured), #sink];

ST-init-env2[Text, Text, $Numeric, $List[Text], Text] :: Text;

ST-init-env2[#env, #suffix, #count, (), #sink]
→
%n⟪
CEnv «#env» = (CEnv) ALLOCATE(«#sink»->context, (1 + «INTEGER[#count]») * sizeof(void*));
«#env»->refcount = 1;«#suffix»⟫;

ST-init-env2[#env, #suffix, #count, (#captured1; #captured), #sink]
→
ST-init-env2[#env, %n⟪
«#env»->values[«INTEGER[#count]»] = (void*)«#captured1»;«#suffix»⟫, $[Plus, #count, 1], #captured, #sink]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-capture[OK_SORT, $List[Reified_Binder], $List[Text], Text, ok¹::OK_SORT captured¹::$List[Text].Text] :: Text;

{#env}ST-set-capture[OK, (), #captured, #sink, ok¹ captured¹.#[ok¹, captured¹]] 
→
{#env}#[OK, #captured];

{#env}ST-set-capture[OK, (#binder; #binders), #captured, #sink, ok¹ captured¹.#[ok¹, captured¹]] 
→
{#env}ST-set-capture-binder[#binder, #captured, #sink, ok¹ captured¹.ST-set-capture[ok¹, #binders, captured¹, #sink, ok¹ captured¹.#[ok¹, captured¹]]] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-capture-binder[Reified_Binder, $List[Text], Text, ok¹::OK_SORT captured¹::$List[Text].Text] :: Text;

{#env}ST-set-capture-binder[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #Captured, #sink, ok¹ captured¹.#[ok¹, captured¹]]
→
{#env}ST-set-binder[$True, BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #sink, ok¹ vars¹.
      ST-set-capture-binder2[ok¹, vars¹, #Captured, #sink, ok¹ captured¹.#[ok¹, captured¹]]];

{#env}ST-set-capture-binder[ARGUMENT[#sort, #Term], #Captured, #sink, ok¹ captured¹.#[ok¹, captured¹]]
→
{#env}ST-set-capture-argument[#Term, #Captured, #sink, ok¹ captured¹.#[ok¹, captured¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-capture-binder2[OK_SORT, $List[Text], $List[Text], Text, ok¹::OK_SORT captured¹::$List[Text].Text] :: Text;

{#env}ST-set-capture-binder2[OK, #vars, #captured,  #sink, ok¹ captured¹.#[ok¹, captured¹]]
→
{#env}#[OK, Append[#vars, #captured]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-capture-argument[Reified_Term, $List[Text], Text, ok¹::OK_SORT captured¹::$List[Text].Text] :: Text;

// Argument is a variable: check if it is free (and capture) or bound (no capture)
{#env}ST-set-capture-argument[VARIABLE-USE[#v], #Captured, #sink, ok¹ captured¹.#[ok¹, captured¹]] 
→
{#env}ST-set-capture-variable[$[{#env}Get[VARIABLE_ENTRY], #v, BOUND], #v, #Captured, #sink, ok¹ captured¹.#[ok¹, captured¹]] ;

// Capture meta
-[Fresh[capture::Text]]:
{#env}ST-set-capture-argument[META-APPLICATION[#metavar, #binders, #use], #captured, #sink, ok¹ captured¹.#[ok¹, captured¹]] 
→
%n⟪¶Term «capture»;«{#env}ST-set[META-APPLICATION[#metavar, #binders, #use], #sink, capture]»«#[OK, (capture; #captured)]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-capture-variable[VARIABLE_ENTRY, Reified_Variable, $List[Text], Text, ok¹::OK_SORT captured¹::$List[Text].Text] :: Text;

// Capture Free Variable
{#env}ST-set-capture-variable[FREE, #v, #captured, #sink, ok¹ captured¹.#[ok¹, captured¹]] 
→
{#env}#[OK, (#v; #captured)];

// This is a direct binder. No capture.
{#env}ST-set-capture-variable[BOUND, #v, #captured, #sink, ok¹ captured¹.#[ok¹, captured¹]]  
→
{#env}#[OK, #captured];

//---------
// Generate code to capture copy of term to new variable.
//

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-to[Reified_Term, Text, var::Text.Text] :: Text;

// Literals can be created directly.
-[Fresh[literal::Text]]
:
{#env}ST-set-to[LITERAL[#literal, #sort], #sink, var.#[var]]
→
%n⟪¶Term «literal» = makeStringLiteral(«#sink»->context, (char *) «STRING[#literal]»);« {#env}#[literal] »⟫
;

// Evaluators are handled separately...
-[Fresh[variable::Text]]
:
{#env}ST-set-to[EVALUATOR[#primitive, #args, #options], #sink, var.#[var]]
→
%n⟪¶Term «variable»;« {#env}E-set[Primitive[#primitive], #args, #options, #sink, variable] »« {#env}#[variable] »⟫
;

// Meta-Application  
-[Fresh[variable::Text]]
:
{#env}ST-set-to[META-APPLICATION[#metavar, (), USE[#count]], #sink, var.#[var]]
→ 
$[If, $[Equal, #count, 1], 
    {#env}#[{#env}MetaVar[#metavar]],
    %n⟨¶Term «variable» = LINK(«#sink»->context, «{#env}MetaVar[#metavar]»);« {#env}#[variable] »⟩]
;

{#env}ST-set-to[META-APPLICATION[#metavar, (#binder; #binders), #use], #sink, var.#[var]] 
→ 
{#env}ST-set-buffer-to[META-APPLICATION[#metavar, (#binder; #binders), #use], #sink, var.#[var]]
;

// Proper term cases require buffering.
{#env}ST-set-to[PROPERTY-REF[#Ref, #Use, #Term],       #sink, var.#[var]] → {#env}ST-set-buffer-to[PROPERTY-REF[#Ref, #Use, #Term],       #sink, var.#[var]];
{#env}ST-set-to[PROPERTY[#Key, #Value, #Term],         #sink, var.#[var]] → {#env}ST-set-buffer-to[PROPERTY[#Key, #Value, #Term],         #sink, var.#[var]];
{#env}ST-set-to[PROPERTY-NOT[#Key, #Term],             #sink, var.#[var]] → {#env}ST-set-buffer-to[PROPERTY-NOT[#Key, #Term],             #sink, var.#[var]];
{#env}ST-set-to[VARIABLE-USE[#Variable],               #sink, var.#[var]] → {#env}ST-set-buffer-to[VARIABLE-USE[#Variable],               #sink, var.#[var]];
{#env}ST-set-to[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, var.#[var]] → {#env}ST-set-buffer-to[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, var.#[var]];

// Helper to set term variable using temporary buffer.   
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-buffer-to[Reified_Term, Text, var::Text.Text] :: Text;

-[Fresh[buf::Text, variable::Text]]
:
{#env}
ST-set-buffer-to[#term, #sink, var.#[var]]
→
%n⟪
Term «variable»;
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);« {#env}ST-then-send[OK, #term, buf] »
«variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»);⟧
}«{#env}#[variable]»⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture copy of term (actual copy or by reference) to an existing variable.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}ST-then-set[OK, #Term, #sink, #variable] → {#env}ST-set[#Term, #sink, #variable];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set[Reified_Term, Text, Text] :: Text;

// Literals can be created directly.
{#env}ST-set[LITERAL[#Literal, #Sort], #sink, #variable]
→
%n⟪¶«#variable» = makeStringLiteral(«#sink»->context, (char *) «STRING[#Literal]»);⟫;

// Evaluators are handled separately...
{#env}ST-set[EVALUATOR[#primitive, #args, #options], #sink, #variable]
→
{#env}E-set[Primitive[#primitive], #args, #options, #sink, #variable];

// Meta-Application  
{#env} 
ST-set[META-APPLICATION[#metavar, (), USE[#count]], #sink, #variable] 
→ 
$[If, $[Equal, #count, 1], 
    %n⟪¶«#variable» = «{#env}MetaVar[#metavar]»;⟫,
    %n⟪¶«#variable» = LINK(«#sink»->context, «{#env}MetaVar[#metavar]»);⟫
] 
;

-[Fallback]
:
{#env}ST-set[META-APPLICATION[#metavar, #binders, #use], #sink, #variable] 
→ 
{#env}ST-set-buffer[META-APPLICATION[#metavar, #binders, #use], #sink, #variable]
;

// Proper term cases require buffering.
{#env}ST-set[PROPERTY-REF[#Ref, #Use, #Term],       #sink, #variable] → {#env}ST-set-buffer[PROPERTY-REF[#Ref, #Use, #Term],       #sink, #variable] ;
{#env}ST-set[PROPERTY[#Key, #Value, #Term],         #sink, #variable] → {#env}ST-set-buffer[PROPERTY[#Key, #Value, #Term],         #sink, #variable] ;
{#env}ST-set[PROPERTY-NOT[#Key, #Term],             #sink, #variable] → {#env}ST-set-buffer[PROPERTY-NOT[#Key, #Term],             #sink, #variable] ;
{#env}ST-set[VARIABLE-USE[#Variable],               #sink, #variable] → {#env}ST-set-buffer[VARIABLE-USE[#Variable],               #sink, #variable] ;
{#env}ST-set[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, #variable] → {#env}ST-set-buffer[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, #variable] ;

// Helper to set term variable using temporary buffer.   
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-buffer[Reified_Term, Text, Text] :: Text;

-[Fresh[buf::Text]]
:
{#env}
ST-set-buffer[#Term, #sink, #variable]
→
%n⟪
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);« {#env; "$tail":NO}ST-then-send[OK, #Term, buf] »
«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»);⟧
}⟫
;


///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture reference to term to an existing variable.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-ref[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}ST-then-set-ref[OK, #term, #sink, #variable] → {#env}ST-set-ref[#term, #sink, #variable];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-ref[Reified_Term, Text, Text] :: Text;

// Literals can be created directly.
{#env}ST-set-ref[LITERAL[#Literal, #Sort], #sink, #variable]
→
%n⟪¶«#variable» = makeStringLiteral(«#sink»->context, (char *) «STRING[#Literal]»);⟫;

// Most term cases require buffering (like ST-set).
{#env}ST-set-ref[PROPERTY-REF[#Ref, #Use, #Term],        #sink, #variable] → {#env}ST-set-buffer[PROPERTY-REF[#Ref, #Use, #Term],        #sink, #variable] ;
{#env}ST-set-ref[PROPERTY[#Key, #Value, #Term],          #sink, #variable] → {#env}ST-set-buffer[PROPERTY[#Key, #Value, #Term],          #sink, #variable] ;
{#env}ST-set-ref[PROPERTY-NOT[#Key, #Term],              #sink, #variable] → {#env}ST-set-buffer[PROPERTY-NOT[#Key, #Term],              #sink, #variable] ;
{#env}ST-set-ref[VARIABLE-USE[#Variable],                #sink, #variable] → {#env}ST-set-buffer[VARIABLE-USE[#Variable],                #sink, #variable] ;
{#env}ST-set-ref[CONSTRUCTION[#Kind, #Symbol, #Binders], #sink, #variable] → {#env}ST-set-buffer[CONSTRUCTION[#Kind, #Symbol, #Binders], #sink, #variable] ;

// Existing reference used directly.
{#env}ST-set-ref[META-APPLICATION[#metavar, #args, USE[#count]], #sink, #variable] 
→
$[If, $[Equal, #count, 1], 
    %n⟪¶«#variable» = « {#env}MetaVar[#metavar] »;⟫,
    %n⟪¶«#variable» = LINK(«#sink»->context, « {#env}MetaVar[#metavar] »);⟫];

// Evaluators are handled separately...
{#env}ST-set-ref[EVALUATOR[#Primitive, #Args, #Options], #sink, #variable]
→
{#env}E-set-ref[Primitive[#Primitive], #Args, #Options, #sink, #variable];

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing variable of type $Boolean

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-bool[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}
ST-then-set-bool[OK, #Term, #sink, #variable] 
→ 
{#env}
ST-set-bool[#Term, #sink, #variable]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-bool[Reified_Term, Text, Text] :: Text;

{#env} ST-set-bool[LITERAL[#Literal, #Sort], #sink, #bool] → ST-set-bool2[#bool, STRING[#Literal],%n⟪⟫] ;
{#env} ST-set-bool[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #bool] → ST-set-bool2[#bool, STRING[#Symbol],%n⟪⟫] ;

-[Free[v::Reified_Variable]]
:  
{#env}
ST-set-bool[VARIABLE-USE[v], #sink, #bool] 
→ 
ST-set-bool2[#bool, %n⟪
«v»->name⟫, %n⟪⟫] // Error? 
;

{#env} 
ST-set-bool[META-APPLICATION[#metavar, #Args, #Use], #sink, #bool] 
→ 
ST-set-bool2[#bool, %n⟪SYMBOL(« {#env}MetaVar[#metavar] »)⟫,{#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]];

{#env} ST-set-bool[PROPERTY-REF[#Ref, #Use, #Term],        #sink, #bool] → {#env} ST-set-bool[#Term, #sink, #bool] ;
{#env} ST-set-bool[PROPERTY[#Key, #Value, #Term],          #sink, #bool] → {#env} ST-set-bool[#Term, #sink, #bool] ;
{#env} ST-set-bool[PROPERTY-NOT[#Key, #Term],              #sink, #bool] → {#env} ST-set-bool[#Term, #sink, #bool] ;
{#env} ST-set-bool[EVALUATOR[#Primitive, #Args, #Options], #sink, #bool] → {#env} E-set-bool[Primitive[#Primitive], #Args, #Options, #sink, #bool] ;

ST-set-bool2[Text, Text, Text] :: Text;

ST-set-bool2[#bool, #string, #suffix]
→
%n⟪
«#bool» = !strcmp(«#string», True);«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing variable of type $Numeric where an integer is needed

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-int[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}
ST-then-set-int[OK, #Term, #sink, #variable] 
→ 
{#env}
ST-set-int[#Term, #sink, #variable]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-int[Reified_Term, Text, Text] :: Text;

{#env}ST-set-int[LITERAL[#Literal, #Sort],              #sink, #int] → ST-set-int2[#int, %n⟪«TOKEN[#Literal]»ll⟫,%n⟪⟫] ;

{#env}
ST-set-int[META-APPLICATION[#metavar, #Args, #Use], #sink, #int] → 
    ST-set-int2[#int, %n⟪LONGLONG(« {#env}MetaVar[#metavar] »)⟫,{#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]] 
;

{#env}ST-set-int[CONSTRUCTION[#kind, #Symbol, #Binders],       #sink, #int] → ST-set-int2[#int, %n⟪«TOKEN[#Symbol]»ll⟫,%n⟪⟫] ;

-[Free[v::Text]]
:
{#env}
ST-set-int[VARIABLE-USE[v], #sink, #int]
→ 
ST-set-int2[#int, %n⟪LONGLONG(«v»->name)⟫,%n⟪⟫]
; // Error?

{#env}ST-set-int[PROPERTY-REF[#Ref, #Use, #Term],   #sink, #int] → {#env} ST-set-int[#Term, #sink, #int] ;
{#env}ST-set-int[PROPERTY[#Key, #Value, #Term],     #sink, #int] → {#env} ST-set-int[#Term, #sink, #int] ;
{#env}ST-set-int[PROPERTY-NOT[#Key, #Term],         #sink, #int] → {#env} ST-set-int[#Term, #sink, #int] ;

{#env}ST-set-int[EVALUATOR[#Primitive, #Args, #Options], #sink, #int] → {#env} E-set-int[Primitive[#Primitive], #Args, #Options, #sink, #int] ;

ST-set-int2[Text, Text, Text] :: Text;

ST-set-int2[#int, #integer, #suffix]
→
%n⟪
«#int» = «#integer»;«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing variable of type $Numeric when a double is needed

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-num[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}
ST-then-set-num[OK, #Term, #sink, #variable]
→ 
{#env}
ST-set-num[#Term, #sink, #variable]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-num[Reified_Term, Text, Text] :: Text;

{#env}
ST-set-num[LITERAL[#Literal, #Sort], #sink, #num] 
→ 
ST-set-num2[#num, %n⟪
(double) «TOKEN[#Literal]»⟫,%n⟪⟫] 
;

{#env}
ST-set-num[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #num] 
→ 
ST-set-num2[#num, %n⟪
(double) «TOKEN[#Symbol]»⟫,%n⟪⟫]
;

-[Free[v::Text]]
:
{#env}
ST-set-num[VARIABLE-USE[v], #sink, #num] 
→
ST-set-num2[#num, %n⟪
DOUBLE(«v»->name)⟫, %n⟪⟫]
; // Error?

{#env}
ST-set-num[META-APPLICATION[#metavar, #Args, #Use], #sink, #num] 
→  
ST-set-num2[#num, %n⟪DOUBLE(« {#env}MetaVar[#metavar] »)⟫, {#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]] ; 

{#env} ST-set-num[PROPERTY-REF[#Ref, #Use, #Term],   #sink, #num] → {#env} ST-set-num[#Term, #sink, #num] ;
{#env} ST-set-num[PROPERTY[#Key, #Value, #Term],     #sink, #num] → {#env} ST-set-num[#Term, #sink, #num] ;
{#env} ST-set-num[PROPERTY-NOT[#Key, #Term],         #sink, #num] → {#env} ST-set-num[#Term, #sink, #num] ;

{#env} ST-set-num[EVALUATOR[#Primitive, #Args, #Options], #sink, #num] → {#env} E-set-num[Primitive[#Primitive], #Args, #Options, #sink, #num] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-num2[Text, Text, Text] :: Text;

ST-set-num2[#num, #number, #suffix]
→
%n⟪
«#num» = «#number»;«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing allocated variable of type $String

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-string[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}ST-then-set-string[OK, #Term, #sink, #variable] → {#env}ST-set-string[#Term, #sink, #variable];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-string[Reified_Term, Text, Text] :: Text;

{#env}ST-set-string[LITERAL[#Literal, #Sort],               #sink, #string] → ST-set-string2[#string, STRING[#Literal], %n⟪⟫] ;
{#env}ST-set-string[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #string] → ST-set-string2[#string, STRING[#Symbol], %n⟪⟫] ;

-[Free[v::Text]]
: 
{#env}ST-set-string[VARIABLE-USE[v], #sink, #string] 
→ 
ST-set-string2[#string, %n⟪makeString(«#sink»->context, «v»->name)⟫, %n⟪⟫];

{#env}ST-set-string[META-APPLICATION[#metavar, #Args, #Use], #sink, #string] 
→ 
ST-set-string2[#string, %n⟪SYMBOL(« {#env}MetaVar[#metavar] »)⟫, {#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]]; 

{#env}ST-set-string[PROPERTY-REF[#Ref, #Use, #Term],   #sink, #string] → {#env} ST-set-string[#Term, #sink, #string];
{#env}ST-set-string[PROPERTY[#Key, #Value, #Term],     #sink, #string] → {#env} ST-set-string[#Term, #sink, #string];
{#env}ST-set-string[PROPERTY-NOT[#Key, #Term],         #sink, #string] → {#env} ST-set-string[#Term, #sink, #string];

{#env}ST-set-string[EVALUATOR[#Primitive, #Args, #Options], #sink, #string] → {#env} E-set-string[Primitive[#Primitive], #Args, #Options, #sink, #string] ;

ST-set-string2[Text, Text, Text] :: Text;

ST-set-string2[#str, #string, #suffix]
→
%n⟪
«#str» = «#string»;«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to insert one instance of a string value.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-then-local-string[OK_SORT, Reified_Term, Text, s::Text p::Text.Text] :: Text;

{#env}
ST-then-local-string[OK, #Term, #sink, s p .#[s,p]]
→ 
{#env}
ST-local-string[#Term, #sink, s p .#[s,p]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-local-string[Reified_Term, Text, s::Text p::Text.Text] :: Text;

{#env}
ST-local-string[LITERAL[#Literal, #Sort], #sink, s p.#[s,p]]
→
#[STRING[#Literal], %n⟪⟫]
;

{#env}
ST-local-string[META-APPLICATION[#metavar, #Args, #Use], sink, s p.#[s,p]] 
→ 
%n⟪
FORCE(«sink»->context, « {#env}MetaVar[#metavar] »); LINK(«sink»->context, « {#env}MetaVar[#metavar] »);« 
#[%n⟨SYMBOL(‹ {#env}MetaVar[#metavar] ›)⟩, %n⟨UNLINK(‹sink›->context, ‹ {#env}MetaVar[#metavar] ›);‹{#env}ST-UnlinkLastMetaUse[#metavar, #Use, sink]›⟩]»⟫;

{#env}
ST-local-string[VARIABLE-USE[v], #sink, s p.#[s, p]]
→
#[%n⟪«v»->name⟫, %n⟪⟫];

{#env}
ST-local-string[EVALUATOR[#Primitive, #Args, #Options], #sink, s p.#[s,p]]
→
{#env}
E-local-string[Primitive[#Primitive], #Args, #Options, #sink, s p.#[s,p]]
;

{#env}ST-local-string[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, s p.#[s,p]] → {#env}ST-local-string2[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, s p.#[s, p]] ;
{#env}ST-local-string[PROPERTY-REF[#Ref, #Use, #Term], #sink, s p.#[s,p]] → {#env}ST-local-string2[PROPERTY-REF[#Ref, #Use, #Term], #sink, s p.#[s,p]] ;
{#env}ST-local-string[PROPERTY[#Key, #Value, #Term],   #sink, s p.#[s,p]] → {#env}ST-local-string2[PROPERTY[#Key, #Value, #Term],   #sink, s p.#[s,p]] ;
{#env}ST-local-string[PROPERTY-NOT[#Key, #Term],       #sink, s p.#[s,p]] → {#env}ST-local-string2[PROPERTY-NOT[#Key, #Term],       #sink, s p.#[s,p]] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-local-string2[Reified_Term, Text, s::Text p::Text.Text] :: Text;

-[Fresh[t::Text]]
:
{#env}ST-local-string2[#Term, #sink, s p.#[s,p]]
→
%n⟪
Term «t»;« {#env} ST-set-ref[#Term, #sink, t] »
FORCE(«#sink»->context, «t»);« #[%n⟨SYMBOL(‹t›)⟩, ST-unlink-ref[#sink, t]] »⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
)] //ST
