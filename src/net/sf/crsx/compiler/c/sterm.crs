// Copyright © 2012,2013 IBM Corporation
// $Id: term.crs,v 3.28 2013/12/18 20:16:18 villardl Exp $

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE C FUNCTION BODY FRAGMENT FOR CONTRACTION OF TERM.
//
// Implements the following term functions:
//
// * {#env} ST-send[TERM, sink] - send term to sink
// * {#env} ST-set-binders[BINDERS, sink, ok vars.#[ok, vars]] - set binders and term to a list of variables
// * {#env} ST-set[TERM, sink, variable] - set Term variable (and register > to term)
// * {#env} ST-set-ref[TERM, sink, variable] - set Term reference variable
// * {#env} ST-set-bool[TERM, sink, variable] - set boolean (int) variable
// * {#env} ST-set-int[TERM, sink, variable] - set integer (long long) variable
// * {#env} ST-set-num[TERM, sink, variable] - set generic numeric (double) variable
// * {#env} ST-set-string[TERM, sink, variable] - set allocated string (char*) variable
// * {#env} ST-local-string[TERM, sink, s p.#[s,p]] - invoke # with either local (volatile!) variable name
//                or literal argument string, with post-processing p
//
// * {#env} ST-then-*[OK, ...] - delayed variant of each of the above.
//
// * {#env} ST-substitute[METAVAR, ARGUMENT_TERMS, sink] - send substitution result to sink
//
// Meta-variables expand.
///////////////////////////////////////////////////////////////////////////////////////////////////

STERM[(

$Use["compiler/c/cdefs.crs"];
$Use["compiler/c/evaluators.crs"];

$Lax;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to send term to sink.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-then-send[OK_SORT, Reified_Term, Text] :: Text;

{#env}ST-then-send[OK, #term, #sink] 
→ 
{#env; "$pending-props" : TERM[#term]}ST-send[#term, #sink]; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send[Reified_Term, Text] :: Text;
 
// Skip the environment

{#env}ST-send[PROPERTY-REF[#ref, #use, #term], #sink]                                                       → {#env}ST-send[#term, #sink];
{#env}ST-send[PROPERTY[VARIABLE-USE[#key], #value, #term], #sink]                                           → {#env}ST-send[#term, #sink];
{#env}ST-send[PROPERTY[LITERAL[#literal, #sort], #value, #term], #sink]                                     → {#env}ST-send[#term, #sink];
{#env}ST-send[PROPERTY[$[NotMatch,VARIABLE-USE[#1],$[NotMatch,LITERAL[#2,#3],#Key]], #value, #term], #sink] → {#env}ST-send[#term, #sink];

{#env}ST-send[CONSTRUCTION[KFUNCTION, #symbol, #binders], #sink] 
→  {#env}ST-send-function[#symbol, #binders, #sink]; 

ST-Send-Construction-Data:
{#env; 
  "$tail"          : #tail; 
  "$pending-props" : #pending}
ST-send[CONSTRUCTION[KDATA, #symbol, #binders], #sink] 
→ %n⟪«
{#env; "$tail": NO; "$pending-props": NO}ST-send-properties[#pending, #sink]»«{#env; "$tail": NO; "$pending-props": NO; "$eval":NO}ST-send-data[#symbol, #binders, #sink]»«ST-send-tail[#tail]»⟫;

ST-Send-Literal:
{#env;
  "$tail"         : #tail; 
  "$pending-props" : #pending}  
ST-send[LITERAL[#literal, #sort], #sink] 
→ %n⟪«{#env; "$tail": NO; "$pending-props": NO}ST-send-properties[#pending, #sink]»¶LITERAL(«#sink», (char *)«STRING[#literal]»);«ST-send-tail[#tail]»⟫;

ST-Send-Variable:
{#env}ST-send[VARIABLE-USE[#variable], #sink] 
→
{#env}ST-send-variable[$[{#env}Get, #variable, FRESH], #variable, #sink];

ST-Send-MetaApplication:
{#env}ST-send[META-APPLICATION[#metavar, #arguments, #occ], #sink]
→
{#env}ST-substitute[#metavar, #arguments, #occ, #sink];

ST-Send-Evaluator: // TODO: check $PendingProps is NO
{#env}ST-send[EVALUATOR[#primitive, #terms, #options], #sink] 
→
{#env; "$pending-props": NO}E-send[Primitive[#primitive], #terms, #options, #sink];


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-function[$String, $List[Reified_Binder], Text] :: Text;

ST-Send-Construction-Function-Strict:
{
    #env; 
    "$tail"          : YES;  // TODO: should rely on eval.
    "$pending-props" : #Pending
}
ST-send-function[#Symbol, #Binders, #sink] 
→ 
{#env; "$tail" : NO; "$pending-props" : NO; "$eval": NO}
ST-set-properties[#Pending, (), #sink, ok¹ props¹.
ST-set-binders[ok¹, #Binders, #sink, ok¹ vars¹.
ST-eval-function[ok¹, YES, #Symbol, props¹, vars¹, #sink]]];

// Lazy function 
{#env; 
  "$tail"          : NO; 
  "$pending-props" : #pending}
ST-send-function[#symbol, #binders, #sink]  
→ %n⟪« 
{#env; "$tail": NO; "$pending-props" : NO}ST-send-properties[#pending, #sink]  »
START(«#sink», «EventConstructor[#symbol]»);⟦« 
{#env; "$tail": NO; "$pending-props" : NO}ST-send-binders[#binders, #sink] »⟧
END(«#sink», «EventConstructor[#symbol]»);«ST-send-tail[NO]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-variable[VARIABLE_ENTRY, Reified_Variable, Text] :: Text;

{#env; "$tail": #tail} 
ST-send-variable[BOUND_FUN, #variable, #sink] 
→
%n⟪¶USEF(«#sink»);«ST-send-tail[#tail]»⟫;

-[Fallback]:
{#env; "$tail": #tail} 
ST-send-variable[#entry, #variable, #sink] 
→
%n⟪¶USE(«#sink», linkVariable(«#sink»->context, «#variable»));«ST-send-tail[#tail]»⟫;


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-data[$String, $List[Reified_Binder], Text] :: Text;

{#env}ST-send-data[#symbol, (), #sink]
→ %n⟪
COPY(«#sink», LINK(«#sink»->context, (Term) «Const[#symbol]»));⟫;

{#env}ST-send-data[#symbol, (#binder; #binders), #sink]
→ %n⟪
START(«#sink», «EventConstructor[#symbol]»);⟦« 
{#env}ST-send-binders[(#binder; #binders), #sink] »⟧
END(«#sink», «EventConstructor[#symbol]»);
⟫;

ST-send-tail[STRING_ENTRY] :: Text;

ST-send-tail[YES]   → %n⟪¶return 1;⟫;
ST-send-tail[NO]    → %n⟪⟫;

ST-send-tail2[STRING_ENTRY] :: Text;

ST-send-tail2[YES]  → %n⟪¶return ⟫;
ST-send-tail2[NO]   → %n⟪¶⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-eval-function[OK_SORT, STRING_ENTRY, $String, $List[Text], $List[Text], Text] :: Text;

{#env}ST-eval-function[OK, #tail, #symbol, #props, #vars, #sink] // vars  are in order 
→ 
%n⟪«ST-function-spilled-args[#sink, Tail[Tail[#vars]], 2]»«ST-send-tail2[#tail]»«MANGLE[#symbol]»(«#sink», 1«{#env}ST-function-args-props[#props]»«{#env}ST-function-args[#vars, 0, 2]»);⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-function-args[$List[Text], $Numeric, $Numeric] :: Text;

{#env}ST-function-args[(), #c, #max]            → %n⟪⟫ ;

-[Data[#c]]:
{#env}ST-function-args[(#arg; #args), #c, #max] 
→
$[If, $[LessThan, #c, #max], 
    %n⟪, «#arg»«{#env}ST-function-args[#args, Plus[#c, 1], #max]»⟫,
    %n⟪⟫];

ST-function-spilled-args[Text, $List[Text], $Numeric] :: Text;

ST-function-spilled-args[#sink, (), #index]            →  %n⟪⟫;
ST-function-spilled-args[#sink, (#arg; #args), #index] →  %n⟪¶«Spilled[#sink, #index]» = (void*) «#arg»;«ST-function-spilled-args[#sink, #args, Plus[#index, 1]]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-function-args-props[$List[Text]] :: Text;

{#env}ST-function-args-props[()]            → %n⟪, NULL, NULL⟫;
{#env}ST-function-args-props[(#arg; #args)] → {#env}ST-function-args[(#arg; #args), 0, 2];

//------------
// Send the properties to a sink

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-properties[STRING_ENTRY, Text] :: Text;
 
{#env}ST-send-properties[NO, #sink]             → %n⟨⟩;
{#env}ST-send-properties[TERM[#term], #sink]      → {#env}ST-send-properties-term[#term, #sink];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-properties-term[Reified_Term, Text] :: Text;

{#env}ST-send-properties-term[PROPERTY-REF[#ref, #use, #term], #sink] 
→ {#env}ST-send-property-ref[$[{#env}Get[STRING_ENTRY], $[:, "MetaVar$", #ref]], #use, #sink, #term];

ST-Send-Property-Variable-Key[Fresh[value::Text]]:
{#env}ST-send-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], #sink] 
→ %n⟪¶{⟦
Term «value»;« {#env} ST-set[#value, #sink, value] »
«value» = NORMALIZEP(«#sink»->context, «value»);
ADD_PROPERTY_VARIABLE(«#sink», linkVariable(«#sink»->context, «#key»), «value»); ⟧
}« {#env} ST-send-properties-term[#term, #sink] »⟫;

ST-Send-Property-Literal-Key[Fresh[value::Text]]:
{#env}ST-send-properties-term[PROPERTY[LITERAL[#Literal, #Sort], #Value, #Term], #sink] 
→ %n⟪¶{⟦
Term «value»;« {#env} ST-set[#Value, #sink, value] »
«value» = NORMALIZEP(«#sink»->context, «value»);
ADD_PROPERTY_NAMED(«#sink», « Literal[#Literal] », «value»);⟧
}« {#env} ST-send-properties-term[#Term, #sink] »⟫;

ST-Send-Property-other[Fresh[key::Text, value::Text]]:
{#env}ST-send-properties-term[PROPERTY[$[NotMatch,VARIABLE-USE[#1],$[NotMatch,LITERAL[#2,#3],#Key]], #Value, #Term], #sink] 
→ %n⟪¶{⟦ 
Term «key», «value»;« {#env} ST-set-ref[#Key, #sink, key] »« {#env} ST-set[#Value, #sink, value] »
«value» = NORMALIZEP(«#sink»->context, «value»);
ADD_PROPERTY(«#sink», «key», «value»);«ST-unlink-ref[#sink, key] »« {#env} ST-send-properties-term[#Term, #sink] »⟧}⟫;

// Ignore all other cases.
{#env}ST-send-properties-term[CONSTRUCTION[#Kind, #Symbol, #Binders], #sink]        → %n⟨⟩;
{#env}ST-send-properties-term[LITERAL[#Value, #Sort], #sink]                        → %n⟨⟩;
{#env}ST-send-properties-term[VARIABLE-USE[#Variable ], #sink]                      → %n⟨⟩;
{#env}ST-send-properties-term[META-APPLICATION[#metavar, #Binders, #Use ], #sink]   → %n⟨⟩;
{#env}ST-send-properties-term[EVALUATOR[#Name, #Terms, #Options], #sink]            → %n⟨⟩;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-property-ref[STRING_ENTRY, Reified_Use, Text, Reified_Term] :: Text;

{#env}
ST-send-property-ref[PROPERTY_VARIABLE[#namedP, #varP], USE[#count], #sink, #term]
→
%n⟪«$[If, $[Equal, #count, 1], // Last use?
    %n⟨
ADD_PROPERTIES(‹#sink›, ‹#namedP ›, ‹#varP›);⟩,
    %n⟨
ADD_PROPERTIES(‹#sink›, LINK_NamedPropertyLink(‹#sink›->context, ‹#namedP ›), LINK_VariablePropertyLink(‹#sink›->context, ‹#varP›));⟩
]»« {#env} ST-send-properties-term[#term, #sink] »⟫
;

//------------

// Set the properties to be then used in strict function.
// Add property variable in reverse order as ST-function-args reverses them.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-properties[STRING_ENTRY, $List[Reified_Variable], Text, ok¹::OK_SORT props¹::$List[Reified_Variable].Text] :: Text;

{#env}ST-set-properties[NO, #props, #sink, ok¹ props.#[ok¹, props]] → {#env}#[OK, #props];

{#env}ST-set-properties[TERM[#term], #props, #sink, ok¹ props¹.#[ok¹, props¹]] 
→
{#env}ST-set-properties-term[#term, #props,  #sink, ok¹ props¹.#[ok¹, props¹]];
 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-properties-term[Reified_Term, $List[Reified_Variable], Text, ok¹::OK_SORT props¹::$List[Reified_Variable].Text] :: Text;

{#env}ST-set-properties-term[PROPERTY-REF[#ref, #use, #term], #props, #sink, ok¹ props¹.#[ok¹, props¹]] 
→
{#env}ST-set-properties-ref[$[{#env}Get[STRING_ENTRY], $[:, "MetaVar$", #ref]], #use, #term, #sink, ok¹ props¹.#[ok¹, props¹]];

-[Fresh[varP::Text, namedP::Text]]
:
{#env}ST-set-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], (), #sink, ok¹ props¹.#[ok¹, props¹]] 
→
%n⟪¶NamedPropertyLink «namedP» = NULL;
VariablePropertyLink «varP» = NULL;« 
{#env} ST-set-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], (namedP; varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫
;

ST-set-property-Variable-Key[Fresh[value::Text]]
:
{#env}ST-set-properties-term[PROPERTY[VARIABLE-USE[#key], #value, #term], (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] 
→
%n⟪¶Term «value»;{⟦« {#env} ST-set[#value, #sink, value] »⟧¶}
«value» = NORMALIZEP(«#sink»->context, «value»);
«#varP» = addVariableProperty(«#sink»->context, «#varP», linkVariable(«#sink»->context, «#key»), «value»);« {#env}ST-set-properties-term[#term, (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;

-[Fresh[varP::Text, namedP::Text]]
:
{#env}ST-set-properties-term[PROPERTY[LITERAL[#literal, #sort],  #value, #term], (), #sink, ok¹ props¹.#[ok¹, props¹]]
→
%n⟪¶NamedPropertyLink «namedP» = NULL; 
VariablePropertyLink «varP» = NULL;« 
{#env} ST-set-properties-term[PROPERTY[LITERAL[#literal, #sort], #value, #term], (namedP; varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;

ST-set-property-Literal-Key[Fresh[value::Text]]
:
{#env}ST-set-properties-term[PROPERTY[LITERAL[#literal, #sort], #value, #term], (#namedP;#varP;), #sink, ok¹ props¹.#[ok¹, props¹]] 
→
%n⟪
Term «value»;¶{⟦« {#env} ST-set[#value, #sink, value] »⟧¶}
«value» = NORMALIZEP(«#sink»->context, «value»);
«#namedP» = addNamedProperty(«#sink»->context, «#namedP»,  « Literal[#literal] », «value»);« 
{#env}ST-set-properties-term[#term,  (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;

ST-set-property-other[Fresh[key::Text, value::Text, keyStr::Text]]
:
{#env}
ST-set-properties-term[PROPERTY[$[NotMatch,VARIABLE-USE[#1],$[NotMatch,LITERAL[#2,#3],#key]], #value, #term], (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]]
→
%n⟪
Term «key», «value»;{⟦« {#env} ST-set-ref[#key, #sink, key] »« {#env} ST-set[#value, #sink, value] »⟧¶}
«value» = NORMALIZEP(«#sink»->context, «value»);
if (IS_VARIABLE_USE(«key»))
    «#varP» = addVariableProperty(«#sink»->context, «#varP», linkVariable(«#sink»->context, VARIABLE(«key»)), «value»);
else
{
    PooledString «keyStr» = GLOBAL(«#sink»->context, SYMBOL(« key »));
    «#namedP» = addNamedProperty(«#sink»->context, «#namedP», « keyStr », «value»);
}
«ST-unlink-ref[#sink, key] »« {#env} ST-set-properties-term[#term, (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]] »⟫;


{#env}ST-set-properties-term[CONSTRUCTION[#kind, #symbol, #binders], #props, #sink, ok¹ props¹.#[ok¹, props¹]]      → {#env}#[OK, #props];
{#env}ST-set-properties-term[CONSTRUCTION[#kind, #symbol, #binders], #props, #sink, ok¹ props¹.#[ok¹, props¹]]      → {#env}#[OK, #props];
{#env}ST-set-properties-term[LITERAL[#value, #sort], #props, #sink, ok¹ props¹.#[ok¹, props¹]]                      → {#env}#[OK, #props];
{#env}ST-set-properties-term[VARIABLE-USE[#variable], #props, #sink, ok¹ props¹.#[ok¹, props¹]]                     → {#env}#[OK, #props];
{#env}ST-set-properties-term[META-APPLICATION[#metavar, #binders, #use], #props, #sink, ok¹ props¹.#[ok¹, props¹]]  → {#env}#[OK, #props];
{#env}ST-set-properties-term[EVALUATOR[#name, #terms, #options], #props, #sink, ok¹ props¹.#[ok¹, props¹]]          → {#env}#[OK, #props];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-properties-ref[STRING_ENTRY, Reified_Use, Reified_Term, Text, ok¹::OK_SORT props¹::$List[Reified_Variable].Text] :: Text;

-[Fresh[namedP::Text, varP::Text]]
:
{#env}
ST-set-properties-ref[PROPERTY_VARIABLE[#namedP, #varP], USE[#count], #term, #sink, ok¹ props¹.#[ok¹, props¹]]
→   
$[If, $[Equal, #count, 1], // Last use?
    {#env}ST-set-properties-term[#term, (#namedP; #varP;), #sink, ok¹ props¹.#[ok¹, props¹]],
    %n⟪
NamedPropertyLink ‹namedP›  = LINK_NamedPropertyLink(‹#sink›->context, ‹#namedP›);
VariablePropertyLink ‹varP› = LINK_VariablePropertyLink(‹#sink›->context, ‹#varP›);«
{#env}ST-set-properties-term[#term, (namedP; varP;), #sink, ok¹ props¹.#[ok¹, props¹]]»⟫];

// -----------------------
// Generate code for sending construction subterms, starting with binders.
//

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binders[$List[Reified_Binder], Text] :: Text;

{#env}ST-send-binders[(), #sink] → %n⟪⟫;

{#env}ST-send-binders[(#binder; #binders), #sink] 
→
%n⟪« {#env}ST-send-binder[HasFunctionalBinders[#binder], #binder, #sink] »« {#env}ST-send-binders[#binders, #sink] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binder[$Boolean, Reified_Binder, Text] :: Text;

// Subterm without binders. This is just a term to send
{#env}ST-send-binder[#has, ARGUMENT[#sort, #term], #sink] 
→
{#env}ST-then-send[OK, #term, #sink];

// Has functional binders : function argument is a closure so no need to send binder.
{#env}ST-send-binder[$True, #binder, #sink] 
→ 
{#env}ST-send-closure-binder[#binder, #sink];

// Has no functional binders : expect Variables and a Term  
// First analyze the binders for potential reuse
{#env}ST-send-binder[$False, #binder, #sink] 
→
{#env}ST-analyze-binders[OK, #binder, #sink, ok¹ vars.ST-send-binder1[OK, #binder, vars, #sink]];

// TODO: Consolidate ST-send-binder and ST-set-term-binder.
// TODO: Factor out redundant code if BOUND and !BOUND case.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binder1[OK_SORT, Reified_Binder, $List[Text], Text] :: Text;

// Since all binders can be reused, generate a case rebinding them. 
// Note that binders can't be reused if shared.
{#env; "$all_reused": YES}
ST-send-binder1[OK, #binder, (#var; #vars), #sink] 
→
%n⟪¶if (!IS_BOUND(«#var»))¶{ /* Reuse */⟦ «{#env}ST-send-binder2[#binder, (#var; #vars), (), #sink, $True]» ⟧¶} ¶else¶{ /* Substitute */⟦« {#env}ST-send-binder2[#binder, (#var; #vars), (), #sink, $False] » ⟧¶}⟫;

// Can't be reused. Just generate the no rebind case.
{#env; "$all_reused": NO}
ST-send-binder1[OK, #binder, #vars, #sink] 
→
{#env}
ST-send-binder2[#binder, #vars, (), #sink, $False];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-binder2[Reified_Binder, $List[Text], $List[Text], Text, $Boolean /* true: reuse, false: copy */] :: Text;

-[Fresh[binds::Text]]
:
{#env}ST-send-binder2[ARGUMENT[#sort, #term], (), (#binder; #binders), #sink, #reuse] 
→
%n⟪¶Variable «binds»[«INTEGER[Length[#binders, 1]]»] = {«#binder»«ConcatText[#binders, %n⟨, ⟩]»};
BINDS(«#sink», «INTEGER[Length[#binders, 1]]», «binds»);«{#env}ST-then-send[OK, #term, #sink]»⟫;

-[Free[reused::Text]]
:
{#env; reused: BOUNDREUSE}
ST-send-binder2[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (reused; #vars), #binders, #sink, $True] 
→ 
%n⟪¶REBIND(«reused»);« {#env}ST-send-binder2[#binder[reused], #vars, Append[#binders,(reused;)], #sink, $True] »⟫;

-[Free[noreuse], Fresh[new::Text]]
:
{#env; noreuse: BOUNDREUSE}
ST-send-binder2[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (noreuse; #vars), #binders, #sink, $False]
→
%n⟪¶Variable «new» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«new»");« {#env; new: BOUND}ST-send-binder2[#binder[new], #vars, Append[#binders,(new;)], #sink, $False] »⟫;

-[Free[noreuse::Text], Fresh[new::Text]]
:
{#env; noreuse: BOUND}
ST-send-binder2[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (noreuse; #vars), #binders, #sink, $False] 
→
%n⟪¶Variable «new» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«new»");« {#env; new: BOUND}ST-send-binder2[#binder[new], #vars, Append[#binders,(new;)], #sink, $False] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-send-closure-binder[Reified_Binder, Text] :: Text;

{#env}ST-send-closure-binder[ARGUMENT[#sort, #term], #sink] 
→
{#env}ST-then-send[OK, #term, #sink];

-[Fresh[b::Reified_Variable]]:
{#env}ST-send-closure-binder[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], #sink] 
→
{#env; b: BOUND_FUN}ST-send-closure-binder[#binder[b], #sink];

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to substitute what was matched by meta-application, with substitutions. 

// ST-substitute builds information for either copying or substituting.
//
// Do a plain copy if all variables have been previously marked for *Reuse, otherwise a full substitution is necessary.
//
// Consider case when meta-variable matches a closure

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute[$String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env}ST-substitute[#metavar, #binders, #use, #sink] 
→
{#env}ST-substitute0[$[{#env}Get[STRING_ENTRY], $[:, "MetaVar$", #metavar]], #metavar, #binders, #use, #sink];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute0[STRING_ENTRY, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// Case 1: top-level meta-variable. Copy or Substitute
-[Free[var::Reified_Variable]]
:
{#env; var: ARG[#Index, $True]}   
ST-substitute0[VARIABLE[var], #metavar, #arguments, #use, #sink] 
→
{#env}ST-substitute1a[#metavar, #arguments, #use, #sink];

// Case 2: top-level closure. Either invoke or copy.
-[Free[var::Reified_Variable]]
:
{#env; var: ARG[#Index, $False]} 
ST-substitute0[VARIABLE[var], #metavar, #arguments, #use, #sink] 
→
{#env}ST-call[var, #metavar, #arguments, #use, #sink];

// Case 3: sub meta-variable.. 
-[Free[var::Reified_Variable]]:
{#env; var:SUB[#parent, #i, #linked, $True]} // Sub data term. Copy or Substitute
ST-substitute0[VARIABLE[var], #metavar, #arguments, #use, #sink] 
→
{#env}ST-substitute1a[#metavar, #arguments, #use, #sink];

// Case 4: sub closure
-[Free[var::Reified_Variable]]
:
{#env; var: SUB[#parent, #i, $True, $False]} // Sub function.  
ST-substitute0[VARIABLE[var], #metavar, #arguments, #use, #sink]
→
{#env}ST-call[var, #metavar, #arguments, #use, #sink];

// Generate code for substitution. Send properties first  (if any)
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute1a[$String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env; "$pending-props" : #pending}
ST-substitute1a[#metavar, #arguments, #use, #sink]
→
%n⟪«{#env; "$tail": NO; "$pending-props": NO}ST-send-properties[#pending, #sink]»«
    {#env; "$pending-props": NO}ST-substitute1[#metavar, #arguments, #use, #sink]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute1[$String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// The meta variable has no argument. Just copy.
{#env; "$tail": #tail}
ST-substitute1[#metavar, (), USE[#Count], #sink] 
→
$[If, $[Equal, #Count, 1],
    %n⟪¶COPY(«#sink», « {#env}MetaVar[#metavar] »);« ST-send-tail[#tail] »⟫, // Give up the reference own by the step function 
    %n⟪¶COPY(«#sink», LINK(«#sink»->context, « {#env}MetaVar[#metavar] »)); « ST-send-tail[#tail] »⟫];

// The meta variable has arguments. Analyze whether substitution is needed.
{#env}ST-substitute1[#metavar, (#argument1; #arguments), #occ, #sink] 
→
{#env}ST-substitute2[#metavar, (#argument1; #arguments), #occ, #sink, 0, %n⟪⟫, %n⟪⟫, %n⟪⟫, %n⟪⟫, $True, 0];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute2[$String, $List[Reified_Binder], Reified_Use, Text, $Numeric, Text, Text, Text, Text, $Boolean, $Numeric] :: Text;

// Process substitution argument.
{#env}ST-substitute2[#metavar, (ARGUMENT[#sort, #term]; #arguments), #occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used] 
→
{#env}ST-substitute3[{#env} T-CheckReuse[#term], #metavar, #term, $[:,#metavar,"$",$[FormatNumber, #index]], #arguments, #occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used];

// Generate COPY instruction for explicit substitution.
{#env; "$tail": #Tail}
ST-substitute2[#metavar, (), USE[#Count], #sink, #arity, #prefix, #vars, #args, #sep, $True, #used] 
→
$[If, $[Equal, #Count, 1],
  %n⟪¶COPY(«#sink», « {#env}MetaVar[#metavar] »);« ST-send-tail[#Tail] »⟫,
  %n⟪¶COPY(«#sink», LINK(«#sink»->context, « {#env}MetaVar[#metavar] »));« ST-send-tail[#Tail] »⟫];

// Generate full SUBSTITUTE instruction for non-explicit substitution.
-[Fresh[substitution::Text, vars::Text, args::Text]]
:
{#env; "$tail": #Tail}
ST-substitute2[#metavar, (), USE[#Count], #sink, #arity, #prefix, #vars, #args, #sep, $False, #used]
→
%n⟪« #prefix »
Variable «vars»[«INTEGER[#used]»] = {«#vars»};
Term «args»[«INTEGER[#used]»] = {«#args»};
struct _SubstitutionFrame «substitution» = {NULL, 0, «INTEGER[#used]», «vars», «args»};
SUBSTITUTE(«#sink», «$[If, $[Equal, #Count, 1], %n⟨⟩, ST-link-prefix[#sink]]»«{#env}MetaVar[#metavar]»«$[If, $[Equal, #Count, 1],%n⟨⟩, %n⟨)⟩]», &«substitution»);« ST-send-tail[#Tail] »⟫;

// Skip reusable substitution component.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute3[T_REUSE_SORT, $String, Reified_Term, $String, $List[Reified_Binder], Reified_Use, Text, $Numeric, Text, Text, Text, Text, $Boolean, $Numeric] :: Text;

{#env}ST-substitute3[T_REUSE, #metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used]
→
{#env}ST-substitute2[#metavar, #Arguments, #Occ, #sink, $[Plus,#index,1], #prefix, #vars, #args, #sep, #explicit, #used];

// Generate non-explicit substitution setup for argument.
{#env}ST-substitute3[T_NO_REUSE, #metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used]
→
{#env}ST-substitute4[$[{#env}Get[STRING_ENTRY], #metavarIndex],#metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used];
 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-substitute4[STRING_ENTRY, $String, Reified_Term, $String, $List[Reified_Binder], Reified_Use, Text, $Numeric, Text, Text, Text, Text, $Boolean, $Numeric] :: Text;

-[Fresh[arg::Text]]
:
{#env}
ST-substitute4[VARIABLE[#var], #metavar, #Term, #metavarIndex, #Arguments, #Occ, #sink, #index, #prefix, #vars, #args, #sep, #explicit, #used]
→
{#env}
ST-substitute2[#metavar, #Arguments, #Occ, #sink, $[Plus,#index,1],
  // prefix extended with reference to argument term.  TODO: linear arguments.
  %n⟪« #prefix »
Term «arg»;« {#env; "$tail": NO}ST-set[#Term, #sink, arg] »⟫,
  // vars and args recorded; separator now known to be comma.
  %n⟪«#vars»«#sep»«#var»⟫, %n⟪«#args»«#sep»«arg»⟫, %n⟪,⟫,
  // explicitness property now lost.
  $False, $[Plus,#used,1]];

ST-link-prefix[Text] :: Text;
ST-link-prefix[#sink] → %n⟪LINK(«#sink»->context,⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-UnlinkLastMetaUse[$String, Reified_Use, Text] :: Text;

{#env}
ST-UnlinkLastMetaUse[#metavar, USE[#Use], #sink]
→
$[If, $[Equal, #Use, 1], %n⟪
UNLINK(«#sink»->context, «{#env}MetaVar[#metavar]»);⟫, %n⟪⟫];


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-UnlinkLastRefUse[$String, Reified_Use, Text] :: Text;

{#env; "$Strict":NO}ST-UnlinkLastRefUse[#RefCookie, #use, #sink]
→
%n⟪⟫;

{#env; "$Strict":YES}
ST-UnlinkLastRefUse[#Ref, #use, #sink]
→
{#env}ST-UnlinkLastRefUse2[$[:,"MetaVar$",#Ref], #use, #sink];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-UnlinkLastRefUse2[$String, Reified_Use, Text] :: Text;

-[Data[#RefCookie]]:
{#env; #RefCookie: PROPERTY_VARIABLE[#namedP, #varP]}
ST-UnlinkLastRefUse2[#RefCookie, USE[#use], #sink]
→
$[If, $[Equal, #use, 1], %n⟪
UNLINK_NamedPropertyLink(«#sink»->context, «#namedP»); 
UNLINK_VariablePropertyLink(«#sink»->context, «#varP»);⟫, %n⟪⟫];

// Determine whether meta is copied.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied[$String, $List[Reified_Binder]] :: $Boolean;

{#env}ST-is-copied[#metavar, #binders] 
→ {#env}ST-is-copied0[$[{#env}Get[STRING_ENTRY], $[:, "MetaVar$", #metavar]], #metavar, #binders];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied0[STRING_ENTRY, $String, $List[Reified_Binder]] :: $Boolean;

// Case 1: top-level meta-variable. Copy or Substitute
-[Free[var::Reified_Variable]] :
{#env; var: ARG[#Index, $True]}   
ST-is-copied0[VARIABLE[var], #metavar, #arguments] 
→ {#env}ST-is-copied-sub[#metavar, #arguments];

// Case 2: top-level closure. Either invoke or copy.
-[Free[var::Reified_Variable]] :
{#env; var: ARG[#Index, $False]} 
ST-is-copied0[VARIABLE[var], #metavar, #arguments] 
→ {#env}ST-is-copied-call[var, #metavar, #arguments];

// Case 3: sub meta-variable.. 
-[Free[var::Reified_Variable]]:
{#env; var:SUB[#parent, #i, #linked, $True]} // Sub data term. Copy or Substitute
ST-is-copied0[VARIABLE[var], #metavar, #arguments] 
→ {#env}ST-is-copied-sub[#metavar, #arguments];

// Case 4: sub closure
-[Free[var::Reified_Variable]]:
{#env; var: SUB[#parent, #i, $True, $False]} // Sub function.  
ST-is-copied0[VARIABLE[var], #metavar, #arguments]
→ {#env}ST-is-copied-call[var, #metavar, #arguments];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied-sub[$String, $List[Reified_Binder]] :: $Boolean;

{#env}ST-is-copied-sub[#metavar, ()] → $True;

// The meta variable has arguments. Analyze whether substitution is needed.
{#env}ST-is-copied-sub[#metavar, (#argument1; #arguments)] 
→ {#env}ST-is-copied-sub2[#metavar, (#argument1; #arguments)];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied-sub2[$String, $List[Reified_Binder]] :: $Boolean;

// Process substitution argument.
{#env}ST-is-copied-sub2[#metavar, (ARGUMENT[#sort, #term]; #arguments)] 
→ {#env}ST-is-copied-sub3[{#env} T-CheckReuse[#term], #metavar, #arguments];

// Generate COPY instruction for explicit substitution.
{#env}ST-is-copied-sub2[#metavar, ()]  → $True; 

// Skip reusable substitution component.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied-sub3[T_REUSE_SORT, $String, $List[Reified_Binder] ] :: $Boolean;

{#env}ST-is-copied-sub3[T_REUSE, #metavar,#arguments]
→ {#env}ST-is-copied-sub2[#metavar, #arguments];

// Generate non-explicit substitution setup for argument.
{#env}ST-is-copied-sub3[T_NO_REUSE, #metavar, #arguments] → $False;


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied-call[Text, $String, $List[Reified_Binder]] :: $Boolean;

// Closure without arguments. Not possible.
{#env}ST-is-copied-call[#closure, #metavar, ()] 
→ $[Error, "Internal error: closure without arguments"];

// The meta variable has arguments.  Analyze whether call is needed.
{#env}ST-is-copied-call[#closure, #metavar, (#argument1; #arguments)] 
→ {#env}ST-is-copied-call1[#closure, #metavar, (#argument1; #arguments)]; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied-call1[Text, $String, $List[Reified_Binder]] :: $Boolean;

// Done. Can copy
{#env}ST-is-copied-call1[#closure, #metavar, ()] → $True;

// Process call argument.
{#env}ST-is-copied-call1[#closure, #metavar, (ARGUMENT[#sort, VARIABLE-USE[#y]]; #arguments)] 
→ {#env}ST-is-copied-call1-var[$[{#env}Get, #y], #closure, #metavar, (ARGUMENT[#sort, VARIABLE-USE[#y]]; #arguments)];

// Not a variable: need to invoke closure
-[Fallback]:
{#env}ST-is-copied-call1[#closure, #metavar, #arguments] → $False; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-is-copied-call1-var[VARIABLE_ENTRY, Text, $String, $List[Reified_Binder]] :: $Boolean;

// A functional binder.. continue.
{#env}ST-is-copied-call1-var[BOUND_FUN, #closure, #metavar, (#argument1; #arguments)]
→ {#env}ST-is-copied-call1[#closure, #metavar, #arguments];

// Something else... invoke.
-[Fallback]:
{#env}ST-is-copied-call1-var[#entry, #closure, #metavar, #arguments] → $False;
 
///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to call or copy a closure

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call[Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// Closure without arguments. Not possible.
{#env}ST-call[#closure, #metavar, (), #use, #sink] 
→ $[Error, "Internal error: closure without arguments"];

// The meta variable has arguments.  Analyze whether call is needed.
{#env}ST-call[#closure, #metavar, (#argument1; #arguments), #use, #sink] 
→ {#env}ST-call1[#closure, #metavar, (#argument1; #arguments), #use, #sink]; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call1[Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// Done. Can reuse.
{#env}ST-call1[#closure, #metavar, (), #use, #sink] 
→ {#env}ST-call-precopy[#metavar, #use, #sink];

// Process call argument.
{#env}ST-call1[#closure, #metavar, (ARGUMENT[#sort, VARIABLE-USE[#y]]; #arguments), #use, #sink] 
→ {#env}ST-call1-var[$[{#env}Get, #y], #closure, #metavar, (ARGUMENT[#sort, VARIABLE-USE[#y]]; #arguments), #use, #sink];

// Not a variable: need to invoke closure
-[Fallback]:
{#env}ST-call1[#closure, #metavar, #arguments, #use, #sink] 
→ {#env}ST-preinvoke[#closure, #metavar, #arguments, #use, #sink]; 

// Copy closure. Properties haven't been sent yet so deal with them first
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call-precopy[$String, Reified_Use, Text] :: Text;

{#env; "$pending-props" : #pending}
ST-call-precopy[#metavar, #use, #sink]
→ %n⟪«{#env; "$tail": NO; "$pending-props": NO}ST-send-properties[#pending, #sink]»«
    {#env; "$pending-props": NO}ST-call-copy[#metavar, #use, #sink]»⟫;

// Copy closure. Properties haven't been sent yet so deal with them first
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call-copy[$String, Reified_Use, Text] :: Text;

{#env; "$tail": #tail}
ST-call-copy[#metavar, USE[#count], #sink]
→
$[If, $[Equal, #count, 1],
  %n⟪¶COPY(«#sink», « {#env}MetaVar[#metavar] »);« ST-send-tail[#tail] »⟫, // TODO: optimize tail call
  %n⟪¶COPY(«#sink», LINK(«#sink»->context, « {#env}MetaVar[#metavar] »));« ST-send-tail[#tail] »⟫]; // TODO: optimize tail call

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-call1-var[VARIABLE_ENTRY, Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

// A functional binder.. continue.
{#env}ST-call1-var[BOUND_FUN, #closure, #metavar, (#argument1; #arguments), #use, #sink]
→ {#env}ST-call1[#closure, #metavar, #arguments, #use, #sink];

// Something else... invoke.
-[Fallback]:
{#env}ST-call1-var[#entry, #closure, #metavar, #arguments, #use, #sink]
→ {#env}ST-preinvoke[#closure, #metavar, #arguments, #use, #sink]; 

// Invoke closure. First must take care of properties.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-preinvoke[Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env}ST-preinvoke[#closure, #metavar, #arguments, #use, #sink] 
→ {#env}ST-invoke[$[{#env}Get, "$pending-props"], #closure, #metavar, #arguments, #use, #sink]; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-invoke[STRING_ENTRY, Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env}ST-invoke[NO, #closure, #metavar, #binders, #use, #sink]
→ {#env}ST-invoke1[#closure, #metavar, #binders, #use, #sink];

{#env}ST-invoke[TERM[#term], #closure, #metavar, #binders, #use, #sink]
→ {#env}ST-invoke0[HasProperties[#term], #term, #closure, #metavar, #binders, #use, #sink];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-invoke0[$Boolean, Reified_Term, Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env}ST-invoke0[$False, #term, #closure, #metavar, #binders, #use, #sink]
→ {#env}ST-invoke1[#closure, #metavar, #binders, #use, #sink];

-[Fresh[buf::Text, closure::Text]]:
{#env}ST-invoke0[$True, #term, #closure, #metavar, #binders, #use, #sink]
→ %n⟪Term «closure»;
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);«{#env; "$tail": NO}ST-send-properties[TERM[#term], buf]»
COPY(«buf», «ST-may-link[#closure, #use, #sink]»);
«closure» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»);⟧
}« {#env; "$pending-props":NO}ST-invoke1[closure, #metavar, #binders, USE[1], #sink]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-invoke1[Text, $String, $List[Reified_Binder], Reified_Use, Text] :: Text;

{#env; "$tail": #tail}
ST-invoke1[#closure, #metavar, #binders, #use, #sink]
→ {#env; "$tail": NO}ST-set-binders[OK, #binders, #sink, ok¹ args¹.
                     ST-invoke2[ok¹, ST-may-link[#closure, #use, #sink], args¹, #metavar, {#env}MetaVarArityNum[#metavar], #tail, #sink]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-invoke2[OK_SORT, Text, $List[Text], $String, $Numeric, STRING_ENTRY, Text] :: Text;

-[Data[#arity]]:
{#env}ST-invoke2[OK, #closure, #args, #metavar, #arity, #tail, #sink]
→ $[If, $[LessThan, #arity, 5],
    %n⟪«ST-send-tail2[#tail]»CALL«INTEGER[#arity]»(«#sink», «#closure»«ConcatText[#args,%n⟨,⟩]»);⟫,
    %n⟪«ST-function-spilled-args[#sink, Tail[Tail[Tail[#args]]], 2]»«ST-send-tail2[#tail]»CALL(«#sink», «#closure», «INTEGER[#arity]»«ST-function-args[#args, 0, 3]»);⟫];

ST-may-link[Text, Reified_Use, Text] :: Text;

ST-may-link[#term, USE[#count], #sink]
→ $[If, $[Equal, #count, 1], 
    #term,
    %n⟨LINK(«#sink»->context, «#term»)⟩];

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to release reference to term to an existing variable.

ST-unlink-ref[Text, Text] :: Text;
ST-unlink-ref[#sink, #variable] → %n⟪¶UNLINK(«#sink»->context, «#variable»);⟫;

// ------------------------
//
// Generate code to capture copy of a bound term to an existing variable.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-binders[OK_SORT, $List[Reified_Binder], Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

{#env}ST-set-binders[OK, #Binders, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→ 
{#env}ST-set-binders2[OK, #Binders, (), #sink, ok¹ vars¹.#[ok¹, vars¹]] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-binders2[OK_SORT, $List[Reified_Binder], $List[Text], Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

// Done. 
{#env}ST-set-binders2[OK, (), #vars, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→ 
{#env}#[OK, #vars];

// Process each arguments, one at a time. Each arguments produces a list of variables
// (of type Variable/Term/Closure) to then be used for calling the function.
{#env}ST-set-binders2[OK, (#binder; #binders), #vars, #sink, ok¹ vars¹.#[ok¹, vars¹]]
→
{#env}ST-set-binder[HasFunctionalBinders[#binder], #binder, #sink, ok¹ vars¹.
      ST-set-binders2[ok¹, #binders, Append[#vars, vars¹], #sink, ok¹ vars¹.
      #[ok¹, vars¹]]];

// If at least one binder is functional, then generate a closure. 
// Otherwise generate Variable for each binder.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-binder[$Boolean, Reified_Binder, Text, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

// Subterm without binders. This is a term.
{#env}ST-set-binder[#has, ARGUMENT[#sort, #term], #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
{#env}ST-set-to[#term, #sink, var.#[OK, (var;)]];

// With functional binders : function argument is a closure: skip binders.
-[Fresh[b::Reified_Variable]]:
{#env}ST-set-binder[$True, BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], #sink, ok¹ vars¹.#[ok¹, vars¹]]
→
{#env; b:BOUND_FUN}ST-set-binder[$True, #binder[b], #sink, ok¹ vars¹.#[ok¹, vars¹]];
;

// Without functional binders : expect Variables and a Term  
// First analyze the binders for potential reuse and then compute the arguments.
{#env}ST-set-binder[$False, #binder, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
{#env}ST-analyze-binders[OK, #binder, #sink, ok¹ vars.
      ST-set-term-binder[OK, #binder, vars, #sink, ok¹ vars¹.
      #[ok¹, vars¹]]];

/*
 Generate arguments of type Variable for binders and Term. 

 When all binders can be reused, and not bound (not shared) then just rebind them and copy term  
  
 In the more general form, the generated code looks like this:
     
      Variable b1, ... bn;
      Term term; 
      if (!IS_BOUND(ob1))
      {  Reused
          b1 = ob1; REBIND(b1);
          ...
          term = ...  COPY
      }
      else
      {  Substitute
          b1 = new Variable ....
          ...
              
          term = ...  SUBSTITUTE
      }
*/

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder[OK_SORT, Reified_Binder /* The argument */, $List[Reified_Variable] /* The analyzed binders */, Text /* sink */, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;

{#env}
ST-set-term-binder[OK, #binder, #binders, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
{#env}
ST-set-term-binder-decls[#binders, (), ok¹ decls.ST-set-term-binder1[ok¹, #binder, #binders, decls, #sink, ok¹ vars¹.#[ok¹, vars¹]]];

// First pass: generate declarations. 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder-decls[$List[Reified_Variable] /* The analyzed binders */, $List[Text] /* The resulting var decls */, ok¹::OK_SORT decls::$List[Text].Text] :: Text;

-[Fresh[term::Text]]
:
{#env}ST-set-term-binder-decls[(), #decls, ok¹ decls.#[ok¹, decls]]
→
%n⟪¶Term «term»; «{#env}#[OK, Append[#decls, (term;)]]»⟫;

-[Fresh[b::Text]]
:
{#env}ST-set-term-binder-decls[(#binder; #binders), #decls, ok¹ decls.#[ok¹, decls]]
→
%n⟪¶Variable «b»;«{#env}ST-set-term-binder-decls[#binders, Append[#decls, (b;)], ok¹ decls.#[ok¹, decls]]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder1[OK_SORT, Reified_Binder /* The argument */, $List[Reified_Variable] /* The analyzed binders */, 
                    $List[Text] /* The variable declarations */, Text /* sink */, ok¹::OK_SORT vars¹::$List[Text].Text] :: Text;


{#env}ST-set-term-binder1[OK, #binder, #binders, #decls, #sink, ok¹ vars¹.#[ok¹, vars¹]] 
→
%n⟪«{#env}ST-set-term-binder2[#binder, #binders, #decls, #sink]»«{#env}#[OK, #decls]»⟫;


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder2[Reified_Binder /* The argument */, $List[Reified_Variable] /* The analyzed binders */, $List[Text] /* The variable declarations */, Text /* sink */] :: Text;

// Since all binders can be reused, generate a case rebinding them. 
// Note that binders can't be reused if shared.
{#env; "$all_reused": YES}
ST-set-term-binder2[#binder, (#var; #binders), #decls, #sink] 
→
%n⟪¶if (!IS_BOUND(«#var»))¶{ /* Reuse */⟦ «{#env}ST-set-term-binder3[#binder, (#var; #binders), #decls, #sink, $True]» ⟧¶} ¶else¶{ /* Substitute */⟦« {#env}ST-set-term-binder3[#binder, (#var; #binders), #decls, #sink, $False] »⟧¶}⟫;

// Can't be reused. Just generate the no rebind case.
{#env; "$all_reused": NO}
ST-set-term-binder2[#binder, #binders, #decls, #sink] 
→
{#env}ST-set-term-binder3[#binder, #binders, #decls, #sink, $False];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-term-binder3[Reified_Binder, $List[Reified_Variable], $List[Text], Text, $Boolean /* Enable Reuse */] :: Text;

{#env}ST-set-term-binder3[ARGUMENT[#sort, #term], (), (#vterm;), #sink, #reuse] 
→
{#env}ST-set[#term, #sink, #vterm];

-[Free[reused::Text]]
:
{#env; reused: BOUNDREUSE}
ST-set-term-binder3[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (reused; #binders), (#decl; #decls), #sink, $True] 
→ 
%n⟪¶«#decl» = «reused»; REBIND(«reused»);« {#env}ST-set-term-binder3[#binder[reused], #binders, #decls, #sink, $True] »⟫
;

-[Free[reuse::Text]]
:
{#env; reused: BOUNDREUSE}
ST-set-term-binder3[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (reused; #binders), (#decl; #decls), #sink, $False] 
→ 
%n⟪¶«#decl» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«#decl»");« {#env; #decl: BOUND}ST-set-term-binder3[#binder[#decl], #binders, #decls, #sink, $False] »⟫;

-[Free[new::Text]]
:
{#env; new: BOUND}
ST-set-term-binder3[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], (new; #binders), (#decl; #decls), #sink, $False] 
→
%n⟪¶«#decl» = MAKE_BOUND_«TOKEN[PromiscuityString[#promisc]]»_VARIABLE(«#sink»->context, (char*) "«#decl»");« {#env; #decl: BOUND}ST-set-term-binder3[#binder[#decl], #binders, #decls, #sink, $False] »⟫;

//---------
// Analyze binders and return a list of variables corresponding to the binder.
// 
// Each variable is added to the environment and marked as either BOUND or BOUNDREUSE.
// 
// The property "$all_reused" is set to YES when all binders can be reused, otherwise set to NO

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders[OK_SORT, Reified_Binder, Text, ok¹::OK_SORT vars::$List[Reified_Variable].Text] :: Text;
 
{#env}ST-analyze-binders[OK, BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #sink, ok¹ vars.#[ok¹, vars]]
→
{#env; "$binders":LIST_VARIABLE[()]; "$all_reused": YES}
ST-analyze-binders1[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #sink, 0, OUTER, ok¹ vars.#[ok¹, vars]];

// - Analyze each binder and either allocate it or reuse the unique variable it replaces.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders1[Reified_Binder, Text, $Numeric, Binder-State, ok¹::OK_SORT vars::$List[Reified_Variable].Text] :: Text;

{#env}ST-analyze-binders1[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#binder[b]], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders2[#occs, NOTHING, #promisc, #kind, #depth, b.#binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]];

// - Once all binders are collected ...
{#env; "$binders":LIST_VARIABLE[#Args]}
ST-analyze-binders1[ARGUMENT[#sort, #Term], #sink, #rank, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}#[OK, #Args];

// -- if binder occurs in exactly one meta-application then record a cookie for that meta-application position and promiscuity -
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders2[$List[Reified_Occurrence], Meta-Occurrence, Reified_Promiscuity, Reified_Kind, 
    Reified_Depth, binder : Reified_Variable . Reified_Binder, Text, $Numeric, Binder-State, ok¹::OK_SORT vars::$List[Reified_Variable].Text] :: Text;

// Record first occurrence. Cannot reuse if meta is copied (TODO: revisit reuse binder for at least one of them!) or if previous binder couldn't have been reused.
{#env}ST-analyze-binders2[(META-USE[#mv,#k]; #occs), NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
$[{#env}IfDef, $[:,"Copy$", #mv],
  {#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]],
  $[If, $[Equal, #state, NO_REUSE],
    {#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]],
    {#env}ST-analyze-binders2[#occs, UNIQUE[$[:, "BinderUnique$", #mv, "$", $[FormatNumber, #k], "$", PromiscuityString[#promisc]]], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]]
];

// Case where there is more than one occurrence. Can't reuse
{#env}ST-analyze-binders2[(META-USE[#mv,#k]; #occs), UNIQUE[#cookie], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]];

// Fallback case: process next occurrence
{#env}ST-analyze-binders2[(#occ; #occs), #cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders2[#occs, #cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]];

// done with occurrence. Move to the next phase
{#env}ST-analyze-binders2[(), #cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders3[#cookie, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]];

// -- test whether uniquely used local binder was also unique in pattern?
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders3[Meta-Occurrence, Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder, 
    Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

{#env}ST-analyze-binders3[UNIQUE[#cookie], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
$[{#env}IfDef, #cookie,
  {#env}ST-analyze-binders4[$[{#env}Get[STRING_ENTRY], #cookie], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]],
  {#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]];

// -- binder that can neither be reused. Generate a fresh binder.
{#env}ST-analyze-binders3[NOTHING, #promisc, #kind, #depth, b.#Binder[b], sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders6[#promisc, #kind, #depth, b.#Binder[b], sink, #index, #state, ok¹ vars.#[ok¹, vars]];

// -- outermost reused binder.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders4[STRING_ENTRY, Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder,
     Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

{#env}ST-analyze-binders4[VARIABLE[#reused], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, OUTER, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders5[#reused, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, REUSING, ok¹ vars.#[ok¹, vars]];

// -- following reused binder.
{#env}ST-analyze-binders4[VARIABLE[#reused], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, REUSING, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders5[#reused, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, REUSING, ok¹ vars.#[ok¹, vars]];

// -- binder that should not be reused because we are copying.
{#env}ST-analyze-binders4[VARIABLE[#reused], #promisc, #kind, #depth, b.#Binder[b], #sink, #index, COPYING, ok¹ vars.#[ok¹, vars]]
→
{#env}ST-analyze-binders6[#promisc, #kind, #depth, b.#Binder[b], #sink, #index, COPYING, ok¹ vars.#[ok¹, vars]];

// --- Generate binder that can be reused.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders5[Text, Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder, 
    Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

-[Free[reused::Text]]
:
{#env; "$binders":LIST_VARIABLE[#binders]}
ST-analyze-binders5[reused, #promisc, #kind, #depth, b.#Binder[b], #sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env; reused : BOUNDREUSE; "$binders":LIST_VARIABLE[Append[#binders, (reused;)]]}
ST-analyze-binders1[#Binder[reused], #sink, $[Plus, #index, 1], #state, ok¹ vars.#[ok¹, vars]];

// --- Generate binder that can't be reused.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-analyze-binders6[Reified_Promiscuity, Reified_Kind, Reified_Depth, binder : Reified_Variable . Reified_Binder, 
    Text, $Numeric, Binder-State, ok¹::OK_SORT vars¹::$List[Reified_Variable].Text] :: Text;

-[Fresh[new::Text]]
:
{#env; "$binders":LIST_VARIABLE[#binders]}
ST-analyze-binders6[#promisc, #kind, #depth, b.#Binder[b], sink, #index, #state, ok¹ vars.#[ok¹, vars]]
→
{#env; new : BOUND; "$binders":LIST_VARIABLE[Append[#binders, (new;)]]; "$all_reused": NO}
ST-analyze-binders1[#Binder[new], sink, $[Plus, #index, 1], #state, ok¹ vars.#[ok¹, vars]];

//---------
// Generate code to capture copy of term to new variable.
//

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-to[Reified_Term, Text, var::Text.Text] :: Text;

// Literals can be created directly.
-[Fresh[literal::Text]] :
{#env}ST-set-to[LITERAL[#literal, #sort], #sink, var.#[var]]
→ %n⟪¶Term «literal» = makeStringLiteral(«#sink»->context, (char *) «STRING[#literal]»);« {#env}#[literal] »⟫;

// Evaluators are handled separately...
-[Fresh[variable::Text]] :
{#env}ST-set-to[EVALUATOR[#primitive, #args, #options], #sink, var.#[var]]
→ %n⟪¶Term «variable»;« {#env}E-set[Primitive[#primitive], #args, #options, #sink, variable] »« {#env}#[variable] »⟫;

// Meta-Application  
-[Fresh[variable::Text]] :
{#env}ST-set-to[META-APPLICATION[#metavar, (), USE[#count]], #sink, var.#[var]]
→ $[If, $[Equal, #count, 1], 
    {#env}#[{#env}MetaVar[#metavar]],
    %n⟨¶Term «variable» = LINK(«#sink»->context, «{#env}MetaVar[#metavar]»);« {#env}#[variable] »⟩];

{#env}ST-set-to[META-APPLICATION[#metavar, (#binder; #binders), #use], #sink, var.#[var]] 
→ {#env}ST-set-to-meta[{#env}ST-is-copied[#metavar, (#binder; #binders)], #metavar, (#binder; #binders), #use, #sink, var.#[var]];
 
// Constant data construction with no properties: just assign
-[Fresh[variable::Text]]:
{#env}ST-set-to[CONSTRUCTION[KDATA, #symbol, ()], #sink, var.#[var]] 
→ %n⟪
Term «variable» = LINK(«#sink»->context, (Term) «Const[#symbol]»);« {#env}#[variable] »⟫;

{#env}ST-set-to[VARIABLE-USE[#Variable],  #sink, var.#[var]] 
→ {#env}ST-set-to-use[$[{#env}Get[VARIABLE_ENTRY], #Variable, FRESH], #Variable, #sink, var.#[var]];

// Proper term cases require buffering.
{#env}ST-set-to[PROPERTY-REF[#Ref, #Use, #Term],       #sink, var.#[var]] → {#env}ST-set-buffer-to[PROPERTY-REF[#Ref, #Use, #Term],       #sink, var.#[var]];
{#env}ST-set-to[PROPERTY[#Key, #Value, #Term],         #sink, var.#[var]] → {#env}ST-set-buffer-to[PROPERTY[#Key, #Value, #Term],         #sink, var.#[var]];
{#env}ST-set-to[PROPERTY-NOT[#Key, #Term],             #sink, var.#[var]] → {#env}ST-set-buffer-to[PROPERTY-NOT[#Key, #Term],             #sink, var.#[var]];
{#env}ST-set-to[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, var.#[var]] → {#env}ST-set-buffer-to[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, var.#[var]];


// Helper to set term variable using temporary buffer.   
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-buffer-to[Reified_Term, Text, var::Text.Text] :: Text;

-[Fresh[buf::Text, variable::Text]]
:
{#env}
ST-set-buffer-to[#term, #sink, var.#[var]]
→
%n⟪
Term «variable»;
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);« {#env}ST-then-send[OK, #term, buf] »
«variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»);⟧
}«{#env}#[variable]»⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-to-meta[$Boolean, $String, $List[Reified_Binder], Reified_Use, Text, var::Text.Text] :: Text;

{#env}ST-set-to-meta[$True, #metavar, #binders, #use, #sink, var.#[var]]
→ {#env}ST-set-to[META-APPLICATION[#metavar, (), #use], #sink, var.#[var]];

{#env}ST-set-to-meta[$False, #metavar, #binders, #use, #sink, var.#[var]]
→ {#env}ST-set-buffer-to[META-APPLICATION[#metavar, #binders, #use], #sink, var.#[var]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-to-use[VARIABLE_ENTRY, Reified_Variable, Text , var::Text.Text] :: Text;

-[Fresh[use::Text]]:
{#env}ST-set-to-use[BOUND_FUN, #variable, #sink, var.#[var]] 
→ %n⟪¶Term «use» = LINK(«#sink»->context, (Term) «#sink»->context->functionalUse);«{#env}#[use]»⟫;

-[Fallback, Fresh[use::Text]]:
{#env}ST-set-to-use[#entry, #variable, #sink, var.#[var]] 
→ %n⟪¶Term «use» = (Term) makeVariableUse(«#sink»->context, linkVariable(«#sink»->context, «#variable»));«{#env}#[use]»⟫;


///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture copy of term (actual copy or by reference) to an existing variable.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}ST-then-set[OK, #Term, #sink, #variable] → {#env}ST-set[#Term, #sink, #variable];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set[Reified_Term, Text, Text] :: Text;

// Literals can be created directly.
{#env}ST-set[LITERAL[#Literal, #Sort], #sink, #variable]
→
%n⟪¶«#variable» = makeStringLiteral(«#sink»->context, (char *) «STRING[#Literal]»);⟫;

// Evaluators are handled separately...
{#env}ST-set[EVALUATOR[#primitive, #args, #options], #sink, #variable]
→
{#env}E-set[Primitive[#primitive], #args, #options, #sink, #variable];

// Meta-Application  
{#env} 
ST-set[META-APPLICATION[#metavar, (), USE[#count]], #sink, #variable] 
→ 
$[If, $[Equal, #count, 1], 
    %n⟪¶«#variable» = «{#env}MetaVar[#metavar]»;⟫,
    %n⟪¶«#variable» = LINK(«#sink»->context, «{#env}MetaVar[#metavar]»);⟫
] ;

{#env}ST-set[META-APPLICATION[#metavar, (#binder;#binders), #use], #sink, #variable] 
→  {#env}ST-set-meta[{#env}ST-is-copied[#metavar, (#binder; #binders)], #metavar, (#binder; #binders), #use, #sink, #variable]; 

// Proper term cases require buffering.
{#env}ST-set[PROPERTY-REF[#Ref, #Use, #Term],       #sink, #variable] → {#env}ST-set-buffer[PROPERTY-REF[#Ref, #Use, #Term],       #sink, #variable] ;
{#env}ST-set[PROPERTY[#Key, #Value, #Term],         #sink, #variable] → {#env}ST-set-buffer[PROPERTY[#Key, #Value, #Term],         #sink, #variable] ;
{#env}ST-set[PROPERTY-NOT[#Key, #Term],             #sink, #variable] → {#env}ST-set-buffer[PROPERTY-NOT[#Key, #Term],             #sink, #variable] ;
{#env}ST-set[VARIABLE-USE[#Variable],               #sink, #variable] → {#env}ST-set-buffer[VARIABLE-USE[#Variable],               #sink, #variable] ;
{#env}ST-set[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, #variable] → {#env}ST-set-buffer[CONSTRUCTION[#Kind, #Symbol, #Binders],#sink, #variable] ;

// Helper to set term variable using temporary buffer.   
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-buffer[Reified_Term, Text, Text] :: Text;

-[Fresh[buf::Text]]
:
{#env}
ST-set-buffer[#Term, #sink, #variable]
→
%n⟪
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);« {#env; "$tail":NO}ST-then-send[OK, #Term, buf] »
«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»);⟧
}⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-meta[$Boolean, $String, $List[Reified_Binder], Reified_Use, Text, Text] :: Text;

{#env}ST-set-meta[$True, #metavar, #binders, #use, #sink, #variable]
→ {#env}ST-set[META-APPLICATION[#metavar, (), #use], #sink, #variable];

{#env}ST-set-meta[$False, #metavar, #binders, #use, #sink, #variable]
→ {#env}ST-set-buffer[META-APPLICATION[#metavar, #binders, #use], #sink, #variable];


///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture reference to term to an existing variable.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-ref[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}ST-then-set-ref[OK, #term, #sink, #variable] → {#env}ST-set-ref[#term, #sink, #variable];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-ref[Reified_Term, Text, Text] :: Text;

// Literals can be created directly.
{#env}ST-set-ref[LITERAL[#Literal, #Sort], #sink, #variable]
→
%n⟪¶«#variable» = makeStringLiteral(«#sink»->context, (char *) «STRING[#Literal]»);⟫;

// Most term cases require buffering (like ST-set).
{#env}ST-set-ref[PROPERTY-REF[#Ref, #Use, #Term],        #sink, #variable] → {#env}ST-set-buffer[PROPERTY-REF[#Ref, #Use, #Term],        #sink, #variable] ;
{#env}ST-set-ref[PROPERTY[#Key, #Value, #Term],          #sink, #variable] → {#env}ST-set-buffer[PROPERTY[#Key, #Value, #Term],          #sink, #variable] ;
{#env}ST-set-ref[PROPERTY-NOT[#Key, #Term],              #sink, #variable] → {#env}ST-set-buffer[PROPERTY-NOT[#Key, #Term],              #sink, #variable] ;
{#env}ST-set-ref[VARIABLE-USE[#Variable],                #sink, #variable] → {#env}ST-set-buffer[VARIABLE-USE[#Variable],                #sink, #variable] ;
{#env}ST-set-ref[CONSTRUCTION[#Kind, #Symbol, #Binders], #sink, #variable] → {#env}ST-set-buffer[CONSTRUCTION[#Kind, #Symbol, #Binders], #sink, #variable] ;

// Existing reference used directly.
{#env}ST-set-ref[META-APPLICATION[#metavar, #args, USE[#count]], #sink, #variable] 
→
$[If, $[Equal, #count, 1], 
    %n⟪¶«#variable» = « {#env}MetaVar[#metavar] »;⟫,
    %n⟪¶«#variable» = LINK(«#sink»->context, « {#env}MetaVar[#metavar] »);⟫];

// Evaluators are handled separately...
{#env}ST-set-ref[EVALUATOR[#Primitive, #Args, #Options], #sink, #variable]
→
{#env}E-set-ref[Primitive[#Primitive], #Args, #Options, #sink, #variable];

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing variable of type $Boolean

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-bool[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}
ST-then-set-bool[OK, #Term, #sink, #variable] 
→ 
{#env}
ST-set-bool[#Term, #sink, #variable]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-bool[Reified_Term, Text, Text] :: Text;

{#env} ST-set-bool[LITERAL[#Literal, #Sort], #sink, #bool] → ST-set-bool2[#bool, STRING[#Literal],%n⟪⟫] ;
{#env} ST-set-bool[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #bool] → ST-set-bool2[#bool, STRING[#Symbol],%n⟪⟫] ;

-[Free[v::Reified_Variable]]
:  
{#env}
ST-set-bool[VARIABLE-USE[v], #sink, #bool] 
→ 
ST-set-bool2[#bool, %n⟪
«v»->name⟫, %n⟪⟫] // Error? 
;

{#env} 
ST-set-bool[META-APPLICATION[#metavar, #Args, #Use], #sink, #bool] 
→ 
ST-set-bool2[#bool, %n⟪SYMBOL(« {#env}MetaVar[#metavar] »)⟫,{#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]];

{#env} ST-set-bool[PROPERTY-REF[#Ref, #Use, #Term],        #sink, #bool] → {#env} ST-set-bool[#Term, #sink, #bool] ;
{#env} ST-set-bool[PROPERTY[#Key, #Value, #Term],          #sink, #bool] → {#env} ST-set-bool[#Term, #sink, #bool] ;
{#env} ST-set-bool[PROPERTY-NOT[#Key, #Term],              #sink, #bool] → {#env} ST-set-bool[#Term, #sink, #bool] ;
{#env} ST-set-bool[EVALUATOR[#Primitive, #Args, #Options], #sink, #bool] → {#env} E-set-bool[Primitive[#Primitive], #Args, #Options, #sink, #bool] ;

ST-set-bool2[Text, Text, Text] :: Text;

ST-set-bool2[#bool, #string, #suffix]
→
%n⟪
«#bool» = !strcmp(«#string», True);«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing variable of type $Numeric where an integer is needed

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-int[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}
ST-then-set-int[OK, #Term, #sink, #variable] 
→ 
{#env}
ST-set-int[#Term, #sink, #variable]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-int[Reified_Term, Text, Text] :: Text;

{#env}ST-set-int[LITERAL[#Literal, #Sort],              #sink, #int] → ST-set-int2[#int, %n⟪«TOKEN[#Literal]»ll⟫,%n⟪⟫] ;

{#env}
ST-set-int[META-APPLICATION[#metavar, #Args, #Use], #sink, #int] → 
    ST-set-int2[#int, %n⟪LONGLONG(« {#env}MetaVar[#metavar] »)⟫,{#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]] 
;

{#env}ST-set-int[CONSTRUCTION[#kind, #Symbol, #Binders],       #sink, #int] → ST-set-int2[#int, %n⟪«TOKEN[#Symbol]»ll⟫,%n⟪⟫] ;

-[Free[v::Text]]
:
{#env}
ST-set-int[VARIABLE-USE[v], #sink, #int]
→ 
ST-set-int2[#int, %n⟪LONGLONG(«v»->name)⟫,%n⟪⟫]
; // Error?

{#env}ST-set-int[PROPERTY-REF[#Ref, #Use, #Term],   #sink, #int] → {#env} ST-set-int[#Term, #sink, #int] ;
{#env}ST-set-int[PROPERTY[#Key, #Value, #Term],     #sink, #int] → {#env} ST-set-int[#Term, #sink, #int] ;
{#env}ST-set-int[PROPERTY-NOT[#Key, #Term],         #sink, #int] → {#env} ST-set-int[#Term, #sink, #int] ;

{#env}ST-set-int[EVALUATOR[#Primitive, #Args, #Options], #sink, #int] → {#env} E-set-int[Primitive[#Primitive], #Args, #Options, #sink, #int] ;

ST-set-int2[Text, Text, Text] :: Text;

ST-set-int2[#int, #integer, #suffix]
→
%n⟪
«#int» = «#integer»;«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing variable of type $Numeric when a double is needed

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-num[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}
ST-then-set-num[OK, #Term, #sink, #variable]
→ 
{#env}
ST-set-num[#Term, #sink, #variable]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-num[Reified_Term, Text, Text] :: Text;

{#env}
ST-set-num[LITERAL[#Literal, #Sort], #sink, #num] 
→ 
ST-set-num2[#num, %n⟪
(double) «TOKEN[#Literal]»⟫,%n⟪⟫] 
;

{#env}
ST-set-num[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #num] 
→ 
ST-set-num2[#num, %n⟪
(double) «TOKEN[#Symbol]»⟫,%n⟪⟫]
;

-[Free[v::Text]]
:
{#env}
ST-set-num[VARIABLE-USE[v], #sink, #num] 
→
ST-set-num2[#num, %n⟪
DOUBLE(«v»->name)⟫, %n⟪⟫]
; // Error?

{#env}
ST-set-num[META-APPLICATION[#metavar, #Args, #Use], #sink, #num] 
→  
ST-set-num2[#num, %n⟪DOUBLE(« {#env}MetaVar[#metavar] »)⟫, {#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]] ; 

{#env} ST-set-num[PROPERTY-REF[#Ref, #Use, #Term],   #sink, #num] → {#env} ST-set-num[#Term, #sink, #num] ;
{#env} ST-set-num[PROPERTY[#Key, #Value, #Term],     #sink, #num] → {#env} ST-set-num[#Term, #sink, #num] ;
{#env} ST-set-num[PROPERTY-NOT[#Key, #Term],         #sink, #num] → {#env} ST-set-num[#Term, #sink, #num] ;

{#env} ST-set-num[EVALUATOR[#Primitive, #Args, #Options], #sink, #num] → {#env} E-set-num[Primitive[#Primitive], #Args, #Options, #sink, #num] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-set-num2[Text, Text, Text] :: Text;

ST-set-num2[#num, #number, #suffix]
→
%n⟪
«#num» = «#number»;«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to capture term to an existing allocated variable of type $String

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-then-set-string[OK_SORT, Reified_Term, Text, Text] :: Text;

{#env}ST-then-set-string[OK, #Term, #sink, #variable] → {#env}ST-set-string[#Term, #sink, #variable];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-set-string[Reified_Term, Text, Text] :: Text;

{#env}ST-set-string[LITERAL[#Literal, #Sort],               #sink, #string] → ST-set-string2[#string, STRING[#Literal], %n⟪⟫] ;
{#env}ST-set-string[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #string] → ST-set-string2[#string, STRING[#Symbol], %n⟪⟫] ;

-[Free[v::Text]]
: 
{#env}ST-set-string[VARIABLE-USE[v], #sink, #string] 
→ 
ST-set-string2[#string, %n⟪makeString(«#sink»->context, «v»->name)⟫, %n⟪⟫];

{#env}ST-set-string[META-APPLICATION[#metavar, #Args, #Use], #sink, #string] 
→ 
ST-set-string2[#string, %n⟪SYMBOL(« {#env}MetaVar[#metavar] »)⟫, {#env}ST-UnlinkLastMetaUse[#metavar, #Use, #sink]]; 

{#env}ST-set-string[PROPERTY-REF[#Ref, #Use, #Term],   #sink, #string] → {#env} ST-set-string[#Term, #sink, #string];
{#env}ST-set-string[PROPERTY[#Key, #Value, #Term],     #sink, #string] → {#env} ST-set-string[#Term, #sink, #string];
{#env}ST-set-string[PROPERTY-NOT[#Key, #Term],         #sink, #string] → {#env} ST-set-string[#Term, #sink, #string];

{#env}ST-set-string[EVALUATOR[#Primitive, #Args, #Options], #sink, #string] → {#env} E-set-string[Primitive[#Primitive], #Args, #Options, #sink, #string] ;

ST-set-string2[Text, Text, Text] :: Text;

ST-set-string2[#str, #string, #suffix]
→
%n⟪
«#str» = «#string»;«#suffix»⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Generate code to insert one instance of a string value.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-then-local-string[OK_SORT, Reified_Term, Text, s::Text p::Text.Text] :: Text;

{#env}
ST-then-local-string[OK, #Term, #sink, s p .#[s,p]]
→ 
{#env}
ST-local-string[#Term, #sink, s p .#[s,p]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
ST-local-string[Reified_Term, Text, s::Text p::Text.Text] :: Text;

{#env}
ST-local-string[LITERAL[#Literal, #Sort], #sink, s p.#[s,p]]
→
#[STRING[#Literal], %n⟪⟫]
;

{#env}
ST-local-string[META-APPLICATION[#metavar, #Args, #Use], sink, s p.#[s,p]] 
→ 
%n⟪
FORCE(«sink»->context, « {#env}MetaVar[#metavar] »); LINK(«sink»->context, « {#env}MetaVar[#metavar] »);« 
#[%n⟨SYMBOL(‹ {#env}MetaVar[#metavar] ›)⟩, %n⟨UNLINK(‹sink›->context, ‹ {#env}MetaVar[#metavar] ›);‹{#env}ST-UnlinkLastMetaUse[#metavar, #Use, sink]›⟩]»⟫;

{#env}
ST-local-string[VARIABLE-USE[v], #sink, s p.#[s, p]]
→
#[%n⟪«v»->name⟫, %n⟪⟫];

{#env}
ST-local-string[EVALUATOR[#Primitive, #Args, #Options], #sink, s p.#[s,p]]
→
{#env}
E-local-string[Primitive[#Primitive], #Args, #Options, #sink, s p.#[s,p]]
;

{#env}ST-local-string[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, s p.#[s,p]] → {#env}ST-local-string2[CONSTRUCTION[#kind, #Symbol, #Binders], #sink, s p.#[s, p]] ;
{#env}ST-local-string[PROPERTY-REF[#Ref, #Use, #Term], #sink, s p.#[s,p]] → {#env}ST-local-string2[PROPERTY-REF[#Ref, #Use, #Term], #sink, s p.#[s,p]] ;
{#env}ST-local-string[PROPERTY[#Key, #Value, #Term],   #sink, s p.#[s,p]] → {#env}ST-local-string2[PROPERTY[#Key, #Value, #Term],   #sink, s p.#[s,p]] ;
{#env}ST-local-string[PROPERTY-NOT[#Key, #Term],       #sink, s p.#[s,p]] → {#env}ST-local-string2[PROPERTY-NOT[#Key, #Term],       #sink, s p.#[s,p]] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}ST-local-string2[Reified_Term, Text, s::Text p::Text.Text] :: Text;

-[Fresh[t::Text]]
:
{#env}ST-local-string2[#Term, #sink, s p.#[s,p]]
→
%n⟪
Term «t»;« {#env} ST-set-ref[#Term, #sink, t] »
FORCE(«#sink»->context, «t»);« #[%n⟨SYMBOL(‹t›)⟩, ST-unlink-ref[#sink, t]] »⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
)] //ST
