// Copyright © 2012,2013 IBM Corporation
// $Id: rules.crs,v 3.29 2013/12/18 20:16:18 villardl Exp $

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE C RULES FILE TEXT FROM REIFIED CRSX. STRICT MODE
///////////////////////////////////////////////////////////////////////////////////////////////////

SRULES[(

$Use["compiler/c/cdefs.crs"];
$Use["compiler/c/sterm.crs"];

$Lax;

/* Generate top-level functions */
SF-Function[$String, $String, $List[Reified_Form], Reified_Sort, $List[Reified_Rule]] :: Text;

-[Fresh[sink::Text, count::Text, namedP::Text, varP::Text]]:
SF-Function[#kind, #function, #Forms, #Sort, #Rules]
→ %n⟪«SF-function-extern[#function, #Forms, #Sort]»

/* FUNCTION « COMMENT_TOKEN[#function] ». */
int «MANGLE[#function]»(Sink «sink», ssize_t «count», NamedPropertyLink «namedP», VariablePropertyLink «varP»« 
                                    {
                                        "$function"    : STRING_VALUE[#function]; 
                                        "$closure-count": NUM_VALUE[0]; 
                                        "$sink"        : VARIABLE[sink]; 
                                        "$shared"      : VARIABLE[count];                                       // Record sharing count.
                                        "$args"        : LIST_VARIABLE[()];
                                        "$TopRef"      : PROPERTY_VARIABLE[namedP, varP];
                                        "$Strict"      : YES;
                                        "$unstep"      : TEXT[%n⟨⟩];                                            // The unstep code. Built by SF-Arg.
                                        "$unstep-props": TEXT[%n⟨¶ADD_PROPERTIES(‹sink›, ‹namedP›, ‹varP›);⟩];  // The properties unstep code.
                                        "$spilled"     : TEXT[%n⟨⟩];                                            // Spilled arguments (to allow TCO) 
                                     }
                                    SF-Arg[#Forms, $True, ok¹.SF-Body[ok¹, #kind, #Rules]] »⟫;

// Generate the name function and construction descriptor extern C 
SF-function-extern[$String, $List[Reified_Form], Reified_Sort] :: Text;

SF-function-extern[#function, (SORT-ALLOWS-VARIABLES; #Forms), #Sort]           → SF-function-extern[#function, #Forms, #Sort];
SF-function-extern[#function, (SORT-SET[#Key, #Value, #Form]; #Forms), #Sort]   → SF-function-extern[#function, (#Form; #Forms), #Sort];

SF-function-extern[#function, (FORM[#Constructor, #FormArguments]; #Forms), #Sort]
→ %n⟪¶¶int « BinderOffsets[#function] »[] = {0« DelayMapText[k o.%n⟨ , ‹ DINTEGER[k, o] ›⟩, FormArguments-binder-offsets-strict[#FormArguments, 0]] »};
char *« NameFun[#function] »(Term term) { return (char *) « STRING[#function] »; }«SF-function-desc[#function, #Sort, #FormArguments]»⟫;

SF-function-desc[$String, Reified_Sort, $List[Reified_FormArgument]] :: Text;
SF-function-desc[#function, SORT[#SortName,#SortArgs], #FormArguments] 
→ %n⟪¶struct _ConstructionDescriptor « Descriptor[#function] » = {« $[If, $[Contains, #SortName, "$"], %n⟨NULL⟩, %n⟨&‹Sort[#SortName]›⟩] », 0, « INTEGER[Length[#FormArguments,0]] », sizeof(STRUCT« Struct[#function] »), « BinderOffsets[#function] », &« NameFun[#function] », « INTEGER[ArgCount[#FormArguments]] », (DStepFun) &«MANGLE[#function]»};⟫;

SF-function-desc[#function, SORT-VARIABLE[#SortVariable], #FormArguments] 
→ %n⟪¶struct _ConstructionDescriptor « Descriptor[#function] » = {NULL, 0, « INTEGER[Length[#FormArguments,0]] », sizeof(STRUCT« Struct[#function] »), « BinderOffsets[#function] », &« NameFun[#function] », « INTEGER[ArgCount[#FormArguments]] », (DStepFun) &«MANGLE[#function]»};⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE FUNCTION. STRICT MODE.
//
// First: Generate C function signature (starting with the argument).

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Arg[$List[Reified_Form], $Boolean<!-- Environment generated? -->, ok¹::OK_SORT.Text] :: Text;

{#env}SF-Arg[(), #hasSortSet, ok¹.#[ok¹]] // Function with no argument and no environment. 
→ {#env}#[OK];

{#env}SF-Arg[(SORT-ALLOWS-VARIABLES; #Forms), #hasSortSet, ok¹.#[ok¹]] 
→ {#env}SF-Arg[#Forms, #hasSortSet, ok¹.#[ok¹]];

{#env}SF-Arg[(SORT-SET[#Sort1, #Sort2, #Form]; #Forms), $True, ok¹.#[ok¹]] 
→ {#env}SF-Arg[(#Form; #Forms), $True, ok¹.#[ok¹]];

-[Fresh[namedP::Text, varP::Text]]:
{#env; "$unstep": TEXT[#unstep]; "$sink": VARIABLE[#sink];}
SF-Arg[(SORT-SET[#Sort1, #Sort2, #Form]; #Forms), $False, ok¹.#[ok¹]] 
→ %n⟪, NamedPropertyLink «namedP», VariablePropertyLink «varP»«
        {
            #env; 
            "$TopRef"       : PROPERTY_VARIABLE[namedP, varP]; 
            "$unstep-props" : TEXT[%n⟨¶ADD_PROPERTIES(‹UnVariable[$[{#env}Get, "$sink"]]›, ‹namedP›, ‹varP›);⟩]
        }
        SF-Arg[(#Form; #Forms), $True, ok¹.#[ok¹]]»⟫;

{#env}SF-Arg[(FORM[#Constructor, #Args];), #hasSortSet, ok¹.#[ok¹]] 
→ {#env; "$topargs": TOPARGS[#Args]}SF-TopArgs[OK, #Args, 0, ok¹.#[ok¹]];

// Go through the list of the function arguments

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopArgs[OK_SORT, $List[Reified_FormArgument], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-TopArgs[OK, (), #index, ok¹.#[ok¹]] 
→ {#env}#[OK];

{#env}SF-TopArgs[OK, (#arg; #args), #index, ok¹.#[ok¹]] 
→ {#env}SF-TopArg[HasFunctionalFormBinders[#arg], #arg, #index, ok¹ index¹.SF-TopArgs[ok¹, #args, index¹, ok¹.#[ok¹]]];

// if FormArgument contains at least one functional binder, generate a closure term. Otherwise, generate variable + term

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopArg[$Boolean, Reified_FormArgument, $Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

{#env}SF-TopArg[$True, #arg, #index, ok¹ index¹.#[ok¹, index¹]]
→ {#env}SF-TopClosure[#index, ok¹ index¹.#[ok¹, index¹]];

{#env}SF-TopArg[$False, #arg, #index, ok¹ index¹.#[ok¹, index¹]]
→ {#env; "$unstep-binders": LIST_VARIABLE[()]}SF-TopTerm[#arg, #index, ok¹ index¹.#[ok¹, index¹]];
 
// The top level argument has no functional binders. Generate variables for each binder and a term
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopTerm[Reified_FormArgument, $Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

-[Data[#index], Fresh[var::Text]]:
{#env; "$spilled":TEXT[#spilled]; "$sink": VARIABLE[#sink]}
SF-TopTerm[FORM-BINDER[KDATA, #sort, v.#formArgument[v]], #index, ok¹ index¹.#[ok¹, index¹]] // Kind must be KDATA
→ $[If, $[LessThan, #index, 2],
    %n⟪, Variable «var»«{#env}SF-TopBinder[var, #formArgument[var], #index, ok¹ index¹.#[ok¹, index¹]]»⟫,
    {#env; "$spilled": TEXT[%n⟪«#spilled»¶Variable «var» = (Variable) «Spilled[#sink, #index]»;⟫]}SF-TopBinder[var, #formArgument[var], #index, ok¹ index¹.#[ok¹, index¹]]];

-[Data[#index], Fresh[term::Text]]:
{#env; "$spilled":TEXT[#spilled];"$sink": VARIABLE[#sink]}
SF-TopTerm[FORM-ARGUMENT[#sort], #index, ok¹ index¹.#[ok¹, index¹]]
→ $[If, $[LessThan, #index, 2],
    %n⟪, Term «term»«{#env}SF-TopTerm2[term, #index, ok¹ index¹.#[ok¹, index¹]]»⟫,
    {#env; "$spilled": TEXT[%n⟪«#spilled»¶Term «term» = (Term) «Spilled[#sink, #index]»;⟫]}SF-TopTerm2[term,  #index, ok¹ index¹.#[ok¹, index¹]]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopTerm2[Text, $Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

{#env; "$args":LIST_VARIABLE[#topArgs]; "$unstep": TEXT[#unstep]; "$sink": VARIABLE[#sink]}
SF-TopTerm2[#term, #index, ok¹ index¹.#[ok¹, index¹]]
→ {#env; "$args"    : LIST_VARIABLE[Append[#topArgs,(#term;)]]; 
       #term      : ARG[#index, $True];
       "$unstep"  : TEXT[ConcatText[(#unstep; {#env}SF-UnstepBinders; %n⟨¶COPY(‹#sink›, ‹#term›);⟩;), %n⟨⟩]]
  }#[OK, $[Plus, #index, 1]];

// Generate syntactic variable argument
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopBinder[Text, Reified_FormArgument, $Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

{#env; "$args":LIST_VARIABLE[#topArgs]; "$unstep-binders": LIST_VARIABLE[#binders]}
SF-TopBinder[#var, #formArgument, #index, ok¹ index¹.#[ok¹, index¹]]
→ {#env; 
     "$args"          : LIST_VARIABLE[Append[#topArgs,(#var;)]]; 
     #var             : ARG[#index, $True]; 
     "$unstep-binders" : LIST_VARIABLE[(#var; #binders)]
  }SF-TopTerm[#formArgument, $[Plus, #index, 1], ok¹ index¹.#[ok¹, index¹]];


// Generate closure term. All binders are completely ignored.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopClosure[$Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

-[Data[#index], Fresh[closure::Text]]:
{#env; "$spilled":TEXT[#spilled]; "$sink": VARIABLE[#sink]}
SF-TopClosure[#index, ok¹ index¹.#[ok¹, index¹]]
→ $[If, $[LessThan, #index, 2],
    %n⟪, Term «closure»«{#env}SF-TopClosure2[closure, #index, ok¹ index¹.#[ok¹, index¹]]»⟫,
    {#env; "$spilled": TEXT[%n⟪«#spilled»¶Term «closure» = (Term) «Spilled[#sink, #index]»;⟫]}SF-TopClosure2[closure, #index, ok¹ index¹.#[ok¹, index¹]]];


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopClosure2[Text, $Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

{#env; "$args": LIST_VARIABLE[#topArgs]; "$unstep": TEXT[#unstep]; "$sink": VARIABLE[#sink]}
SF-TopClosure2[#closure, #index, ok¹ index¹.#[ok¹, index¹]]
→ {#env; 
     "$args"   : LIST_VARIABLE[Append[#topArgs,(#closure;)]]; 
     #closure  : ARG[#index, $False]; 
     "$unstep" : TEXT[ConcatText[(#unstep; %n⟨¶COPY(‹#sink›, ‹#closure›);⟩;), %n⟨⟩]]
  }#[OK, $[Plus, #index, 1]];

// Create thunk for binders
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-UnstepBinders :: Text;
{#env}SF-UnstepBinders → {#env}SF-UnstepBinders2[$[{#env}Get[STRING_ENTRY], "$unstep-binders"], $[{#env}Get[STRING_ENTRY], "$sink"]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-UnstepBinders2[STRING_ENTRY, STRING_ENTRY] :: Text;
{#env}SF-UnstepBinders2[LIST_VARIABLE[()], #sink] → %n⟪⟫;

-[Fresh[binders::Text]]:
{#env}SF-UnstepBinders2[LIST_VARIABLE[(#binder; #binders)], VARIABLE[#sink]]
→ %n⟪«MapText[x.%n⟨¶REBIND(‹x›);⟩, (#binder; #binders)]»
Variable «binders»[«INTEGER[Length[(#binder;#binders), 0]]»] = {«#binder»«ConcatText[#binders, %n⟨, ⟩]»}; BINDS(«#sink», «INTEGER[Length[(#binder;#binders), 0]]», «binders»);⟫;

// Move on to function body
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Body[OK_SORT, $String, $List[Reified_Rule]] :: Text;

{#env; "$spilled":TEXT[#spilled]}
SF-Body[OK, #kind, #Rules] 
→
%n⟪)
{⟦«#spilled»«
    $[If, $[Equal, #kind, "Contract"],       {#env}SF-Contract[#Rules],
    $[If, $[Equal, #kind, "BinderDispatch"], {#env}SF-Contract[#Rules], 
    $[If, $[Equal, #kind, "Dispatch"],       {#env}SF-Dispatch[#Rules],  
    $[If, $[Equal, #kind, "Shuffle" ],       {#env}SF-Contract[#Rules],
                                             %n⟨⟩]]]]
»⟧
}⟫
;

/*
  Generate C function body. Contraction mode.
 
  The generated C code has the following general form:
 
      do
      {
          { rule1 }
          ...
          { rulen }    
      } while (0);
      
      fallback
       
  where rule has the following form
  
      pattern matching
      unlink unused meta variable and variable
      contraction
 
  Since pattern matching can fail, intermediate linked meta variables and variables
  must first be unlink before fallback.
 */

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Contract[$List[Reified_Rule]] :: Text;

{#env; "$sink":VARIABLE[#sink]}
SF-Contract[(RULE[#name, #Options, #Pattern, #Contractum]; #Rules)]
→ %n⟪¶do {⟦
/* Contraction rule « COMMENT_TOKEN[#name] ». */« 
    {#env;
      "$vars" : LIST_VARIABLE[()];    // Keep list of linked variable that needs to be unlinked before contraction.
    }
    F-Options[#Options, o3.
    F-then-Fresh[o3, #sink, #Options, ok.
    SF-pattern-init[ok, FIRST, MATCH, #Pattern, #sink, %n⟨⟩, $False, $False, %n⟨⟩, o2.
    SF-then-eval[o2, %n⟨⟩, #Contractum, #sink]]]] »⟧
} while (0);« {#env}SF-Contract[#Rules] »⟫;

// Done with contraction. Generate thunk construction. 
{#env; 
  "$unstep"       : TEXT[#unstep];
  "$unstep-props" : TEXT[#unstep-props]; 
  "$function"     : STRING_VALUE[#function]; 
  "$sink"         : VARIABLE[#sink]
}SF-Contract[()]
→ %n⟪

/* Fallback */«#unstep-props»
START(«#sink», «EventConstructor[#function]»);«#unstep»
END(«#sink», «EventConstructor[#function]»); 
return 0;⟫;

/*
  Generate C function body. Dispatch mode.

  Dispatch rule function: single rule that switches on an initial value before contracting the remainder.
*/ 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Dispatch[$List[Reified_Rule]] :: Text;

// Generate function body for complete contraction rule set.
{#env; 
  "$topargs" : TOPARGS[(#formArgument1; #formArguments)]; 
  "$args"    : LIST_VARIABLE[#args];
}SF-Dispatch[#rules] 
→ {#env}SF-Dispatch-choice[#formArgument1, #args, #rules];

// Generate choice.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Dispatch-choice[Reified_FormArgument, $List[Text] <!-- top-level arguments -->, $List[Reified_Rule]] :: Text;

// Skip binders...
-[Fresh[dummy::Text]]:
{#env}SF-Dispatch-choice[FORM-BINDER[#Kind, #BinderSort, v.#Form[v]], (#arg; #args), #Rules]
→ {#env}SF-Dispatch-choice[#Form[dummy], #args, #Rules];

// Dispatch on the first argument. Make sure it's weak-normal form using FORCE.
-[Fresh[choice::Text]] :
{#env; 
  "$sink"         : VARIABLE[#sink];
  "$unstep"       : TEXT[#unstep];
  "$unstep-props" : TEXT[#unstep-props]; 
  "$function"     : STRING_VALUE[#function]
}SF-Dispatch-choice[FORM-ARGUMENT[SORT[#sort-name, #sort-params]], (#arg; #args), #rules]
→ %n⟪
FORCE(«#sink»->context, «#arg»);
« Enum[#sort-name] » «choice» = (IS_VARIABLE_USE(«#arg») ? « EnumVar[#sort-name] » : (« Enum[#sort-name] ») TAG(«#arg»));
switch («choice»)
{⟦« {#env}SF-Dispatch-cases[FIRST, #rules, #sort-name] »
default: 
break;⟧
}

/* Fallback. */«#unstep-props»
START(«#sink», «EventConstructor[#function]»);«#unstep»
END(«#sink», «EventConstructor[#function]»); 
return 0;⟫;

// dispatch on single polymorphic variable - just contract.
-[Free[alpha::Reified_Variable]] :
{#env}SF-Dispatch-choice[FORM-ARGUMENT[SORT-VARIABLE[alpha]], #args, #rules] 
→ {#env}SF-Contract[#rules]; 

// Generate cases, one per rule.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Dispatch-cases[PASS, $List[Reified_Rule], $String] :: Text;

// Generate switch body for each dispatch rule: case+options+matching, then contraction, finally report success.
{#env; "$sink": VARIABLE[#sink]}
SF-Dispatch-cases[#pass, (RULE[#name, #options, #pattern, #contractum]; #rules), #sort-name]
→ %n⟪« 
    {#env; "$vars": LIST_VARIABLE[()]}
    SF-pattern-init[OK, #pass, DISPATCH[#name, #options, #sort-name], #pattern, #sink, %n⟨⟩, $False, $False, %n⟨⟩, ok¹.
    SF-then-eval[ok¹, %n⟨⟩, #contractum, #sink]] »« 
    {#env}SF-Dispatch-cases[SECOND, #rules, #sort-name] »⟫;

SF-Dispatch-cases[FIRST,  (), #SortName]    → %n⟪⟫;
SF-Dispatch-cases[SECOND, (), #SortName]    → %n⟪¶}⟫;

// ------------
// Match term against pattern. 
//

// Initialize environment before moving on to SF-pattern
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-pattern-init[OK_SORT, PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok::OK_SORT.Text] :: Text;

{#env}SF-pattern-init[OK, #pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→ {#env;
    "$refs"     : LIST_STRING[()];   // Record property references that needs to be unlink before tail-call. 
    "$subrefs"  : LIST_STRING[()];   // Record sub property references that needs to be unlinked upon pattern matching failure. 
    "$terms"    : LIST_VARIABLE[()]; // Record term references that needs to be unlink before  tail-call.   
    "$subterms" : LIST_VARIABLE[()]  // Record sub term references that needs to be unlinked upon pattern matching failure.   
  }SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern[OK_SORT, PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok¹::OK_SORT.Text] :: Text;

{#env}SF-then-Pattern[OK, #pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→ {#env}SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern[PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok::OK_SORT.Text] :: Text;

// Pattern {#REF} prefix: defer 
SF-Pattern-PropertyRef:
{#env}SF-Pattern[#pass, #stage, PROPERTY-REF[#ref, #use, #pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]] 
→ $[{#env}IfDef, $[:, "Comparable$", #ref],
    $[Error, "Property reference cannot be compared"],
    {#env}SF-Pattern[#pass, #stage, #pattern, #sink, #setup, $True, #unique, #term, ok¹.
          SF-then-Pattern-Ref[ok¹, $[:,"MetaVar$", #ref], #stage, #use, #sink, #term, o2¹.#[o2¹]]]];

//SF-Pattern-PropertyRef-Used :
//{#env}SF-Pattern[#pass, #stage, PROPERTY-REF[#Ref, USE[#Count], #Pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]] 
//→ {#env}SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, $True, #unique, #term, ok¹.
//      SF-then-Pattern-Ref[ok¹, $[:,"MetaVar$",#Ref], #stage, USE[#Count], #sink, #term, ok¹.#[ok¹]]];

// Pattern {KEY:VALUE} prefix: extract property and match pattern.
SF-Pattern-Property-all
:
{#env}SF-Pattern[#pass, #stage, PROPERTY[#Key, #Value, #Pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]] 
→
{#env}SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, $True, #unique, #term, ok¹.
      SF-then-Pattern-Property[ok¹, SF-is-top-stage[#stage], #pass, #sink, #term, #Key, #Value, ok¹.#[ok¹]]];

// Pattern {¬ KEY} prefix: extract property and check for absence.
SF-Pattern-NotProperty-all 
:
{#env}
SF-Pattern[#pass, #stage, PROPERTY-NOT[#Key, #Pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, $True, #unique, #term, ok¹.
SF-then-Pattern-Not-Property[ok¹, SF-is-top-stage[#stage], #sink, #term, #Key, o2¹.#[o2¹]]];

// - DISPATCH stage: ignore function application itself (which is the function) and advance to case generation.
SF-Pattern-Construction-Dispatch
:
{#env}SF-Pattern[#pass, DISPATCH[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, (#binder1; #binders)], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}SF-PatternBinders[#pass, DISPATCH[#name, #options, #sort-name], (#binder1; #binders), #sink, #unique, #term, 0, ok¹.#[ok¹]];

SF-Pattern-Construction-NoBinders-Dispatch 
:
{#env}SF-Pattern[#pass, DISPATCH[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, ()], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}SF-Pattern[#pass, CASE[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, ()], #sink, #setup, $False, #unique, #term, ok¹.#[ok¹]];

// - CASE stage: emit case check and proceed normally.
SF-Pattern-Construction-Case
:
{#env}SF-Pattern[#pass, CASE[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, #binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« SF-Pattern-Open[#pass] »
case « EnumTag[#symbol] »: /* Function «COMMENT_TOKEN[#name]» case «COMMENT_TOKEN[#symbol]» */
{⟦«#setup»« 
        {#env}
        F-Options[#options, ok¹.
        SF-then-PatternBinders[ok¹, #pass, CASE[#name, #options, #sort-name], #binders, #sink, #unique, #term, 0, ok¹.#[ok¹]]] »⟧⟫;

// -  MATCH stage: ignore construction itself and process Binders.
SF-Pattern-Construction-Match
:
{#env}SF-Pattern[#pass, MATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »« {#env}SF-PatternBinders[#pass, MATCH, #Binders, #sink, #unique, #term, 0, ok¹.#[ok¹]] »⟫;

// - SUBMATCH stage: force, check, and process argument Binders.
SF-Pattern-Construction-SubMatch-Sub
:
{#env; #term: SUB[#parent, #i, #linked, #isterm]}
SF-Pattern[#pass, SUBMATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
FORCE(«#sink»->context, «#term»); SUB(«#parent», «INTEGER[#i]») = «#term»;
if (strcmp(SYMBOL(«#term»), «STRING[#Symbol]»)) {«{#env}SF-fail-cleanup[#sink]» break;}« {#env} SF-then-PatternBinders[OK, #pass, SUBMATCH, #Binders, #sink, #unique, #term, 0, ok¹.#[ok¹]] »⟫;

SF-Pattern-Construction-SubMatch-TermArg
:
{#env; #term: ARG[#i, $True]}
SF-Pattern[#pass, SUBMATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
FORCE(«#sink»->context, «#term»); 
if (strcmp(SYMBOL(«#term»), «STRING[#Symbol]»)) {«{#env}SF-fail-cleanup[#sink]» break;}« {#env} SF-then-PatternBinders[OK, #pass, SUBMATCH, #Binders, #sink, #unique, #term, 0, ok¹.#[ok¹]] »⟫;

SF-Pattern-Construction-SubMatch-ClosureArg
:
{#env; #term: ARG[#i, $False]}
SF-Pattern[#pass, SUBMATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
$[Error, "Assertion error: a top-level argument cannot be in a subterm"];

// Pattern "Literal": assume that the literal is there...
SF-Pattern-Literal
:
{#env}
SF-Pattern[#pass, #stage, LITERAL[#Literal, #Type], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪¶/* Ignoring literal «STRING[#Literal]» */« $[If, #needed,#setup,%n⟨⟩] »« {#env} #[OK] »⟫;

// SUBMATCH stage, pattern is free variable (outside meta-application): record the variable.  
SF-Pattern-Variable-Free-Top
:
{#env; #variable : FREE; #term:ARG[#i, #IsTerm]}
SF-Pattern[#pass, SUBMATCH, VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
Variable «#variable» = VARIABLE(«#term»);« {#env} #[OK] »⟫;

// SUBMATCH stage, Pattern is bound variable (outside meta-application).
SF-Pattern-Variable-Bound
:
{#env; #variable : $[NotMatch, FREE, #kind]; #term:SUB[#parent, #i, #linked, #isterm]}
SF-Pattern[#pass, SUBMATCH, VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
FORCE(«#sink»->context, «#term»); 
SUB(«#parent», «INTEGER[#i]») = «#term»; 
if («#variable» != VARIABLE(«#term»)) {«{#env}SF-fail-cleanup[#sink]» break;}« {#env} #[OK] »⟫;

// Pattern is variable but before options have been processed.

// - first variable.
SF-Pattern-Variable-Case1 
:
{#env}
SF-Pattern[FIRST, CASE[#Name,#Options,#SortName], VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪
case « EnumVar[#SortName] »: {⟦
« {#env} SF-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok¹.#[ok¹]] »⟧⟫;

// - subsequent variable (always follows another variable).
SF-Pattern-Variable-Case2[Discard[#SortName,#needed,#unique]]
:
{#env}
SF-Pattern[SECOND, CASE[#Name,#Options,#SortName], VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok¹.#[ok¹]];

// Pattern $[...]: in all cases, delegate to E-Pattern. 
{#env}
SF-Pattern[#pass, #stage, EVALUATOR[#Primitive, #Patterns, #Options], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »« {#env; "$tail":NO}E-Pattern[Primitive[#Primitive], #Patterns, #pass, #stage, #sink, #term, ok¹.#[ok¹]] »⟫;

// Pattern #MetaVar[MetaArg...]: store in meta-variable and record argument variables.

SF-Pattern-MetaApplication
:
{#env}
SF-Pattern[#pass, #stage, META-APPLICATION[#MetaVar, #MetaArgs, #Use], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→  
{#env}
SF-Pattern-MetaArgs-Norm[{#env}F-Pattern-NeedNorm[#MetaVar,#Use], #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]];

// Helper for generating environment reference meta-variable.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Ref[OK_SORT, $String, Pattern-Stage, Reified_Use, Text, Text, ok¹::OK_SORT.Text] :: Text;

{#env}SF-then-Pattern-Ref[OK, #RefCookie, #stage, #use, #sink, #term, ok¹.#[ok¹]] 
→
{#env}SF-pattern-ref[SF-is-top-stage[#stage], #RefCookie, #stage, #use, #sink, #term, ok¹.#[ok¹]] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-pattern-ref[$Boolean, $String, Pattern-Stage, Reified_Use, Text, Text, ok¹::OK_SORT.Text] :: Text;

// Top-level property ref: no need to link but must record for unlink
-[Data[#refcookie]]
:
{#env; "$TopRef": #propvars; "$refs": LIST_STRING[#refs]}
SF-pattern-ref[$True, #refcookie, #stage, DISCARD, #sink, #term, ok¹.#[ok¹]] 
→
{#env; #refcookie : #propvars; "$refs":LIST_STRING[(#refcookie; #refs)]}#[OK];

// Top-level property ref: used at least once. Top-level: already linked. 
// Don't record for unlink as it's going to be consumed in the contraction.
-[Data[#RefCookie]]
:
{#env; "$TopRef": #propvars}
SF-pattern-ref[$True, #refcookie, #stage, USE[#count], #sink, #term, ok¹.#[ok¹]] 
→
{#env; #refcookie : #propvars}#[OK];

// Sub property ref: case where the properties are discarded. 
// Just store in local variable without owning a reference as it won't be used in the contraction.
-[Fresh[namedP::Text, varP::Text], Data[#RefCookie]]
:
{#env}
SF-pattern-ref[$False, #RefCookie, #stage, DISCARD, #sink, #term, ok¹.#[ok¹]]  
→
%n⟪
NamedPropertyLink «namedP» = NAMED_PROPERTIES(«#term»); permitUnusedNLink(«namedP»);
VariablePropertyLink «varP» = VARIABLE_PROPERTIES(«#term»); permitUnusedVLink(«varP»);
« {#env;  #RefCookie : PROPERTY_VARIABLE[namedP, varP]} #[OK] »⟫;

// Sub property ref: case where the properties is at least used once. Must link.
// Don't record for unlink as it's going to be consumed in the contraction.
// However record for cleanup.
-[Fresh[namedP::Text, varP::Text], Data[#refcookie]]
:
{#env; "$subrefs": LIST_STRING[#subrefs]}
SF-pattern-ref[$False, #refcookie, #stage, USE[#count], #sink, #term, ok¹.#[ok¹]]  
→
%n⟪
NamedPropertyLink «namedP» = LINK_NamedPropertyLink(«#sink»->context, NAMED_PROPERTIES(«#term»));  
VariablePropertyLink «varP» = LINK_VariablePropertyLink(«#sink»->context, VARIABLE_PROPERTIES(«#term»)); 
« {#env;  #refcookie : PROPERTY_VARIABLE[namedP, varP]; "$subrefs": LIST_STRING[(#refcookie; #subrefs)]} #[OK] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Property[OK_SORT, $Boolean<!-- top stage? -->, PASS, Text, Text, Reified_Term, Reified_Term, ok¹::OK_SORT.Text] :: Text;

-[Fresh[value::Text]]
:
{#env}
SF-then-Pattern-Property[OK, #top, #pass, #sink, #term, #Key, #Value, ok¹.#[ok¹]]
→
%n⟪« {#env} SF-set-value[#top, #Key, #sink, #term, value] »
if (!«value») {«{#env}SF-fail-cleanup[#sink]» break;} 
LINK(«#sink»->context, «value»);
int «value»_count = LINK_COUNT(«value»); permitUnusedInt(«value»_count);« {#env; value: ARG[0, $True]} SF-Pattern[#pass, SUBMATCH, #Value, #sink, %n⟨⟩, $False, $True, value, ok¹.#[ok¹]] »⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-set-value[$Boolean<!-- top stage? -->, Reified_Term, Text, Text, Text] :: Text;

{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, META-APPLICATION[#MetaVar, #Args,#count], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = DPROPERTY(«#sink»->context, «#namedP», «#varP», « {#env}MetaVar[#MetaVar] »); permitUnusedTerm(«#value»);⟫;

{#env}
SF-set-value[$False, META-APPLICATION[#MetaVar, #Args,#count], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = PROPERTY(«#sink»->context, «#term», « {#env}MetaVar[#MetaVar] »); permitUnusedTerm(«#value»);⟫;

{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, LITERAL[#literal, #Sort], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = DNAMED_PROPERTY(«#sink»->context, «#namedP»,  « Literal[#literal] »); permitUnusedTerm(«#value»);⟫;

{#env}
SF-set-value[$False, LITERAL[#literal, #Sort], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = NAMED_PROPERTY(«#sink»->context, «#term», « Literal[#literal] »); permitUnusedTerm(«#value»);⟫;

-[Fresh[key::Text]]
:
{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, CONSTRUCTION[#kind, #symbol, #Binders], #sink, #term, #value] 
→ 
%n⟪
const PooledString «key» = GLOBAL(«#sink»->context, « STRING[#symbol] »);
Term «#value» = DNAMED_PROPERTY(«#sink»->context, «#namedP», «key»); permitUnusedTerm(«#value»);⟫;

-[Fresh[key::Text]]
:
{#env}
SF-set-value[$False, CONSTRUCTION[#kind, #symbol, #Binders], #sink, #term, #value] 
→ 
%n⟪
PooledString «key» = GLOBAL(«#sink»->context, « STRING[#symbol] »);
Term «#value» = NAMED_PROPERTY(«#sink»->context, «#term», «key»); permitUnusedTerm(«#value»);⟫;

{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, VARIABLE-USE[#variable], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = DVARIABLE_PROPERTY(«#varP», «$[Show, #variable]»); permitUnusedTerm(«#value»);⟫;

{#env}SF-set-value[$False, VARIABLE-USE[#variable], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = VARIABLE_PROPERTY(«#term», «$[Show, #variable]»); permitUnusedTerm(«#value»);⟫;

SF-Pattern-Open[PASS] :: Text;

SF-Pattern-Open[FIRST] → %n⟪⟫; 
SF-Pattern-Open[SECOND] → %n⟪
}⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Not-Property[OK_SORT, $Boolean<!-- top stage? -->, Text, Text, Reified_Term, ok¹::OK_SORT.Text] :: Text;

-[Fresh[value::Text]]
:
{#env}SF-then-Pattern-Not-Property[OK, #top, #sink, #term, #Key, ok¹.#[ok¹]]
→
%n⟪« {#env} SF-set-value[#top, #Key, #sink, #term, value] »
if (!«value») {¶⟦«{#env}SF-fail-cleanup[#sink]»¶break;⟧¶}
LINK(«#sink»->context, «value»);« {#env} #[OK] »⟫;

// Helper for processing construction subterms.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-PatternBinders[OK_SORT, PASS, Pattern-Stage, $List[Reified_Binder], Text, $Boolean, Text, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-then-PatternBinders[OK, #pass, #stage, #Binders, #sink, #unique, #term, #index, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternBinders[#pass, #stage, #Binders, #sink, #unique, #term, #index, ok¹.#[ok¹]];

// ------------ Process construction binders, for each stage

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinders[PASS, Pattern-Stage, $List[Reified_Binder], Text, $Boolean, Text, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-PatternBinders[#pass, #stage, (#Binder;#Binders), #sink, #unique, #term, #index, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder[#pass, #stage, HasFunctionalBinders[#Binder], #Binder, #sink, %n⟨⟩, #unique, #term, #index, 0, ok¹.
      SF-then-PatternBinders[ok¹, #pass, #stage, #Binders, #sink, #unique, #term, $[Plus,#index,1], ok¹.#[ok¹]]];

// Pattern arguments []. Done.
{#env}SF-PatternBinders[#pass, #stage, (), #sink, #unique, #term, #index, ok¹.#[ok¹]]
→
{#env}#[OK];

// ------------ Process construction binder, for each stage

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder[PASS, Pattern-Stage, $Boolean, Reified_Binder, Text, Text, $Boolean, Text, $Numeric<!-- Sub Index -->, $Numeric<!-- Binder index -->, ok¹::OK_SORT.Text] :: Text;

// At least one functional binder: hidden in Closure. Just skip so that they are not marked as reusable.
-[Fresh[b::Reified_Variable]]
:
{#env}SF-PatternBinder[#pass, #stage, $True, BINDER[#promisc, #kind, #depth, #sort, #occs, b . #Binder[b]], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder[#pass, #stage, $True, #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// All binders are data. Represent as data
{#env}SF-PatternBinder[#pass, #stage, $False, BINDER[#promisc, KDATA, #depth, #sort, #occs, b . #Binder[b]], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder1[#occs, NOTHING, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// Just an argument. Move on to the term.
{#env}SF-PatternBinder[#pass, #stage, #has, ARGUMENT[#sort,#Pattern], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternSub[#Pattern, #pass, #has, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

/*
 * Analyzes data binder for reuse and extract/record variable 
 *
 * If binder occurs in exactly one meta-application then record a BinderUnique$mv$k$promisc cookie for that meta-application position
 * otherwise record BinderUnique$mv$k$promisc only for the first occurrence.
 *
 */

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder1[$List[Reified_Occurrence], Meta-Occurrence, PASS, Pattern-Stage, Reified_Promiscuity, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-PatternBinder1[(META-USE[#mv,#k]; #occs), NOTHING, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder1[#occs, UNIQUE[$[:,"BinderUnique$",#mv,"$",$[FormatNumber, #k],"$",PromiscuityString[#promisc]]], #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

{#env}SF-PatternBinder1[(OTHER; #occs), #state, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[NOTHING, #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

{#env}SF-PatternBinder1[(), #cookie, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[#cookie, #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// This is the second occurrence. Record cookie for the first one only
{#env}SF-PatternBinder1[(META-USE[#mv, #k]; #occs), UNIQUE[#cookie], #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[UNIQUE[#cookie], #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

-[Fallback]
:
{#env}SF-PatternBinder1[#occs, #cookie, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[NOTHING, #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// - then generate and record cookie, binder name, and promiscuity (and recurse).

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder2[Meta-Occurrence, PASS, Pattern-Stage, $Boolean<!-- Top-level? -->, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;

// The binder is on the function. If the function is not shared, then can unbind binder so it can be eventually reused.
{#env; "$args":LIST_VARIABLE[(#arg; #args)]; "$shared": VARIABLE[#shared]}
SF-PatternBinder2[#cookie, #pass, #stage, $True, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env; "$args":LIST_VARIABLE[#args]}
SF-PatternBinder3[#arg, #cookie, #pass, #stage, b . #Binder[b], #sink, %n⟪« #code »¶if («#shared» <= 1) ⟦¶UNBIND(«#arg»);⟧⟫, #unique, #term, #i, #j, ok¹.#[ok¹]];

// Get the variable from the term. Same as above: if the term is not shared, then can unbind binder so it can be eventually reused.
-[Fresh[v::Text]]
:
{#env}SF-PatternBinder2[#cookie, #pass, #stage, $False, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder3[v, #cookie, #pass, #stage, b.#Binder[b], #sink, %n⟪« #code »
Variable «v» = linkVariable(«#sink»->context, BINDER(«#term»,«INTEGER[#i]»,«INTEGER[#j]»)); 
if (« #term »_count <= 1) ⟦¶UNBIND(«v»);⟧⟫, #unique, #term, #i, $[Plus,#j,1], ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder3[Reified_Variable, Meta-Occurrence, PASS, Pattern-Stage, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;

// The variable is use only once in the contraction 
{#env; "$vars": LIST_VARIABLE[#Vars]}
SF-PatternBinder3[#var, UNIQUE[#cookie], #pass, #stage, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env; #var: BOUND; #cookie: VARIABLE[#var]; "$vars": LIST_VARIABLE[(#var; #Vars)]}
SF-PatternBinder[#pass, #stage, $False, #Binder[#var], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// The variable is use only more than once in the contraction
{#env; "$vars":LIST_VARIABLE[#Vars]}
SF-PatternBinder3[#var, NOTHING, #pass, #stage, b.#Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env; #var: BOUND; "$vars":  LIST_VARIABLE[(#var; #Vars)]}
SF-PatternBinder[#pass, #stage, $False, #Binder[#var], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-Variable-Case[$String, $List[Reified_Option], Text, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - use a do block so failed test can break out.
{#env}SF-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok¹.#[ok¹]] 
→
%n⟪
do {⟦« #setup »« 
    {#env;
        "$vars" : LIST_VARIABLE[()];    // Keep list of linked variable that needs to be unlinked before contraction.
    }F-Options[#Options, ok.
    SF-then-Pattern-Variable-Use[ok, #Name, #sink, #variable, #term, o2.#[o2]]] »⟧
} while(0);⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Variable-Use[OK_SORT, $String, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - bound variable
{#env}SF-then-Pattern-Variable-Use[OK, #name, #sink, #variable, #term, ok¹.#[ok¹]] 
→ {#env}SF-then-Pattern-Variable-Use2[$[{#env}Get[VARIABLE_ENTRY], #variable, FREE], #name, #sink, #variable, #term, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Variable-Use2[VARIABLE_ENTRY, $String, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - bound variable
{#env}SF-then-Pattern-Variable-Use2[BOUND, #name, #sink, #variable, #term, ok¹.#[ok¹]] 
→ %n⟪¶/* Function «COMMENT_TOKEN[#name]» case for pattern bound variable. */
if («#variable» != VARIABLE(«#term»)) { «{#env}SF-fail-cleanup[#sink]» break;}«{#env}#[OK]»⟫;

// - free variable case is always last
{#env}SF-then-Pattern-Variable-Use2[FREE, #name, #sink, #variable, #term, ok¹.#[ok¹]] 
→ %n⟪/* Function «COMMENT_TOKEN[#name]» fall-back case for free variable */
Variable «#variable» = linkVariable(«#sink»->context, VARIABLE(«#term»));«{#env}#[OK]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-Norm[$Boolean <!-- Need normalization? -->, Pattern-Stage, $String, $List[Reified_Binder], Text, Text, Text, ok::OK_SORT.Text] :: Text;

{#env; #term : SUB[#parent, #i, $True, $True]}
SF-Pattern-MetaArgs-Norm[$True, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→ %n⟪« #setup »
UNLINK_SUB(«#sink»->context, «#parent»,  «INTEGER[#i]»); «#term» = NORMALIZEP(«#sink»->context, «#term»); SUB(«#parent»,  «INTEGER[#i]») = LINK(«#sink»->context, «#term»);«
{#env}SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]»⟫;

{#env; #term : SUB[#parent, #i, $True, $False]} //  argument is a closure. 
SF-Pattern-MetaArgs-Norm[$True, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→ 
%n⟪« #setup »«{#env}SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]»⟫;

{#env; #term : ARG[#i, $True]} // Argument is a term
SF-Pattern-MetaArgs-Norm[$True, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→ 
%n⟪« #setup »
«#term» = NORMALIZEP(«#sink»->context, «#term»);«{#env}SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]»⟫;

{#env; #term : ARG[#i, $False]} // Argument is a closure
SF-Pattern-MetaArgs-Norm[$True, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→ 
%n⟪« #setup »«{#env}SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]»⟫;

// No normalization needed. 
{#env}
SF-Pattern-MetaArgs-Norm[$False, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »«{#env}SF-Pattern-MetaArgs-bind[$[:,"MetaVar$",#MetaVar], #MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-Copy[$String, $List[Reified_Binder], Text, Text, ok::OK_SORT.Text] :: Text;

{#env}
SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]
→ 
{#env}
SF-Pattern-MetaArgs-bind[$[:,"MetaVar$",#MetaVar], #MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-bind[$String, $String, $List[Reified_Binder], Text, Text, ok::OK_SORT.Text] :: Text;

{#env}
SF-Pattern-MetaArgs-bind[#MetaVarCookie, #MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]
→
%n⟪¶/* «#term» = « COMMENT_TOKEN[#MetaVar] » */
« {#env; #MetaVarCookie : VARIABLE[#term]}SF-Pattern-MetaArgs[#MetaVar, #MetaArgs, 0, #sink, #term, ok¹.#[ok¹]] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs[$String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

// Helper for meta-application variable .
{#env}SF-Pattern-MetaArgs[#MetaVar, (), #index, #sink, #term, ok¹.#[ok¹]]
→
{#env}SF-Pattern-MetaArgs-arity[$[:,#MetaVar,"$arity"], #index, ok¹.#[ok¹]];

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs[#MetaVar, (ARGUMENT[#sort, VARIABLE-USE[variable]]; #MetaArgs), #index, sink, term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern-MetaArgs-variable[$[:,#MetaVar,"$",$[FormatNumber, #index]], $[:,"Reuse$",#MetaVar,"$",$[FormatNumber, #index]], variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}SF-Pattern-MetaArgs-arity[$String, $Numeric, ok::OK_SORT.Text] :: Text;

-[Data[#MetaVarArity]]
:
{#env}
SF-Pattern-MetaArgs-arity[#MetaVarArity, #arity, ok¹.#[ok¹]]
→
{#env; #MetaVarArity : NUM_VALUE[#arity]}
#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-variable[$String, $String, Reified_Variable, $String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs-variable[#MetaVarIndex, #ReuseVar, variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
→
{#env; #MetaVarIndex : VARIABLE[variable]}
SF-Pattern-MetaArgs-variable2[$[{#env}Get[STRING_ENTRY], #ReuseVar, NO], variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-variable2[STRING_ENTRY, Reified_Variable, $String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs-variable2[NO, variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern-MetaArgs[#MetaVar, #MetaArgs, $[Plus,#index,1], sink, term, ok¹.#[ok¹]]
;

-[Free[reuse::Text, sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs-variable2[VARIABLE[reuse], variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
→
%n⟪Variable «reuse» = «variable»; permitUnusedVariable(«reuse»);
« {#env} SF-Pattern-MetaArgs[#MetaVar, #MetaArgs, $[Plus,#index,1], sink, term, ok¹.#[ok¹]] »⟫
;

// Extract sub. Determine if linking is needed when meta var is not just an intermediary construction.
// The sub can either be on the C function argument list or in a term.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub[Reified_Term, PASS, $Boolean, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

{#env}SF-PatternSub[PROPERTY-REF[#Ref, #Use, #Term], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub[#Term,  #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[PROPERTY[#Key, #Value, #Term], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub[#Term, #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[PROPERTY-NOT[#Key, #Term], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub[#Term, #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[CONSTRUCTION[#kind, #Symbol, #Binder], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[LITERAL[#Value, #Sort], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[VARIABLE-USE[#Variable], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];
 
{#env}SF-PatternSub[META-APPLICATION[#MetaVar, #Binders, USE[#Count]], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→
{#env}SF-PatternSub2[$True, SF-is-top-stage[#stage], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[META-APPLICATION[#MetaVar, #Binders, DISCARD], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];
 
{#env}SF-PatternSub[EVALUATOR[#Primitive, #Patterns, #Options], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub2[$Boolean<!-- Whether to link sub -->, $Boolean<!-- Processing top terms -->, PASS, $Boolean, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

// Get top-level arguments. No need to link as all top-level arguments have a reference. 
// Might need to unlink if it's a term. 
{#env}SF-PatternSub2[#link, $True, #pass, #hasfun, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2a[$[{#env}Get[STRING_ENTRY], "$args"], #link, $True, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

// A sub to link. Record to unlink only when pattern fails
{#env}SF-PatternSub2[$True, $False, #pass, #hasfun, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2b[$[{#env}Get[STRING_ENTRY], "$subterms"], $True, $False, #pass, #hasfun, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

// A temporary sub. Don't link and don't record for unlink
-[Fresh[sub::Text]]
:
{#env}
SF-PatternSub2[$False, $False, #pass, #hasfun, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→
{#env; sub: SUB[#term, #i, $False, Not[#hasfun]]}
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #Pattern, #sink, %n⟪« #code »
Term «sub» = SUB(«#term», «INTEGER[#i]»); int «sub»_count = «#term»_count*LINK_COUNT(«sub»); permitUnusedInt(«sub»_count);«D-check-sort[#sink, sub, #sort]»⟫, $False, #unique, sub, ok¹.#[ok¹]];

// Top level argument helper
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub2a[STRING_ENTRY, $Boolean<!-- Whether to link sub -->, $Boolean<!-- Processing top terms -->, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

{#env}SF-PatternSub2a[LIST_VARIABLE[(#arg; #args)], #link, $True, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env; "$args" : LIST_VARIABLE[#args]} // Navigate to the next argument.
SF-PatternSub3[#arg, $[{#env}Get[VARIABLE_ENTRY], #arg], #link, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] ;

//  Sub argument helper
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub2b[STRING_ENTRY, $Boolean<!-- Whether to link sub -->, $Boolean<!-- Processing top terms -->, PASS, $Boolean, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

// A sub to link. Record to unlink only when pattern fails
-[Fresh[sub::Text]]:
{#env}SF-PatternSub2b[LIST_VARIABLE[#subs], $True, $False, #pass, #hasfun, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env; sub: SUB[#term, #i, $True, Not[#hasfun]]; "$subterms":LIST_VARIABLE[(sub; #subs)]}
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #pattern, #sink, %n⟪« #code »
Term «sub» = LINK(«#sink»->context, SUB(«#term», «INTEGER[#i]»)); int «sub»_count = «#term»_count*LINK_COUNT(«sub»); permitUnusedInt(«sub»_count);«D-check-sort[#sink, sub, #sort]»⟫, $True, #unique, sub, ok¹.#[ok¹]];

// Processing a top-level argument. 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub3[Text, VARIABLE_ENTRY, $Boolean<!-- Whether to link sub -->, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

// Top-level argument is a term or closure and is not discarded. No need to record for unlink or cleanup.
{#env; "$shared": VARIABLE[#count]} 
SF-PatternSub3[#arg, ARG[#Index, #isterm], $True, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}  
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #pattern, #sink, %n⟪« #code »
int «#arg»_count = «#count»*LINK_COUNT(«#arg»); permitUnusedInt(«#arg»_count);«D-check-sort[#sink, #arg, #sort]»⟫, $True, #unique, #arg, ok¹.#[ok¹]];

// Top-level argument is a term or closure and is discarded. Record for unlink, but not cleanup (fallback uses reference).
{#env; "$terms": LIST_VARIABLE[#subs];  "$shared": VARIABLE[#count]} 
SF-PatternSub3[#arg, ARG[#index, #isterm], $False, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env; "$terms":LIST_VARIABLE[(#arg; #subs)]} // Record for unlink
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #pattern, #sink, %n⟪« #code »
int «#arg»_count = «#count»*LINK_COUNT(«#arg»); permitUnusedInt(«#arg»_count);«D-check-sort[#sink, #arg, #sort]»⟫, $False, #unique, #arg, ok¹.#[ok¹]];

//// Top-level argument is a closure
//{#env}SF-PatternSub3[#arg, ARG[#index, $False], #link, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
//→ 
//{#env}SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #Pattern, #sink, #code, $True, #unique, #arg, ok¹.#[ok¹]];

// Stage management.

SF-is-top-stage[Pattern-Stage] :: $Boolean;

SF-is-top-stage[MATCH]                              → $True; 
SF-is-top-stage[SUBMATCH]                           → $False;
SF-is-top-stage[DISPATCH[#Name,#Options,#SortName]] → $True;
SF-is-top-stage[CASE[#Name,#Options,#SortName]]     → $False;


SF-move-to-sub-stage[Pattern-Stage] :: Pattern-Stage;

SF-move-to-sub-stage[MATCH]                              →  SUBMATCH;
SF-move-to-sub-stage[SUBMATCH]                           →  SUBMATCH;
SF-move-to-sub-stage[DISPATCH[#Name,#Options,#SortName]] →  CASE[#Name,#Options,#SortName];
SF-move-to-sub-stage[CASE[#Name,#Options,#SortName]]     →  SUBMATCH;

//
// When pattern matching fails, intermediate linked terms, properties and variables must be unlinked  
//
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-fail-cleanup[Text] :: Text;

{#env;
    "$subrefs"  : LIST_STRING[#refs];    
    "$subterms" : LIST_VARIABLE[#terms] 
}
SF-fail-cleanup[#sink] 
→
%n⟪«{#env}SF-unlink-refs[#sink, #refs]»«{#env}SF-unlink-terms[#sink, #terms]»⟫  
;

//
// Unlink property refs 
//

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}SF-unlink-refs[Text, $List[$String]] :: Text;

{#env}SF-unlink-refs[#sink, ()] → %n⟪⟫;

{#env}SF-unlink-refs[#sink, (#refcookie; #refs)] 
→
%n⟪«{#env}SF-unlink-refs2[#sink, $[{#env}Get[STRING_ENTRY], #refcookie]]»«{#env}SF-unlink-refs[#sink, #refs]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-unlink-refs2[Text, STRING_ENTRY] :: Text;

{#env}SF-unlink-refs2[#sink, PROPERTY_VARIABLE[#namedP, #varP]] 
→ 
%n⟪
UNLINK_NamedPropertyLink(«#sink»->context, «#namedP»); 
UNLINK_VariablePropertyLink(«#sink»->context, «#varP»);⟫;

//
// Unlink terms.
//

SF-unlink-terms[Text, $List[Reified_Variable]] :: Text;

SF-unlink-terms[#sink, ()]       → %n⟪⟫; 
SF-unlink-terms[#sink, (#v;#vs)] → %n⟪¶UNLINK(«#sink»->context, «#v»);«SF-unlink-terms[#sink, #vs]»⟫;

// Print a comment indicating the beginning of the unused section.
SF-unlink-comment[$List[$String], $List[Reified_Variable]] :: Text;

SF-unlink-comment[(), ()] → %n⟪⟫; 
SF-unlink-comment[#1, #2] → %n⟪¶¶/* -- Unused terms cleanup -- */⟫; 

// 
// Done matching term against pattern. 
// Unlink unused terms and variable then move on to contraction.  
//
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-eval[OK_SORT, Text, Reified_Term, Text] :: Text;

{#env;
    "$refs"     : LIST_STRING[#refs];
    "$terms"    : LIST_VARIABLE[#terms]
}
SF-then-eval[OK, #term, #contractum, #sink]
→
%n⟪«SF-unlink-comment[#refs, #terms]»«{#env}SF-unlink-refs[#sink, #refs]»«{#env}SF-unlink-terms[#sink, #terms]»

/* -- Contraction -- */«{#env; "$tail": YES}ST-then-send[OK, #contractum, #sink]»⟫;


///////////////////////////////////////////////////////////////////////////////////////////////////
)] //SF
