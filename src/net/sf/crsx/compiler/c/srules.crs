// Copyright © 2012,2013 IBM Corporation
// $Id: rules.crs,v 3.29 2013/12/18 20:16:18 villardl Exp $

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE C RULES FILE TEXT FROM REIFIED CRSX. STRICT MODE
///////////////////////////////////////////////////////////////////////////////////////////////////

SRULES[(

$Use["compiler/c/cdefs.crs"];
$Use["compiler/c/sterm.crs"];

$Lax;

//
// Generate top-level functions
//
// Generate 2 C functions per sorts:
//  - a step function: unwraps top-level arguments and calls the second function
//  - a direct function: correspond to the rule's body.
//
SF-Function[$String, $String, $List[Reified_Form], Reified_Sort, $List[Reified_Rule]] :: Text;

//«SF-closures[#function, #Rules]»

-[Fresh[sink::Text, term::Text, count::Text, namedP::Text, varP::Text]]
:
SF-Function[#kind, #function, #Forms, #Sort, #Rules]
→
%n⟪«SF-function-extern[#function, #Forms, #Sort]»

/* STEP FUNCTION « COMMENT_TOKEN[#function] ». */
int «Step[#function]»(Sink «sink», Term «term», ...)
{⟦« SF-step-body[#kind, sink, term, #function, #Forms, #Sort, #Rules] »⟧¶}

/* FUNCTION « COMMENT_TOKEN[#function] ». */
int «MANGLE[#function]»(Sink «sink», ssize_t «count», NamedPropertyLink «namedP», VariablePropertyLink «varP»« 
                                    {
                                        "$Function"    : STRING_VALUE[#function]; 
                                        "$ClosureCount": NUM_VALUE[0]; 
                                        "$Sink"        : VARIABLE[sink]; 
                                        "$shared"      : VARIABLE[count];                                       // Record sharing count.
                                        "$Args"        : LIST_VARIABLE[()];
                                        "$TopRef"      : PROPERTY_VARIABLE[namedP, varP];
                                        "$Strict"      : YES;
                                        "$unstep"      : TEXT[%n⟨⟩];                                            // The unstep code. Built by SF-Arg.
                                        "$unstep-props": TEXT[%n⟨¶ADD_PROPERTIES(‹sink›, ‹namedP›, ‹varP›);⟩];  // The properties unstep code. 
                                     }
                                    SF-Arg[#Forms, $True, ok¹.SF-Body[ok¹, #kind, #Rules]] »⟫;

// Generate the name function and construction descriptor extern C 
SF-function-extern[$String, $List[Reified_Form], Reified_Sort] :: Text;

SF-function-extern[#function, (SORT-ALLOWS-VARIABLES; #Forms), #Sort]           → SF-function-extern[#function, #Forms, #Sort];
SF-function-extern[#function, (SORT-SET[#Key, #Value, #Form]; #Forms), #Sort]   → SF-function-extern[#function, (#Form; #Forms), #Sort];

SF-function-extern[#function, (FORM[#Constructor, #FormArguments]; #Forms), #Sort]
→
%n⟪¶¶int « BinderOffsets[#function] »[] = {0« DelayMapText[k o.%n⟨ , ‹ DINTEGER[k, o] ›⟩, FormArguments-binder-offsets-strict[#FormArguments, 0]] »};
char *« NameFun[#function] »(Term term) { return (char *) « STRING[#function] »; }«SF-function-desc[#function, #Sort, #FormArguments]»⟫;

SF-function-desc[$String, Reified_Sort, $List[Reified_FormArgument]] :: Text;

SF-function-desc[#function, SORT[#SortName,#SortArgs], #FormArguments] 
→
%n⟪¶struct _ConstructionDescriptor « Descriptor[#function] » = {« $[If, $[Contains, #SortName, "$"], %n⟨NULL⟩, %n⟨&‹Sort[#SortName]›⟩] », 0, « INTEGER[Length[#FormArguments,0]] », sizeof(STRUCT« Struct[#function] »), « BinderOffsets[#function] », &« NameFun[#function] », &« Step[#function] »};⟫;

SF-function-desc[#function, SORT-VARIABLE[#SortVariable], #FormArguments] 
→
%n⟪¶struct _ConstructionDescriptor « Descriptor[#function] » = {NULL, 0, « INTEGER[Length[#FormArguments,0]] », sizeof(STRUCT« Struct[#function] »), « BinderOffsets[#function] », &« NameFun[#function] », &« Step[#function] »};⟫;
 
//
// Generate step function. Extract subs and invokes C function.
//

SF-step-body[$String, Text, Text, $String, $List[Reified_Form], Reified_Sort, $List[Reified_Rule]] :: Text;

SF-step-body[#kind, #sink, #term, #function, #Forms, #Sort, #Rules] →
    %n⟪¶va_list ap;
va_start(ap, « #term »);
ssize_t shared = LINK_COUNT(« #term »);
NamedPropertyLink namedP = LINK_NamedPropertyLink(«#sink»->context, NAMED_PROPERTIES(«#term»)); 
VariablePropertyLink varP = LINK_VariablePropertyLink(«#sink»->context, VARIABLE_PROPERTIES(«#term»));«SF-extract-props[#Forms, $True, #sink, #term, (), ok¹ args¹.SF-StepUnlinkTerm[ok¹, #sink, #term, args¹, #function]]»⟫;

SF-extract-props[$List[Reified_Form], $Boolean<!-- Environment generated? -->, Text, Text, $List[Text], ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

SF-extract-props[(), #hasSortSet, #sink, #term, #args, ok¹ args¹.#[ok¹, args¹]] → // Function with no argument and no environment. 
    #[OK, #args];

SF-extract-props[(SORT-ALLOWS-VARIABLES; #Forms), #hasSortSet, #sink, #term, #args, ok¹ args¹.#[ok¹, args¹]] → 
    SF-extract-props[#Forms, #hasSortSet, #sink, #term, #args, ok¹ args¹.#[ok¹, args¹]];

SF-extract-props[(SORT-SET[#Sort1, #Sort2, #Form]; #Forms), $True, #sink, #term, #args, ok¹ args¹.#[ok¹, args¹]] → 
    SF-extract-props[(#Form; #Forms), $True, #sink, #term, #args, ok¹ args¹.#[ok¹, args¹]];

-[Fresh[namedP::Text, varP::Text]]
:
SF-extract-props[(SORT-SET[#Sort1, #Sort2, #Form]; #Forms), $False, #sink, #term, #args, ok¹ args¹.#[ok¹, args¹]]  → 
    %n⟪¶NamedPropertyLink «namedP» = LINK_NamedPropertyLink(«#sink»->context, NAMED_PROPERTIES(«#term»)); 
VariablePropertyLink «varP» = LINK_VariablePropertyLink(«#sink»->context, VARIABLE_PROPERTIES(«#term»));«SF-extract-props[(#Form; #Forms), $True, #sink, #term, Append[#args, (namedP;varP;)], ok¹ args¹.#[ok¹, args¹]]»⟫;

SF-extract-props[(FORM[#Constructor, #Args];), #hasSortSet, #sink, #term, #args, ok¹ args¹.#[ok¹, args¹]] → 
    SF-ExtractSubs[OK, #Args, #sink, #term, #args, 0, ok¹ args¹.#[ok¹, args¹]];

// Go through the list of the function arguments

SF-ExtractSubs[OK_SORT, $List[Reified_FormArgument], Text, Text, $List[Text], $Numeric, ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

SF-ExtractSubs[OK, (), #sink, #term, #args, #subi, ok¹ args¹.#[ok¹, args¹]] 
→
#[OK, #args]
;

SF-ExtractSubs[OK, (#Arg; #Args), #sink, #term, #args, #subi, ok¹ args¹.#[ok¹, args¹]] 
→
SF-ExtractSub[HasFunctionalFormBinders[#Arg], #Arg, #sink, #term, #args, #subi, ok¹ args¹.SF-ExtractSubs[ok¹, #Args, #sink, #term, args¹, $[Plus, #subi, 1], ok¹ args¹.#[ok¹, args¹]]]
;

// Apply same rule: if FormArgument contains at least one functional binder, generate
// a Closure. Otherwise, generate variable + term

SF-ExtractSub[$Boolean, Reified_FormArgument, Text, Text, $List[Text], $Numeric, ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

SF-ExtractSub[$True, #Arg, #sink, #term, #args, #subi, ok¹ args¹.#[ok¹, args¹]]
→
SF-ExtractClosure[#term, #sink, #args, #subi, ok¹ args¹.#[ok¹, args¹]] 
;

SF-ExtractSub[$False, #Arg, #sink, #term, #args, #subi, ok¹ args¹.#[ok¹, args¹]]
→
SF-ExtractTerm[#Arg, #sink, #term, #args, #subi, 0, ok¹ args¹.#[ok¹, args¹]] 
;
 
// The top level argument has no functional binders. Extract variables for each binder and a term
SF-ExtractTerm[Reified_FormArgument, Text, Text, $List[Text], $Numeric, $Numeric, ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

-[Fresh[var::Text]]
:
SF-ExtractTerm[FORM-BINDER[KDATA, #Sort, v.#FormArgument[v]], #sink, #term, #args, #subi, #binderi, ok¹ args¹.#[ok¹, args¹]] // Kind must be KDATA
→
%n⟪
Variable «var» = linkVariable(«#sink»->context, BINDER(«#term»,«INTEGER[#subi]»,«INTEGER[#binderi]»));«SF-ExtractTerm[#FormArgument[var], #sink, #term, Append[#args, (var;)], #subi, $[Plus, #binderi, 1], ok¹ args¹.#[ok¹, args¹]]»⟫
;

-[Fresh[term::Text]]
:
SF-ExtractTerm[FORM-ARGUMENT[#Sort], #sink, #term, #args, #subi, #binderi, ok¹ args¹.#[ok¹, args¹]]
→
%n⟪
Term «term» = IS_FUNCTIONAL_USE(«#sink»->context, SUB(«#term», «INTEGER[#subi]»)) ? va_arg(ap, Term) : LINK(«#sink»->context, SUB(«#term», «INTEGER[#subi]»));«#[OK, Append[#args, (term;)]]»⟫
;

SF-ExtractClosure[Text, Text, $List[Text], $Numeric, ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

-[Fresh[closure::Text]]
:
SF-ExtractClosure[#term, #sink, #args, #subi, ok¹ args¹.#[ok¹, args¹]]
→
%n⟪
Term «closure» = IS_FUNCTIONAL_USE(«#sink»->context, SUB(«#term», «INTEGER[#subi]»)) ? va_arg(ap, Term) : LINK(«#sink»->context, SUB(«#term», «INTEGER[#subi]»));«#[OK, Append[#args, (closure;)]]»⟫
;

SF-StepUnlinkTerm[OK_SORT, Text, Text, $List[Text], $String] :: Text;

SF-StepUnlinkTerm[OK, #sink, #term, #args, #function]
→
%n⟪
UNLINK(«#sink»->context, «#term»);
va_end(ap);
return «MANGLE[#function]»(«#sink»,shared, namedP, varP«ConcatText[#args,%n⟨,⟩]»);⟫
;

// 
// Generate closure invocation functions, as well as associated descriptor.
// 
// Traverses the contraction and generate C function for each closure.
// These C functions extract the arguments from the environment (if any)
// and call the closed function.
//
// TODO: give example

SF-closures[$String, $List[Reified_Rule]] :: Text;

SF-closures[#function, ()] 
→ 
%n⟪⟫;

SF-closures[#function, (#rule; #rules)] 
→ 
%n⟪«SF-closure-rule[#function, #rule]»«SF-closures[#function, #rules]»⟫;

SF-closure-rule[$String, Reified_Rule] :: Text;

SF-closure-rule[#function, RULE[#name, #options, #pattern, #contractum]]
→
{
    "$Function"     : STRING_VALUE[#function]; 
    "$ClosureCount" : NUM_VALUE[0]
} 
SF-Closure-Term[OK, #contractum, ok¹.%n⟪⟫];

// Traverse the term and look for function with binders (functional or data).

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Term[OK_SORT, Reified_Term, ok¹::OK_SORT.Text] :: Text;

{#env}
SF-Closure-Term[OK, PROPERTY-REF[#Ref, #Use, #term], ok¹.#[ok¹]]  
→
{#env}
SF-Closure-Term[OK, #term, ok¹.#[ok¹]]
;

{#env}
SF-Closure-Term[OK, PROPERTY[#Key, #Value, #Scope], ok¹.#[ok¹]] 
→
{#env}
SF-Closure-Term[OK, #Value, ok¹.SF-Closure-Term[ok¹, #Scope, ok¹.#[ok¹]]]
; 

{#env}
SF-Closure-Term[OK, PROPERTY-NOT[#Key, #Scope], ok¹.#[ok¹]] 
→
{#env}
SF-Closure-Term[OK, #Scope, ok¹.#[ok¹]]
; 
  
{#env}
SF-Closure-Term[OK,CONSTRUCTION[#kind, #Symbol, #Binders], ok¹.#[ok¹]] 
→
{#env}
SF-Closure-Binders[OK, #Binders, ok¹.#[ok¹]]
;

{#env}
SF-Closure-Term[OK, LITERAL[#Literal, #Sort], ok¹.#[ok¹]]
→
{#env}
#[OK]
;

{#env}
SF-Closure-Term[OK, VARIABLE-USE[#variable], ok¹.#[ok¹]]
→
{#env}
#[OK]
;

{#env}
SF-Closure-Term[OK, META-APPLICATION[#MetaVar, #Arguments, #Use], ok¹.#[ok¹]]
→
{#env}
SF-Closure-Binders[OK, #Arguments, ok¹.#[ok¹]]
;

{#env}
SF-Closure-Term[OK, EVALUATOR[#Primitive, #Terms, #Options], ok¹.#[ok¹]]
→
{#env}
SF-Closure-Terms[OK, #Terms, ok¹.#[ok¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Terms[OK_SORT, $List[Reified_Term], ok¹::OK_SORT.Text] :: Text;

{#env}
SF-Closure-Terms[OK, (), ok¹.#[ok¹]]
→
{#env}
#[OK]
;

{#env}
SF-Closure-Terms[OK, (#Term; #Terms), ok¹.#[ok¹]]
→
{#env}
SF-Closure-Term[OK, #Term, ok¹.SF-Closure-Terms[ok¹, #Terms, ok¹.#[ok¹]]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Binders[OK_SORT, $List[Reified_Binder], ok¹::OK_SORT.Text] :: Text;

{#env}
SF-Closure-Binders[OK, (), ok¹.#[ok¹]]
→
{#env}
#[OK]
;

{#env}
SF-Closure-Binders[OK, (#Binder; #Binders), ok¹.#[ok¹]]
→
{#env}
SF-Closure-Binder[HasFunctionalBinders[#Binder], #Binder, ok¹.SF-Closure-Binders[ok¹, #Binders, ok¹.#[ok¹]]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Binder[$Boolean, Reified_Binder, ok¹::OK_SORT.Text] :: Text;

// Subterm without function binders, not a candidate. Move on.
{#env}
SF-Closure-Binder[$False, #Binder, ok¹.#[ok¹]]
→
{#env}
SF-Closure-Term[OK, MoveToTerm[#Binder], ok¹.#[ok¹]]
;

// At least one functional binder. Generate closure invocation function (TODO: currying).
{#env}
SF-Closure-Binder[$True, #Binder, ok¹.#[ok¹]]
→
{#env}
SF-Closure-Function[#Binder, (), 0, ok¹.#[ok¹]]
;

// Just iterate over the binders, gather their kind (data vs functional) and count them.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Function[Reified_Binder, $List[Reified_Variable], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}
SF-Closure-Function[ARGUMENT[#sort, #Term], #Binders, #Count, ok¹.#[ok¹]]
→
{#env}
SF-Closure-Arguments[#Term, #Binders, #Count, ok¹.#[ok¹]]
;

-[Fresh[b::Reified_Variable]]
:
{#env}
SF-Closure-Function[BINDER[#promisc, #kind, #depth, #sort, #occs, b.#Binder[b]], #Binders, #Count, ok¹.#[ok¹]]
→
{#env; b: SF-BoundKind[#kind]}
SF-Closure-Function[#Binder[b], Append[#Binders, (b;)], $[Plus, #Count, 1], ok¹.#[ok¹]] // Preserve binder order.
;

// At that point we have a term with functional binders. 
// Move to the subterm with binder. Error if subterm is of a wrong type.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Arguments[Reified_Term, $List[Reified_Variable], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}
SF-Closure-Arguments[PROPERTY-REF[#Ref, #Use, #Term], #Binders, #Count, ok¹.#[ok¹]]  // TODO: should be counted as one of the arguments
→
{#env}
SF-Closure-Arguments[#Term, #Binders, #Count, ok¹.#[ok¹]]
;

// x..y.T[...]. Good we found a closure. Create the function to invoke it.
{#env}
SF-Closure-Arguments[CONSTRUCTION[#Kind, #Symbol, #Arguments], #Binders, #Count, ok¹.#[ok¹]] 
→
{#env; "$Symbol":STRING_VALUE[#Symbol]}
SF-Create-Closure[#Symbol, #Arguments, #Binders, #Count, ok¹.#[ok¹]]
;

// x..y.Literal. Just proceed.
{#env}
SF-Closure-Arguments[LITERAL[#Literal, #Sort], #Binders, #Count, ok¹.#[ok¹]]
→
{#env}
#[OK]
;

// x...y.x: no need to generate a closure. Use builtin identity function.
{#env}
SF-Closure-Arguments[VARIABLE-USE[#variable], #Binders, #Count, ok¹.#[ok¹]]
→
{#env}
#[OK]
;

// x...y.#[ ... ]. Potentially currying. TODO
{#env}
SF-Closure-Arguments[META-APPLICATION[#MetaVar, #Arguments, #Use], #Binders, #Count, ok¹.#[ok¹]]
→
{#env}
SF-Closure-Binders[OK, #Arguments, ok¹.#[ok¹]]
;

// x..y.$[ ... ]. Not a closure. Proceed to the primitive arguments.
{#env}
SF-Closure-Arguments[EVALUATOR[#Primitive, #Terms, #Options], #Binders, #Count, ok¹.#[ok¹]]
→
{#env}
SF-Closure-Terms[OK, #Terms, ok¹.#[ok¹]]
;

//------------ Here start the generation of the C function invoking the closure!

// Simplifier ensures the binders order is preserved. 
// x y.C[x,y  <== x is before y.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Create-Closure[$String, $List[Reified_Binder], $List[Reified_Variable], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}
SF-Create-Closure[#Symbol, #Arguments, #Binders, #Count, ok¹.#[ok¹]] 
→
{#env}
SF-ClosureName[name¹.SF-Create-Closure1[name¹, #Arguments, #Binders, #Count, ok¹.#[ok¹]]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Create-Closure1[Text, $List[Reified_Binder], $List[Reified_Variable], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-Create-Closure1[#Name, #Arguments, #Binders, #Count, ok¹.#[ok¹]] 
→
%n⟪¶static int «#Name»(Sink sink, CEnv env«{#env}SF-Create-Params[#Binders, #Arguments, ok¹.#[ok¹]]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Create-Params[$List[Reified_Variable], $List[Reified_Binder], ok¹::OK_SORT.Text] :: Text;

{#env}SF-Create-Params[(), #Arguments, ok¹.#[ok¹]]
→
{#env}SF-Closure-Body[#Arguments, ok¹.#[ok¹]];

{#env}SF-Create-Params[(#Binder;#Binders), #Arguments, ok¹.#[ok¹]]
→
%n⟪,«SF-ParamType[$[{#env}Get[VARIABLE_ENTRY], #Binder]]» «#Binder»«{#env}SF-Create-Params[#Binders, #Arguments, ok¹.#[ok¹]]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Body[$List[Reified_Binder], ok¹::OK_SORT.Text] :: Text;

{#env}SF-Closure-Body[#Arguments, ok¹.#[ok¹]]
→
%n⟪) {⟦
«{#env}SF-Closure-Env[#Arguments, (), (), 0]»
⟧
}
«{#env}#[OK]»
⟫;

// Traverse the construction argument and identify captured values. Get them out of the environment.
// Handle the case where there is no captured values (TODO: and only one captured value)

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Env[$List[Reified_Binder], $List[Text]<!-- Calls values -->, $List[Text]<!-- Environment assignments -->, $Numeric<!-- Capture count -->] :: Text;

{#env}
SF-Closure-Env[(), #Values, #Captured, #Count] 
→
{#env}
SF-Closure-Assemble[#Values, #Captured, #Count]
;

// Argument is itself a closure
{#env}
SF-Closure-Env[(BINDER[#Promiscuity, #Kind, #Depth, #Sort, #Occurrences, binder.#Binder[binder]]; #Binders), #Values, #Captured, #Count]
→
{#env}
SF-Closure-Env[#Binders, (%n⟪v«INTEGER[#Count]»⟫;#Values), (%n⟪
Closure v«INTEGER[#Count]» = (Closure) env->values[«INTEGER[#Count]»];⟫;#Captured), $[Plus, #Count, 1]]
;

// Argument is either a bound variable or free variable.
{#env}
SF-Closure-Env[(ARGUMENT[#Sort, VARIABLE-USE[#var]]; #Binders), #Values, #Captured, #Count]
→
{#env}
SF-Closure-EnvVariable[$[{#env}Get[VARIABLE_ENTRY], #var, FREE], #var, #Binders, #Values, #Captured, #Count]
;

// In any other cases, we captured a term. 
-[Fallback]
:
{#env}
SF-Closure-Env[(#Arg; #Binders), #Values, #Captured, #Count]
→
{#env}
SF-Closure-Env[#Binders, (%n⟪v«INTEGER[#Count]»⟫;#Values), (%n⟪
Term v«INTEGER[#Count]» = (Term) env->values[«INTEGER[#Count]»];⟫;#Captured), $[Plus, #Count, 1]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-EnvVariable[VARIABLE_ENTRY, Reified_Variable, $List[Reified_Binder], $List[Text], $List[Text], $Numeric] :: Text;

{#env}
SF-Closure-EnvVariable[BOUND, #var, #Binders, #Values, #Captured, #Count]
→
{#env}
SF-Closure-Env[#Binders, (%n⟪«#var»⟫;#Values), #Captured, #Count]
;

{#env}
SF-Closure-EnvVariable[BOUND_DATA, #var, #Binders, #Values, #Captured, #Count]
→
{#env}
SF-Closure-Env[#Binders, (%n⟪«#var»⟫;#Values), #Captured, #Count]
;

{#env}
SF-Closure-EnvVariable[FREE, #var, #Binders, #Values, #Captured, #Count]
→
{#env}
SF-Closure-Env[#Binders, (%n⟪v«INTEGER[#Count]»⟫;#Values), (%n⟪
Variable v«INTEGER[#Count]» = (Variable) env[«INTEGER[#Count]»];⟫;#Captured), $[Plus, #Count, 1]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Assemble[$List[Text]<!-- Calls values -->, $List[Text]<!-- Environment assignments -->, $Numeric<!-- Capture count -->] :: Text;

{#env}
SF-Closure-Assemble[#Values, #Captured, #Count]
→
$[If, $[Equal, #Count, 0], 
    {#env}SF-Closure-Values[#Values],
    {#env}SF-Closure-Captured[#Captured, #Values]
]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Captured[$List[Text]<!-- Environment assignments -->, $List[Text]<!-- Calls values -->] :: Text;

{#env}
SF-Closure-Captured[(), #Values]
→
%n⟪
unlinkCEnv(sink->context, env);
«{#env}SF-Closure-Values[#Values]»⟫
;

{#env}
SF-Closure-Captured[(#Captured;#Captureds), #Values]
→
%n⟪«#Captured»
«{#env}SF-Closure-Captured[#Captureds, #Values]»⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Closure-Values[$List[Text]<!-- Calls values -->] :: Text;

{#env; "$Symbol":STRING_VALUE[#Symbol]}
SF-Closure-Values[#Values]
→
%n⟪
return «MANGLE[#Symbol]»(sink, 1«ConcatText[#Values, %n⟨,⟩]»);⟫
;

// Some helpers.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-ClosureName[name¹::Text.Text] :: Text;

{#env; "$Function":STRING_VALUE[#Function];"$ClosureCount":NUM_VALUE[#Count]}
SF-ClosureName[name¹.#[name¹]] 
→ 
{#env; "$ClosureCount":NUM_VALUE[$[Plus, #Count, 1]]}
#[%n⟪« MANGLE[$[:, #Function, "$CC$"]]»«INTEGER[#Count]»⟫]
;

SF-ParamType[VARIABLE_ENTRY]:: Text;

SF-ParamType[BOUND_DATA]  → %n⟪Variable⟫;
SF-ParamType[BOUND]       → %n⟪Term⟫; 

SF-BoundKind[Reified_Kind] :: VARIABLE_ENTRY;

SF-BoundKind[KDATA]     → BOUND_DATA;
SF-BoundKind[KFUNCTION] → BOUND;

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE FUNCTION. STRICT MODE.
//
// First: Generate C function signature (starting with the argument).

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Arg[$List[Reified_Form], $Boolean<!-- Environment generated? -->, ok¹::OK_SORT.Text] :: Text;

{#env}
SF-Arg[(), #hasSortSet, ok¹.#[ok¹]] // Function with no argument and no environment. 
→ 
{#env}
#[OK]
;

{#env}
SF-Arg[(SORT-ALLOWS-VARIABLES; #Forms), #hasSortSet, ok¹.#[ok¹]] 
→ 
{#env}
SF-Arg[#Forms, #hasSortSet, ok¹.#[ok¹]]
;

{#env}
SF-Arg[(SORT-SET[#Sort1, #Sort2, #Form]; #Forms), $True, ok¹.#[ok¹]] 
→ 
{#env}
SF-Arg[(#Form; #Forms), $True, ok¹.#[ok¹]]
;

-[Fresh[namedP::Text, varP::Text]]
:
{#env; "$unstep": TEXT[#unstep]; "$Sink": VARIABLE[#sink];}
SF-Arg[(SORT-SET[#Sort1, #Sort2, #Form]; #Forms), $False, ok¹.#[ok¹]] 
→ 
%n⟪, NamedPropertyLink «namedP», VariablePropertyLink «varP»«
        {
            #env; 
            "$TopRef"       : PROPERTY_VARIABLE[namedP, varP]; 
            "$unstep-props" : TEXT[%n⟨¶ADD_PROPERTIES(‹#sink›, ‹namedP›, ‹varP›);⟩]
        }
        SF-Arg[(#Form; #Forms), $True, ok¹.#[ok¹]]»⟫;

{#env}
SF-Arg[(FORM[#Constructor, #Args];), #hasSortSet, ok¹.#[ok¹]] 
→ 
{#env; "$TopArgs": TOPARGS[#Args]}
SF-TopArgs[OK, #Args, 0, ok¹.#[ok¹]]
;

// Go through the list of the function arguments

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopArgs[OK_SORT, $List[Reified_FormArgument], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}
SF-TopArgs[OK, (), #Index, ok¹.#[ok¹]] 
→
{#env}
#[OK]
;

{#env}
SF-TopArgs[OK, (#Arg; #Args), #Index, ok¹.#[ok¹]] 
→
{#env}
SF-TopArg[HasFunctionalFormBinders[#Arg], #Arg, #Index, ok¹ index¹.SF-TopArgs[ok¹, #Args, index¹, ok¹.#[ok¹]]]
;

// Apply same rule: if FormArgument contains at least one functional binder, generate
// a Closure. Otherwise, generate variable + term

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopArg[$Boolean, Reified_FormArgument, $Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

{#env}
SF-TopArg[$True, #Arg, #Index, ok¹ index¹.#[ok¹, index¹]]
→
{#env}
SF-TopClosure[#Index, ok¹ index¹.#[ok¹, index¹]] 
;

{#env}
SF-TopArg[$False, #Arg, #Index, ok¹ index¹.#[ok¹, index¹]]
→
{#env; "$UnstepBinders": LIST_VARIABLE[()]}
SF-TopTerm[#Arg, #Index, ok¹ index¹.#[ok¹, index¹]] 
;
 
// The top level argument has no functional binders. Generate variables for each binder and a term
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopTerm[Reified_FormArgument, $Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

-[Fresh[var::Text]]
:
{#env; "$Args":LIST_VARIABLE[#TopArgs];"$UnstepBinders": LIST_VARIABLE[#binders]}
SF-TopTerm[FORM-BINDER[KDATA, #Sort, v.#FormArgument[v]], #Index, ok¹ index¹.#[ok¹, index¹]] // Kind must be KDATA
→
%n⟪, Variable «var»«{#env;  "$Args":LIST_VARIABLE[Append[#TopArgs,(var;)]]; var:ARG[#Index, $True]; "$UnstepBinders":LIST_VARIABLE[(var; #binders)]}SF-TopTerm[#FormArgument[var], $[Plus, #Index, 1], ok¹ index¹.#[ok¹, index¹]]»⟫
;

-[Fresh[term::Text]]
:
{#env; "$Args":LIST_VARIABLE[#TopArgs];"$unstep": TEXT[#unstep]; "$Sink": VARIABLE[#sink]}
SF-TopTerm[FORM-ARGUMENT[#Sort], #Index, ok¹ index¹.#[ok¹, index¹]]
→
%n⟪, Term «term»« 
        {#env; 
            "$Args"     : LIST_VARIABLE[Append[#TopArgs,(term;)]]; 
            term        : ARG[#Index, $True];
            "$unstep"   : TEXT[ConcatText[(#unstep; {#env}SF-UnstepBinders; %n⟨¶COPY(‹#sink›, ‹term›);⟩;), %n⟨⟩]]
        }
        #[OK, $[Plus, #Index, 1]]»⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-TopClosure[$Numeric, ok¹::OK_SORT index¹::$Numeric.Text] :: Text;

-[Fresh[closure::Text]]
:
{#env; "$Args":LIST_VARIABLE[#TopArgs]}
SF-TopClosure[#Index, ok¹ index¹.#[ok¹, index¹]]
→
%n⟪, Term «closure»«{#env; "$Args":LIST_VARIABLE[Append[#TopArgs,(closure;)]];closure:ARG[#Index, $False]}#[OK, $[Plus, #Index, 1]]»⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-UnstepBinders :: Text;

{#env}SF-UnstepBinders →  {#env}SF-UnstepBinders2[$[{#env}Get[STRING_ENTRY], "$UnstepBinders"], $[{#env}Get[STRING_ENTRY], "$Sink"]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-UnstepBinders2[STRING_ENTRY, STRING_ENTRY] :: Text;

{#env}
SF-UnstepBinders2[LIST_VARIABLE[()], #sink] → %n⟪⟫;

-[Fresh[binders::Text]]
:
{#env}
SF-UnstepBinders2[LIST_VARIABLE[(#binder; #binders)], VARIABLE[#sink]]
→ 
%n⟪«MapText[x.%n⟨¶REBIND(‹x›);⟩, (#binder; #binders)]»
Variable «binders»[«INTEGER[Length[(#binder;#binders), 0]]»] = {«#binder»«ConcatText[#binders, %n⟨, ⟩]»}; BINDS(«#sink», «INTEGER[Length[(#binder;#binders), 0]]», «binders»);⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Body[OK_SORT, $String, $List[Reified_Rule]] :: Text;

{#env}
SF-Body[OK, #kind, #Rules] 
→
%n⟪)
{⟦«
    $[If, $[Equal, #kind, "Contract"],       {#env}SF-Contract[#Rules],
    $[If, $[Equal, #kind, "BinderDispatch"], {#env}SF-Contract[#Rules], 
    $[If, $[Equal, #kind, "Dispatch"],       {#env}SF-Dispatch[#Rules],  
    $[If, $[Equal, #kind, "Shuffle" ],       {#env}SF-Contract[#Rules],
                                             %n⟨⟩]]]]
»⟧
}⟫
;

//
// Generate C function body. Contraction mode.
//
// The generated C code has the following general form:
//
//     do
//     {
//         { rule1 }
//         ...
//         { rulen }    
//     } while (0);
//     
//     fallback
//      
// where rule has the following form
// 
//     pattern matching
//     unlink unused meta variable and variable
//     contraction
//
// Since pattern matching can fail, intermediate linked meta variables and variables
// must first be unlink before fallback.
//

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Contract[$List[Reified_Rule]] :: Text;

{#env; "$Sink":VARIABLE[#sink]}
SF-Contract[(RULE[#name, #Options, #Pattern, #Contractum]; #Rules)]
→
%n⟪¶do {⟦
/* Contraction rule « COMMENT_TOKEN[#name] ». */« 
    {
        #env;
        "$Vars" : LIST_VARIABLE[()];    // Keep list of linked variable that needs to be unlinked before contraction.
    }
    F-Options[#Options, o3.
    F-then-Fresh[o3, #sink, #Options, ok.
    SF-pattern-init[ok, FIRST, MATCH, #Pattern, #sink, %n⟨⟩, $False, $False, %n⟨⟩, o2.
    SF-then-eval[o2, %n⟨⟩, #Contractum, #sink]]]] »⟧
} while (0);« {#env}SF-Contract[#Rules] »⟫;

// Done with contraction. Generate thunk construction. 
{
    #env; 
    "$unstep"       : TEXT[#unstep];
    "$unstep-props" : TEXT[#unstep-props]; 
    "$Function"     : STRING_VALUE[#function]; 
    "$Sink"         : VARIABLE[#sink]
}
SF-Contract[()]
→
%n⟪

/* Fallback */«#unstep-props»
START(«#sink», «EventConstructor[#function]»);«#unstep»
END(«#sink», «EventConstructor[#function]»); 
return 0;⟫;

//
// Generate C function body. Dispatch mode.
//
// Dispatch rule function: single rule that switches on an initial value before contracting the remainder.
// 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Dispatch[$List[Reified_Rule]] :: Text;

// Generate function body for complete contraction rule set.
{
    #env; 
    "$TopArgs" : TOPARGS[(#formArgument1; #formArguments)]; 
    "$Args"    : LIST_VARIABLE[#args];
}
SF-Dispatch[#rules] → {#env}SF-Dispatch-choice[#formArgument1, #args, #rules];

// Generate choice.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Dispatch-choice[Reified_FormArgument, $List[Text] <!-- top-level arguments -->, $List[Reified_Rule]] :: Text;

// Skip binders...
-[Fresh[dummy::Text]]
:
{#env}SF-Dispatch-choice[FORM-BINDER[#Kind, #BinderSort, v.#Form[v]], (#arg; #args), #Rules]
 →
{#env}SF-Dispatch-choice[#Form[dummy], #args, #Rules]
;

// Dispatch on the first argument. Make sure it's data using FORCE.
-[Fresh[choice::Text]]
:
{
    #env; 
    "$Sink"         : VARIABLE[#sink];
    "$unstep"       : TEXT[#unstep];
    "$unstep-props" : TEXT[#unstep-props]; 
    "$Function"     : STRING_VALUE[#function];
} 
SF-Dispatch-choice[FORM-ARGUMENT[SORT[#sort-name, #sort-params]], (#arg; #args), #rules]
→
%n⟪
FORCE(«#sink»->context, «#arg»);
« Enum[#sort-name] » «choice» = (IS_VARIABLE_USE(«#arg») ? « EnumVar[#sort-name] » : (« Enum[#sort-name] ») TAG(«#arg»));
switch («choice»)
{⟦« {#env}SF-Dispatch-cases[FIRST, #rules, #sort-name] »
default: 
break;⟧
}

/* Fallback. */«#unstep-props»
START(«#sink», «EventConstructor[#function]»);«#unstep»
END(«#sink», «EventConstructor[#function]»); 
return 0;⟫;

// dispatch on single polymorphic variable - just contract.
-[Free[alpha::Reified_Variable]]
:
{#env}SF-Dispatch-choice[FORM-ARGUMENT[SORT-VARIABLE[alpha]], #Args, #Rules] 
→
{#env}SF-Contract[#Rules]
; 

// Generate cases, one per rule.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Dispatch-cases[PASS, $List[Reified_Rule], $String] :: Text;

// Generate switch body for each dispatch rule: case+options+matching, then contraction, finally report success.
{
    #env; 
    "$Sink"    : VARIABLE[#sink]
}
SF-Dispatch-cases[#pass, (RULE[#name, #options, #pattern, #contractum]; #rules), #sort-name]
→
%n⟪« 
    {#env; "$Vars": LIST_VARIABLE[()]}
    SF-pattern-init[OK, #pass, DISPATCH[#name, #options, #sort-name], #pattern, #sink, %n⟨⟩, $False, $False, %n⟨⟩, ok.
    SF-then-eval[ok, %n⟨⟩, #contractum, #sink]] »« 
    {#env}SF-Dispatch-cases[SECOND, #rules, #sort-name] »⟫
;

SF-Dispatch-cases[FIRST,  (), #SortName]    → %n⟪⟫;
SF-Dispatch-cases[SECOND, (), #SortName]    → %n⟪¶}⟫;

// ------------
// Match term against pattern. 
//

//
// Initialize environment before moving on to SF-pattern
//
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-pattern-init[OK_SORT, PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok::OK_SORT.Text] :: Text;

{#env}
SF-pattern-init[OK, #pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{
    #env;
    "$refs"     : LIST_STRING[()];   // Record property references that needs to be unlink before tail-call. 
    "$subrefs"  : LIST_STRING[()];   // Record sub property references that needs to be unlinked upon pattern matching failure. 
    "$terms"    : LIST_VARIABLE[()]; // Record term references that needs to be unlink before  tail-call.   
    "$subterms" : LIST_VARIABLE[()]  // Record sub term references that needs to be unlinked upon pattern matching failure.   
} 
SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern[OK_SORT, PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok¹::OK_SORT.Text] :: Text;

{#env}SF-then-Pattern[OK, #pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→ 
{#env}SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern[PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok::OK_SORT.Text] :: Text;

// Pattern {#REF} prefix: create reference variable (if used).
SF-Pattern-PropertyRef-Discard
:
{#env}SF-Pattern[#pass, #stage, PROPERTY-REF[#ref, DISCARD, #pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]] 
→
$[{#env}IfDef, $[:, "Comparable$", #ref],
    $[Error, "Property reference cannot be compared"],
    {#env}SF-Pattern[#pass, #stage, #pattern, #sink, #setup, $True, #unique, #term, ok¹.
          SF-then-Pattern-Ref[ok¹, $[:,"MetaVar$", #ref], #stage, DISCARD, #sink, #term, o2¹.#[o2¹]]]];

SF-Pattern-PropertyRef-Used
:
{#env}SF-Pattern[#pass, #stage, PROPERTY-REF[#Ref, USE[#Count], #Pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]] 
→
{#env}SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, $True, #unique, #term, ok¹.
      SF-then-Pattern-Ref[ok¹, $[:,"MetaVar$",#Ref], #stage, USE[#Count], #sink, #term, ok¹.#[ok¹]]];

// Pattern {KEY:VALUE} prefix: extract property and match pattern.
SF-Pattern-Property-all
:
{#env}SF-Pattern[#pass, #stage, PROPERTY[#Key, #Value, #Pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]] 
→
{#env}SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, $True, #unique, #term, ok¹.
      SF-then-Pattern-Property[ok¹, SF-is-top-stage[#stage], #pass, #sink, #term, #Key, #Value, ok¹.#[ok¹]]];

// Pattern {¬ KEY} prefix: extract property and check for absence.
SF-Pattern-NotProperty-all 
:
{#env}
SF-Pattern[#pass, #stage, PROPERTY-NOT[#Key, #Pattern], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern[#pass, #stage, #Pattern, #sink, #setup, $True, #unique, #term, ok¹.
SF-then-Pattern-Not-Property[ok¹, SF-is-top-stage[#stage], #sink, #term, #Key, o2¹.#[o2¹]]];

// - DISPATCH stage: ignore function application itself (which is the function) and advance to case generation.
SF-Pattern-Construction-Dispatch
:
{#env}SF-Pattern[#pass, DISPATCH[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, (#binder1; #binders)], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}SF-PatternBinders[#pass, DISPATCH[#name, #options, #sort-name], (#binder1; #binders), #sink, #unique, #term, 0, ok¹.#[ok¹]];

SF-Pattern-Construction-NoBinders-Dispatch 
:
{#env}SF-Pattern[#pass, DISPATCH[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, ()], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}SF-Pattern[#pass, CASE[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, ()], #sink, #setup, $False, #unique, #term, ok¹.#[ok¹]];

// - CASE stage: emit case check and proceed normally.
SF-Pattern-Construction-Case
:
{#env}SF-Pattern[#pass, CASE[#name, #options, #sort-name], CONSTRUCTION[#kind, #symbol, #binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« SF-Pattern-Open[#pass] »
case « EnumTag[#symbol] »: /* Function «COMMENT_TOKEN[#name]» case «COMMENT_TOKEN[#symbol]» */
{⟦«#setup»« 
        {#env}
        F-Options[#options, ok¹.
        SF-then-PatternBinders[ok¹, #pass, CASE[#name, #options, #sort-name], #binders, #sink, #unique, #term, 0, ok¹.#[ok¹]]] »⟧⟫;

// -  MATCH stage: ignore construction itself and process Binders.
SF-Pattern-Construction-Match
:
{#env}SF-Pattern[#pass, MATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »« {#env}SF-PatternBinders[#pass, MATCH, #Binders, #sink, #unique, #term, 0, ok¹.#[ok¹]] »⟫;

// - SUBMATCH stage: force, check, and process argument Binders.
SF-Pattern-Construction-SubMatch-Sub
:
{#env; #term: SUB[#parent, #i, #linked]}
SF-Pattern[#pass, SUBMATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
FORCE(«#sink»->context, «#term»); SUB(«#parent», «INTEGER[#i]») = «#term»;
if (strcmp(SYMBOL(«#term»), «STRING[#Symbol]»)) {«{#env}SF-fail-cleanup[#sink]» break;}« {#env} SF-then-PatternBinders[OK, #pass, SUBMATCH, #Binders, #sink, #unique, #term, 0, ok¹.#[ok¹]] »⟫;

SF-Pattern-Construction-SubMatch-TermArg
:
{#env; #term: ARG[#i, $True]}
SF-Pattern[#pass, SUBMATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
FORCE(«#sink»->context, «#term»); 
if (strcmp(SYMBOL(«#term»), «STRING[#Symbol]»)) {«{#env}SF-fail-cleanup[#sink]» break;}« {#env} SF-then-PatternBinders[OK, #pass, SUBMATCH, #Binders, #sink, #unique, #term, 0, ok¹.#[ok¹]] »⟫;

SF-Pattern-Construction-SubMatch-ClosureArg
:
{#env; #term: ARG[#i, $False]}
SF-Pattern[#pass, SUBMATCH, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
$[Error, "Assertion error: a top-level argument cannot be in a subterm"];

// Pattern "Literal": assume that the literal is there...
SF-Pattern-Literal
:
{#env}
SF-Pattern[#pass, #stage, LITERAL[#Literal, #Type], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪¶/* Ignoring literal «STRING[#Literal]» */« $[If, #needed,#setup,%n⟨⟩] »« {#env} #[OK] »⟫;

// SUBMATCH stage, pattern is free variable (outside meta-application): record the variable.  
SF-Pattern-Variable-Free-Top
:
{#env; #variable : FREE; #term:ARG[#i, #IsTerm]}
SF-Pattern[#pass, SUBMATCH, VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
Variable «#variable» = VARIABLE(«#term»);« {#env} #[OK] »⟫;

// SUBMATCH stage, Pattern is bound variable (outside meta-application).
SF-Pattern-Variable-Bound
:
{#env; #variable : $[NotMatch, FREE, #kind]; #term:SUB[#parent, #i, #linked]}
SF-Pattern[#pass, SUBMATCH, VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »
FORCE(«#sink»->context, «#term»); 
SUB(«#parent», «INTEGER[#i]») = «#term»; 
if («#variable» != VARIABLE(«#term»)) {«{#env}SF-fail-cleanup[#sink]» break;}« {#env} #[OK] »⟫;

// Pattern is variable but before options have been processed.

// - first variable.
SF-Pattern-Variable-Case1 
:
{#env}
SF-Pattern[FIRST, CASE[#Name,#Options,#SortName], VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪
case « EnumVar[#SortName] »: {⟦
« {#env} SF-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok¹.#[ok¹]] »⟧⟫;

// - subsequent variable (always follows another variable).
SF-Pattern-Variable-Case2[Discard[#SortName,#needed,#unique]]
:
{#env}
SF-Pattern[SECOND, CASE[#Name,#Options,#SortName], VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok¹.#[ok¹]];

// Pattern $[...]: in all cases, delegate to E-Pattern. 
{#env}
SF-Pattern[#pass, #stage, EVALUATOR[#Primitive, #Patterns, #Options], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »« {#env; "$tail":NO}E-Pattern[Primitive[#Primitive], #Patterns, #pass, #stage, #sink, #term, ok¹.#[ok¹]] »⟫;

// Pattern #MetaVar[MetaArg...]: store in meta-variable and record argument variables.

SF-Pattern-MetaApplication
:
{#env}
SF-Pattern[#pass, #stage, META-APPLICATION[#MetaVar, #MetaArgs, #Use], #sink, #setup, #needed, #unique, #term, ok¹.#[ok¹]]
→  
{#env}
SF-Pattern-MetaArgs-Norm[{#env}F-Pattern-NeedNorm[#MetaVar,#Use], #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]];

// Helper for generating environment reference meta-variable.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Ref[OK_SORT, $String, Pattern-Stage, Reified_Use, Text, Text, ok¹::OK_SORT.Text] :: Text;

{#env}SF-then-Pattern-Ref[OK, #RefCookie, #stage, #use, #sink, #term, ok¹.#[ok¹]] 
→
{#env}SF-pattern-ref[SF-is-top-stage[#stage], #RefCookie, #stage, #use, #sink, #term, ok¹.#[ok¹]] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-pattern-ref[$Boolean, $String, Pattern-Stage, Reified_Use, Text, Text, ok¹::OK_SORT.Text] :: Text;

// Top-level property ref: no need to link but must record for unlink
-[Data[#refcookie]]
:
{#env; "$TopRef": #propvars; "$refs": LIST_STRING[#refs]}
SF-pattern-ref[$True, #refcookie, #stage, DISCARD, #sink, #term, ok¹.#[ok¹]] 
→
{#env; #refcookie : #propvars; "$refs":LIST_STRING[(#refcookie; #refs)]}#[OK];

// Top-level property ref: used at least once. Top-level: already linked. 
// Don't record for unlink as it's going to be consumed in the contraction.
-[Data[#RefCookie]]
:
{#env; "$TopRef": #propvars}
SF-pattern-ref[$True, #refcookie, #stage, USE[#count], #sink, #term, ok¹.#[ok¹]] 
→
{#env; #refcookie : #propvars}#[OK];

// Sub property ref: case where the properties are discarded. 
// Just store in local variable without owning a reference as it won't be used in the contraction.
-[Fresh[namedP::Text, varP::Text], Data[#RefCookie]]
:
{#env}
SF-pattern-ref[$False, #RefCookie, #stage, DISCARD, #sink, #term, ok¹.#[ok¹]]  
→
%n⟪
NamedPropertyLink «namedP» = NAMED_PROPERTIES(«#term»); permitUnusedNLink(«namedP»);
VariablePropertyLink «varP» = VARIABLE_PROPERTIES(«#term»); permitUnusedVLink(«varP»);
« {#env;  #RefCookie : PROPERTY_VARIABLE[namedP, varP]} #[OK] »⟫;

// Sub property ref: case where the properties is at least used once. Must link.
// Don't record for unlink as it's going to be consumed in the contraction.
// However record for cleanup.
-[Fresh[namedP::Text, varP::Text], Data[#refcookie]]
:
{#env; "$subrefs": LIST_STRING[#subrefs]}
SF-pattern-ref[$False, #refcookie, #stage, USE[#count], #sink, #term, ok¹.#[ok¹]]  
→
%n⟪
NamedPropertyLink «namedP» = LINK_NamedPropertyLink(«#sink»->context, NAMED_PROPERTIES(«#term»));
VariablePropertyLink «varP» = LINK_VariablePropertyLink(«#sink»->context, VARIABLE_PROPERTIES(«#term»));
« {#env;  #refcookie : PROPERTY_VARIABLE[namedP, varP]; "$subrefs": LIST_STRING[(#refcookie; #subrefs)]} #[OK] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Property[OK_SORT, $Boolean<!-- top stage? -->, PASS, Text, Text, Reified_Term, Reified_Term, ok¹::OK_SORT.Text] :: Text;

-[Fresh[value::Text]]
:
{#env}
SF-then-Pattern-Property[OK, #top, #pass, #sink, #term, #Key, #Value, ok¹.#[ok¹]]
→
%n⟪« {#env} SF-set-value[#top, #Key, #sink, #term, value] »
if (!«value») {«{#env}SF-fail-cleanup[#sink]» break;} 
LINK(«#sink»->context, «value»);
int «value»_count = LINK_COUNT(«value»); permitUnusedInt(«value»_count);« {#env; value: ARG[0, $True]} SF-Pattern[#pass, SUBMATCH, #Value, #sink, %n⟨⟩, $False, $True, value, ok¹.#[ok¹]] »⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-set-value[$Boolean<!-- top stage? -->, Reified_Term, Text, Text, Text] :: Text;

{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, META-APPLICATION[#MetaVar, #Args,#count], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = DPROPERTY(«#sink»->context, «#namedP», «#varP», « {#env}MetaVar[#MetaVar] »); permitUnusedTerm(«#value»);⟫;

{#env}
SF-set-value[$False, META-APPLICATION[#MetaVar, #Args,#count], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = PROPERTY(«#sink»->context, «#term», « {#env}MetaVar[#MetaVar] »); permitUnusedTerm(«#value»);⟫;

{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, LITERAL[#Literal, #Sort], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = DNAMED_PROPERTY(«#sink»->context, «#namedP», (char *) «STRING[#Literal]»); permitUnusedTerm(«#value»);⟫;

{#env}
SF-set-value[$False, LITERAL[#Literal, #Sort], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = NAMED_PROPERTY(«#sink»->context, «#term», (char *) «STRING[#Literal]»); permitUnusedTerm(«#value»);⟫;

{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = DNAMED_PROPERTY(«#sink»->context, «#namedP», «STRING[#Symbol]»); permitUnusedTerm(«#value»);⟫;

{#env}
SF-set-value[$False, CONSTRUCTION[#kind, #Symbol, #Binders], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = NAMED_PROPERTY(«#sink»->context, «#term», «STRING[#Symbol]»); permitUnusedTerm(«#value»);⟫;

{#env; "$TopRef":PROPERTY_VARIABLE[#namedP, #varP]}
SF-set-value[$True, VARIABLE-USE[#variable], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = DVARIABLE_PROPERTY(«#varP», «$[Show, #variable]»); permitUnusedTerm(«#value»);⟫;

{#env}SF-set-value[$False, VARIABLE-USE[#variable], #sink, #term, #value] 
→ 
%n⟪
Term «#value» = VARIABLE_PROPERTY(«#term», «$[Show, #variable]»); permitUnusedTerm(«#value»);⟫;

SF-Pattern-Open[PASS] :: Text;

SF-Pattern-Open[FIRST] → %n⟪⟫; 
SF-Pattern-Open[SECOND] → %n⟪
}⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Not-Property[OK_SORT, $Boolean<!-- top stage? -->, Text, Text, Reified_Term, ok¹::OK_SORT.Text] :: Text;

-[Fresh[value::Text]]
:
{#env}SF-then-Pattern-Not-Property[OK, #top, #sink, #term, #Key, ok¹.#[ok¹]]
→
%n⟪« {#env} SF-set-value[#top, #Key, #sink, #term, value] »
if (!«value») {¶⟦«{#env}SF-fail-cleanup[#sink]»¶break;⟧¶}
LINK(«#sink»->context, «value»);« {#env} #[OK] »⟫;

// Helper for processing construction subterms.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-PatternBinders[OK_SORT, PASS, Pattern-Stage, $List[Reified_Binder], Text, $Boolean, Text, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-then-PatternBinders[OK, #pass, #stage, #Binders, #sink, #unique, #term, #index, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternBinders[#pass, #stage, #Binders, #sink, #unique, #term, #index, ok¹.#[ok¹]];

// ------------ Process construction binders, for each stage

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinders[PASS, Pattern-Stage, $List[Reified_Binder], Text, $Boolean, Text, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-PatternBinders[#pass, #stage, (#Binder;#Binders), #sink, #unique, #term, #index, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder[#pass, #stage, HasFunctionalBinders[#Binder], #Binder, #sink, %n⟨⟩, #unique, #term, #index, 0, ok¹.
      SF-then-PatternBinders[ok¹, #pass, #stage, #Binders, #sink, #unique, #term, $[Plus,#index,1], ok¹.#[ok¹]]];

// Pattern arguments []. Done.
{#env}SF-PatternBinders[#pass, #stage, (), #sink, #unique, #term, #index, ok¹.#[ok¹]]
→
{#env}#[OK];

// ------------ Process construction binder, for each stage

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder[PASS, Pattern-Stage, $Boolean, Reified_Binder, Text, Text, $Boolean, Text, $Numeric<!-- Sub Index -->, $Numeric<!-- Binder index -->, ok¹::OK_SORT.Text] :: Text;

// At least one functional binder: hidden in Closure. Just skip so that they are not marked as reusable.
-[Fresh[b::Reified_Variable]]
:
{#env}SF-PatternBinder[#pass, #stage, $True, BINDER[#promisc, #kind, #depth, #sort, #occs, b . #Binder[b]], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder[#pass, #stage, $True, #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// All binders are data. Represent as data
{#env}SF-PatternBinder[#pass, #stage, $False, BINDER[#promisc, KDATA, #depth, #sort, #occs, b . #Binder[b]], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder1[#occs, NOTHING, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// Just an argument. Move on to the term.
{#env}SF-PatternBinder[#pass, #stage, #Has, ARGUMENT[#sort,#Pattern], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternSub[#Pattern, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

/*
 * Analyzes data binder for reuse and extract/record variable 
 *
 * If binder occurs in exactly one meta-application then record a BinderUnique$mv$k$promisc cookie for that meta-application position
 * otherwise record BinderUnique$mv$k$promisc only for the first occurrence.
 *
 */

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder1[$List[Reified_Occurrence], Meta-Occurrence, PASS, Pattern-Stage, Reified_Promiscuity, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#env}SF-PatternBinder1[(META-USE[#mv,#k]; #occs), NOTHING, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder1[#occs, UNIQUE[$[:,"BinderUnique$",#mv,"$",$[FormatNumber, #k],"$",PromiscuityString[#promisc]]], #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

{#env}SF-PatternBinder1[(OTHER; #occs), #state, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[NOTHING, #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

{#env}SF-PatternBinder1[(), #cookie, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[#cookie, #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// This is the second occurrence. Record cookie for the first one only
{#env}SF-PatternBinder1[(META-USE[#mv, #k]; #occs), UNIQUE[#cookie], #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[UNIQUE[#cookie], #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

-[Fallback]
:
{#env}SF-PatternBinder1[#occs, #cookie, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder2[NOTHING, #pass, #stage, SF-is-top-stage[#stage], b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// - then generate and record cookie, binder name, and promiscuity (and recurse).

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder2[Meta-Occurrence, PASS, Pattern-Stage, $Boolean<!-- Top-level? -->, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;

// The binder is on the function. If the function is not shared, then can unbind binder so it can be eventually reused.
{#env; "$Args":LIST_VARIABLE[(#arg; #args)]; "$shared": VARIABLE[#shared]}
SF-PatternBinder2[#cookie, #pass, #stage, $True, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env; "$Args":LIST_VARIABLE[#args]}
SF-PatternBinder3[#arg, #cookie, #pass, #stage, b . #Binder[b], #sink, %n⟪« #code »¶if («#shared» <= 1) ⟦¶UNBIND(«#arg»);⟧⟫, #unique, #term, #i, #j, ok¹.#[ok¹]];

// Get the variable from the term. Same as above: if the term is not shared, then can unbind binder so it can be eventually reused.
-[Fresh[v::Text]]
:
{#env}SF-PatternBinder2[#cookie, #pass, #stage, $False, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env}SF-PatternBinder3[v, #cookie, #pass, #stage, b.#Binder[b], #sink, %n⟪« #code »
Variable «v» = linkVariable(«#sink»->context, BINDER(«#term»,«INTEGER[#i]»,«INTEGER[#j]»)); 
if (« #term »_count <= 1) ⟦¶UNBIND(«v»);⟧⟫, #unique, #term, #i, $[Plus,#j,1], ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternBinder3[Reified_Variable, Meta-Occurrence, PASS, Pattern-Stage, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;

// The variable is use only once in the contraction 
{#env; "$Vars": LIST_VARIABLE[#Vars]}
SF-PatternBinder3[#var, UNIQUE[#cookie], #pass, #stage, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env; #var: BOUND; #cookie: VARIABLE[#var]; "$Vars": LIST_VARIABLE[(#var; #Vars)]}
SF-PatternBinder[#pass, #stage, $False, #Binder[#var], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

// The variable is use only more than once in the contraction
{#env; "$Vars":LIST_VARIABLE[#Vars]}
SF-PatternBinder3[#var, NOTHING, #pass, #stage, b.#Binder[b], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]]
→
{#env; #var: BOUND; "$Vars":  LIST_VARIABLE[(#var; #Vars)]}
SF-PatternBinder[#pass, #stage, $False, #Binder[#var], #sink, #code, #unique, #term, #i, #j, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-Variable-Case[$String, $List[Reified_Option], Text, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - use a do block so failed test can break out.
{#env}SF-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok¹.#[ok¹]] 
→
%n⟪
do {⟦« #setup »« 
    {#env;
        "$Vars" : LIST_VARIABLE[()];    // Keep list of linked variable that needs to be unlinked before contraction.
    } 
    F-Options[#Options, ok.
    SF-then-Pattern-Variable-Use[ok, #Name, #sink, #variable, #term, o2.#[o2]]] »⟧
} while(0);⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Variable-Use[OK_SORT, $String, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - bound variable
{#env}SF-then-Pattern-Variable-Use[OK, #name, #sink, #variable, #term, ok¹.#[ok¹]] 
→
{#env}SF-then-Pattern-Variable-Use2[$[{#env}Get[VARIABLE_ENTRY], #variable, FREE], #name, #sink, #variable, #term, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-Pattern-Variable-Use2[VARIABLE_ENTRY, $String, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - bound variable
{#env}SF-then-Pattern-Variable-Use2[BOUND, #name, #sink, #variable, #term, ok¹.#[ok¹]] 
→
%n⟪¶/* Function «COMMENT_TOKEN[#name]» case for pattern bound variable. */
if («#variable» != VARIABLE(«#term»)) { «{#env}SF-fail-cleanup[#sink]» break;}«{#env}#[OK]»⟫;

// - free variable case is always last
{#env}SF-then-Pattern-Variable-Use2[FREE, #name, #sink, #variable, #term, ok¹.#[ok¹]] 
→
%n⟪/* Function «COMMENT_TOKEN[#name]» fall-back case for free variable */
Variable «#variable» = linkVariable(«#sink»->context, VARIABLE(«#term»));«{#env}#[OK]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-Norm[$Boolean <!-- Need normalization? -->, Pattern-Stage, $String, $List[Reified_Binder], Text, Text, Text, ok::OK_SORT.Text] :: Text;

{#env; #term : SUB[#parent, #i, $True]}
SF-Pattern-MetaArgs-Norm[$True, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→ 
%n⟪« #setup »
UNLINK_SUB(«#sink»->context, «#parent»,  «INTEGER[#i]»); «#term» = NORMALIZEP(«#sink»->context, «#term»); SUB(«#parent»,  «INTEGER[#i]») = LINK(«#sink»->context, «#term»);«
{#env}SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]»⟫;

{#env; #term : ARG[#i, $True]} // Argument is a closure
SF-Pattern-MetaArgs-Norm[$True, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→ 
%n⟪« #setup »
«#term» = NORMALIZEP(«#sink»->context, «#term»);«{#env}SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]»⟫;

{#env; #term : ARG[#i, $False]} // Argument is a term
SF-Pattern-MetaArgs-Norm[$True, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→ 
%n⟪« #setup »«{#env}SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]»⟫;

// No normalization needed. 
{#env}
SF-Pattern-MetaArgs-Norm[$False, #stage, #MetaVar, #MetaArgs, #sink, #setup, #term, ok¹.#[ok¹]]
→
%n⟪« #setup »«{#env}SF-Pattern-MetaArgs-bind[$[:,"MetaVar$",#MetaVar], #MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-Copy[$String, $List[Reified_Binder], Text, Text, ok::OK_SORT.Text] :: Text;

{#env}
SF-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]
→ 
{#env}
SF-Pattern-MetaArgs-bind[$[:,"MetaVar$",#MetaVar], #MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-bind[$String, $String, $List[Reified_Binder], Text, Text, ok::OK_SORT.Text] :: Text;

{#env}
SF-Pattern-MetaArgs-bind[#MetaVarCookie, #MetaVar, #MetaArgs, #sink, #term, ok¹.#[ok¹]]
→
%n⟪¶/* «#term» = « COMMENT_TOKEN[#MetaVar] » */
« {#env; #MetaVarCookie : VARIABLE[#term]}SF-Pattern-MetaArgs[#MetaVar, #MetaArgs, 0, #sink, #term, ok¹.#[ok¹]] »⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs[$String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

// Helper for meta-application variable .
{#env}SF-Pattern-MetaArgs[#MetaVar, (), #index, #sink, #term, ok¹.#[ok¹]]
→
{#env}SF-Pattern-MetaArgs-arity[$[:,#MetaVar,"$arity"], #index, ok¹.#[ok¹]];

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs[#MetaVar, (ARGUMENT[#sort, VARIABLE-USE[variable]]; #MetaArgs), #index, sink, term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern-MetaArgs-variable[$[:,#MetaVar,"$",$[FormatNumber, #index]], $[:,"Reuse$",#MetaVar,"$",$[FormatNumber, #index]], variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}SF-Pattern-MetaArgs-arity[$String, $Numeric, ok::OK_SORT.Text] :: Text;

-[Data[#MetaVarArity]]
:
{#env}
SF-Pattern-MetaArgs-arity[#MetaVarArity, #arity, ok¹.#[ok¹]]
→
{#env; #MetaVarArity : NUM_VALUE[#arity]}
#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-variable[$String, $String, Reified_Variable, $String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs-variable[#MetaVarIndex, #ReuseVar, variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
→
{#env; #MetaVarIndex : VARIABLE[variable]}
SF-Pattern-MetaArgs-variable2[$[{#env}Get[STRING_ENTRY], #ReuseVar, NO], variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-Pattern-MetaArgs-variable2[STRING_ENTRY, Reified_Variable, $String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs-variable2[NO, variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
→
{#env}
SF-Pattern-MetaArgs[#MetaVar, #MetaArgs, $[Plus,#index,1], sink, term, ok¹.#[ok¹]]
;

-[Free[reuse::Text, sink::Text, term::Text, variable::Text]]
:
{#env}
SF-Pattern-MetaArgs-variable2[VARIABLE[reuse], variable, #MetaVar, #MetaArgs, #index, sink, term, ok¹.#[ok¹]]
→
%n⟪Variable «reuse» = «variable»; permitUnusedVariable(«reuse»);
« {#env} SF-Pattern-MetaArgs[#MetaVar, #MetaArgs, $[Plus,#index,1], sink, term, ok¹.#[ok¹]] »⟫
;

// Extract sub. Determine if linking is needed when meta var is not just an intermediary construction.
// The sub can either be on the C function argument list or in a term.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub[Reified_Term, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

{#env}SF-PatternSub[PROPERTY-REF[#Ref, #Use, #Term], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub[#Term,  #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[PROPERTY[#Key, #Value, #Term], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub[#Term, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[PROPERTY-NOT[#Key, #Term], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub[#Term, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[CONSTRUCTION[#kind, #Symbol, #Binder], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[LITERAL[#Value, #Sort], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[VARIABLE-USE[#Variable], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];
 
{#env}SF-PatternSub[META-APPLICATION[#MetaVar, #Binders, USE[#Count]], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→
{#env}SF-PatternSub2[$True, SF-is-top-stage[#stage], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{#env}SF-PatternSub[META-APPLICATION[#MetaVar, #Binders, DISCARD], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];
 
{#env}SF-PatternSub[EVALUATOR[#Primitive, #Patterns, #Options], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2[$False, SF-is-top-stage[#stage], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub2[$Boolean<!-- Whether to link sub -->, $Boolean<!-- Processing top terms -->, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

// Get top-level arguments. No need to link as all top-level arguments have a reference. 
// Might need to unlink if it's a term. 
{#env}SF-PatternSub2[#link, $True, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2a[$[{#env}Get[STRING_ENTRY], "$Args"], #link, $True, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

// A sub to link. Record to unlink only when pattern fails
{#env}SF-PatternSub2[$True, $False, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-PatternSub2b[$[{#env}Get[STRING_ENTRY], "$subterms"], $True, $False, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]];

// A temporary sub. Don't link and don't record for unlink
-[Fresh[sub::Text]]
:
{#env}
SF-PatternSub2[$False, $False, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→
{#env; sub: SUB[#term, #i, $False]}
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #Pattern, #sink, %n⟪« #code »
Term «sub» = SUB(«#term», «INTEGER[#i]»); int «sub»_count = «#term»_count*LINK_COUNT(«sub»); permitUnusedInt(«sub»_count);«D-check-sort[#sink, sub, #sort]»⟫, $False, #unique, sub, ok¹.#[ok¹]];

// Top level argument helper
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub2a[STRING_ENTRY, $Boolean<!-- Whether to link sub -->, $Boolean<!-- Processing top terms -->, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

{#env}SF-PatternSub2a[LIST_VARIABLE[(#arg; #args)], #link, $True, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env; "$Args" : LIST_VARIABLE[#args]} // Navigate to the next argument.
SF-PatternSub3[#arg, $[{#env}Get[VARIABLE_ENTRY], #arg], #link, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] ;

//  Sub argument helper
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub2b[STRING_ENTRY, $Boolean<!-- Whether to link sub -->, $Boolean<!-- Processing top terms -->, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

// A sub to link. Record to unlink only when pattern fails
-[Fresh[sub::Text]]:
{#env}SF-PatternSub2b[LIST_VARIABLE[#subs], $True, $False, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env; sub: SUB[#term, #i, $True]; "$subterms":LIST_VARIABLE[(sub; #subs)]}
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #pattern, #sink, %n⟪« #code »
Term «sub» = LINK(«#sink»->context, SUB(«#term», «INTEGER[#i]»)); int «sub»_count = «#term»_count*LINK_COUNT(«sub»); permitUnusedInt(«sub»_count);«D-check-sort[#sink, sub, #sort]»⟫, $True, #unique, sub, ok¹.#[ok¹]];

// Processing a top-level argument. 
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-PatternSub3[Text, VARIABLE_ENTRY, $Boolean<!-- Whether to link sub -->, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

// Top-level argument is a term and must be linked. No need to record for unlink or cleanup.
{#env; "$shared": VARIABLE[#count]} 
SF-PatternSub3[#arg, ARG[#Index, $True], $True, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}  
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #pattern, #sink, %n⟪« #code »
int «#arg»_count = «#count»*LINK_COUNT(«#arg»); permitUnusedInt(«#arg»_count);«D-check-sort[#sink, #arg, #sort]»⟫, $True, #unique, #arg, ok¹.#[ok¹]];

// Top-level argument is a term and is discarded. Record for unlink, but not cleanup (fallback uses reference).
{#env; "$terms": LIST_VARIABLE[#subs];  "$shared": VARIABLE[#count]} 
SF-PatternSub3[#arg, ARG[#index, $True], $False, #pass, #stage, #sort, #pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env; "$terms":LIST_VARIABLE[(#arg; #subs)]} // Record for unlink
SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #pattern, #sink, %n⟪« #code »
int «#arg»_count = «#count»*LINK_COUNT(«#arg»); permitUnusedInt(«#arg»_count);«D-check-sort[#sink, #arg, #sort]»⟫, $False, #unique, #arg, ok¹.#[ok¹]];

// Top-level argument is a closure. TODO: ref counting is not yet implemented. 
{#env}SF-PatternSub3[#arg, ARG[#index, $False], #link, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, #term, #i, ok¹.#[ok¹]] 
→ 
{#env}SF-Pattern[#pass, SF-move-to-sub-stage[#stage], #Pattern, #sink, #code, $True, #unique, #arg, ok¹.#[ok¹]];

// Stage management.

SF-is-top-stage[Pattern-Stage] :: $Boolean;

SF-is-top-stage[MATCH]                              → $True; 
SF-is-top-stage[SUBMATCH]                           → $False;
SF-is-top-stage[DISPATCH[#Name,#Options,#SortName]] → $True;
SF-is-top-stage[CASE[#Name,#Options,#SortName]]     → $False;


SF-move-to-sub-stage[Pattern-Stage] :: Pattern-Stage;

SF-move-to-sub-stage[MATCH]                              →  SUBMATCH;
SF-move-to-sub-stage[SUBMATCH]                           →  SUBMATCH;
SF-move-to-sub-stage[DISPATCH[#Name,#Options,#SortName]] →  CASE[#Name,#Options,#SortName];
SF-move-to-sub-stage[CASE[#Name,#Options,#SortName]]     →  SUBMATCH;

//
// When pattern matching fails, intermediate linked terms, properties and variables must be unlinked  
//
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-fail-cleanup[Text] :: Text;

{#env;
    "$subrefs"  : LIST_STRING[#refs];    
    "$subterms" : LIST_VARIABLE[#terms] 
}
SF-fail-cleanup[#sink] 
→
%n⟪«{#env}SF-unlink-refs[#sink, #refs]»«{#env}SF-unlink-terms[#sink, #terms]»⟫  
;

//
// Unlink property refs 
//

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}SF-unlink-refs[Text, $List[$String]] :: Text;

{#env}SF-unlink-refs[#sink, ()] → %n⟪⟫;

{#env}SF-unlink-refs[#sink, (#refcookie; #refs)] 
→
%n⟪«{#env}SF-unlink-refs2[#sink, $[{#env}Get[STRING_ENTRY], #refcookie]]»«{#env}SF-unlink-refs[#sink, #refs]»⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-unlink-refs2[Text, STRING_ENTRY] :: Text;

{#env}SF-unlink-refs2[#sink, PROPERTY_VARIABLE[#namedP, #varP]] 
→ 
%n⟪
UNLINK_NamedPropertyLink(«#sink»->context, «#namedP»); 
UNLINK_VariablePropertyLink(«#sink»->context, «#varP»);⟫;


//
// Unlink terms.
//

SF-unlink-terms[Text, $List[Reified_Variable]] :: Text;

SF-unlink-terms[#sink, ()]       → %n⟪⟫; 
SF-unlink-terms[#sink, (#v;#vs)] → %n⟪¶UNLINK(«#sink»->context, «#v»);«SF-unlink-terms[#sink, #vs]»⟫;

// Print a comment indicating the beginning of the unused section.
SF-unlink-comment[$List[$String], $List[Reified_Variable]] :: Text;

SF-unlink-comment[(), ()] → %n⟪⟫; 
SF-unlink-comment[#1, #2] → %n⟪¶¶/* -- Unused terms cleanup -- */⟫; 

// 
// Done matching term against pattern. 
// Unlink unused terms and variable then move on to contraction.  
//
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
SF-then-eval[OK_SORT, Text, Reified_Term, Text] :: Text;

{#env;
    "$refs"     : LIST_STRING[#refs];
    "$terms"    : LIST_VARIABLE[#terms]
}
SF-then-eval[OK, #term, #contractum, #sink]
→
%n⟪«SF-unlink-comment[#refs, #terms]»«{#env}SF-unlink-refs[#sink, #refs]»«{#env}SF-unlink-terms[#sink, #terms]»

/* -- Contraction -- */«{#env; "$tail": YES}ST-then-send[OK, #contractum, #sink]»⟫;


///////////////////////////////////////////////////////////////////////////////////////////////////
)] //SF
